[{"content":"ğŸŒŸ è½»é‡çº§iniæ–‡ä»¶è§£æåº“ ğŸ“Œ é¡¹ç›®ç®€ä»‹ è¿™æ˜¯ä¸€ä¸ªè½»é‡çº§ã€è·¨å¹³å°ã€é«˜æ•ˆä¸” header-only çš„ INI é…ç½®è§£æåº“ï¼Œä¸“ä¸º C++ é¡¹ç›®æ‰“é€ ã€‚å®ƒæä¾›ç®€æ´ã€ç›´è§‚ä¸”ä¼˜é›…çš„ APIï¼Œæ”¯æŒä»æ–‡ä»¶ã€std::istream æˆ– std::string è§£æã€ä¿®æ”¹å¹¶å†™å…¥ INI é…ç½®ä¿¡æ¯ï¼Œå¹¶å…·å¤‡è¡Œçº§æ³¨é‡Šä¿ç•™åŠŸèƒ½ï¼Œç¡®ä¿åŸå§‹æ³¨é‡Šä¸ä¸¢å¤±ï¼Œä½¿é…ç½®ç®¡ç†æ›´åŠ è½»æ¾é«˜æ•ˆã€‚\nä»“åº“åœ°å€: https://github.com/abin-z/IniFile\nğŸš€ ç‰¹æ€§ è½»é‡çº§ \u0026amp; æ— ä¾èµ–ï¼šä»…ä¾èµ– C++11 æ ‡å‡†åº“ï¼Œæ— éœ€é¢å¤–ä¾èµ–é¡¹ æ˜“äºé›†æˆï¼šHeader-only è®¾è®¡ï¼Œå¼€ç®±å³ç”¨ï¼Œè¶³å¤Ÿç®€å• ç›´è§‚ APIï¼šæä¾›æ¸…æ™°å‹å¥½çš„æ¥å£ï¼Œç®€åŒ– INI é…ç½®æ“ä½œ è·¨å¹³å°æ”¯æŒï¼šæ”¯æŒLinux, Windows, MacOSç­‰ç³»ç»Ÿ, ä»¥åŠä¸»æµç¼–è¯‘å™¨ å¤šç§æ•°æ®æºï¼šæ”¯æŒä»æ–‡ä»¶ï¼Œstd::string æˆ– std::istream è§£æ INI æ•°æ®ï¼Œå¹¶å†™å…¥å…¶ä¸­ è‡ªåŠ¨ç±»å‹è½¬æ¢ï¼šæ”¯æŒå¤šç§æ•°æ®ç±»å‹ï¼Œèƒ½è‡ªåŠ¨å¤„ç†ç±»å‹è½¬æ¢(ä¼˜é›…çš„apiæ¥å£) æ”¯æŒæ³¨é‡ŠåŠŸèƒ½: æ”¯æŒiniè¡Œæ³¨é‡Š(;æˆ–è€…#), å¯ä»¥ä¸º[section]å’Œkey=valueæ·»åŠ è¡Œæ³¨é‡Š(ä¸æ”¯æŒè¡Œå°¾æ³¨é‡Š) è‡ªå®šä¹‰ç±»å‹è½¬æ¢: å¯ä»¥è‡ªå®šä¹‰ç±»å‹è½¬æ¢, inifileå°†æ ¹æ®ä½ å†™çš„å®šä¹‰è¿›è¡Œè‡ªåŠ¨è½¬æ¢(å‡å°‘é‡å¤) æ”¯æŒå¤§å°å†™ä¸æ•æ„ŸåŠŸèƒ½: æä¾›å¯é€‰çš„å¤§å°å†™ä¸æ•æ„ŸåŠŸèƒ½(é’ˆå¯¹sectionå’Œkey) é€‚ç”¨äºå¯¹ INI é…ç½®æœ‰ è§£æã€ç¼–è¾‘ã€å­˜å‚¨ éœ€æ±‚çš„ C++ é¡¹ç›®ã€‚ä»¥ä¸‹æ˜¯åŸºç¡€çš„iniæ ¼å¼:\n1 2 3 ; comment [section] key = value æ³¨: æœ¬åº“å†…éƒ¨ä½¿ç”¨std::stringç±»å‹å°è£…filedå€¼, å¯ä»¥å¾ˆå¥½çš„å’Œ UTF-8 ç¼–ç å…¼å®¹, ä½†å…¶ä»–ç¼–ç å…·ä½“æƒ…å†µå¯èƒ½ä¼šæœ‰æ‰€ä¸åŒ.\nğŸ“¦ ä½¿ç”¨æ–¹å¼ æ–¹å¼1: Header-only\nç›´æ¥å°†inifile.hå¤´æ–‡ä»¶å¤åˆ¶åˆ°æ‚¨çš„é¡¹ç›®æ–‡ä»¶å¤¹ä¸­\nç„¶ååœ¨æºä»£ç æ–‡ä»¶ä¸­ç›´æ¥#include \u0026quot;inifile.h\u0026quot;å³å¯ä½¿ç”¨\næ–¹å¼2: ä½¿ç”¨CMake\nåœ¨é¡¹ç›®ä¸­åˆ›å»ºä¸€ä¸ªinifileæ–‡ä»¶å¤¹(åç§°éšæ„)\nå°†æœ¬é¡¹ç›®çš„includeæ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰å†…å®¹å¤åˆ¶åˆ°åˆšæ‰æ­¥éª¤1åˆ›å»ºçš„inifileæ–‡ä»¶å¤¹å†…\nç„¶ååœ¨æ‚¨çš„ä¸»CMakeLists.txtä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹\n1 add_subdirectory(inifile) # inifileä¸ºæ­¥éª¤1åˆ›å»ºçš„æ–‡ä»¶å¤¹åç§° åœ¨æºä»£ç ä¸­æ·»åŠ #include \u0026lt;inifile/inifile.h\u0026gt;å³å¯ä½¿ç”¨\nğŸ› ï¸ åŸºç¡€ä½¿ç”¨æ¡ˆä¾‹ ä¸‹é¢æä¾›ç®€å•çš„ä½¿ç”¨æ¡ˆä¾‹, æ›´å¤šè¯¦ç»†çš„æ¡ˆä¾‹è¯·æŸ¥çœ‹./examples/æ–‡ä»¶å¤¹ä¸‹çš„æ¡ˆä¾‹\nåˆ›å»ºå¹¶ä¿å­˜iniæ–‡ä»¶ 1 2 3 4 5 6 7 8 9 10 11 #include \u0026#34;inifile.h\u0026#34; int main() { constexpr char path[] = \u0026#34;path/to/ini/file\u0026#34;; ini::inifile inif; inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;] = true; inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = 3.14159; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = \u0026#34;value\u0026#34;; // Save the ini file, returns whether the save was successful or not. bool isok = inif.save(path); } è¯»å–iniæ–‡ä»¶ 1 2 3 4 5 6 7 8 9 10 11 #include \u0026#34;inifile.h\u0026#34; int main() { constexpr char path[] = \u0026#34;path/to/ini/file\u0026#34;; ini::inifile inif; // Load the ini file, return whether the loading was successful or not. bool isok = inif.load(path); bool b = inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;]; double d = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::string s = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; } streamæµä¸­è¯»/å†™iniä¿¡æ¯ æ”¯æŒstreamæµ, å…è®¸ä»std::istreamæµä¸­è¯»å–iniæ•°æ®, ä¹Ÿèƒ½å‘std::ostreamä¸­å†™å…¥iniæ•°æ®.\n1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { // create istream object \u0026#34;is\u0026#34; ... ini::inifile inif; inif.read(is); } 1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { // create ostream object \u0026#34;os\u0026#34; ... ini::inifile inif; inif.write(os); } std::stringä¸­è¯»å†™iniä¿¡æ¯ æ”¯æŒä»std::stringä¸­è¯»å–iniæ•°æ®, ä¹Ÿèƒ½å°†inifile è½¬ä¸ºstd::string.\n1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { // create string object \u0026#34;s\u0026#34; ... ini::inifile inif; inif.from_string(s); } 1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;] = \u0026#34;value\u0026#34;; std::string s = inif.to_string(); } è®¾ç½®å€¼ è¯´æ˜: è‹¥section-keyä¸å­˜åœ¨, operator[]æ“ä½œç¬¦å’Œsetå‡½æ•°ä¼šç›´æ¥æ’å…¥section-key, è‹¥section-keyå­˜åœ¨åˆ™æ›´æ–°fieldå€¼.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; /// Setting a single value inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = \u0026#34;value\u0026#34;; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;].set(\u0026#34;hello\u0026#34;); inif.set(\u0026#34;section\u0026#34;, \u0026#34;key3\u0026#34;, true); inif[\u0026#34;section\u0026#34;].set(\u0026#34;key4\u0026#34;, 3.14159); /// Setting multiple values for the same section, supporting different types inif[\u0026#34;section2\u0026#34;].set({{\u0026#34;bool\u0026#34;, false}, {\u0026#34;int\u0026#34;, 123}, {\u0026#34;double\u0026#34;, 999.888}, {\u0026#34;string\u0026#34;, \u0026#34;ABC\u0026#34;}, {\u0026#34;char\u0026#34;, \u0026#39;m\u0026#39;}}); } è·å–å€¼ è¯´æ˜: è·å–å€¼çš„æ—¶å€™éœ€è¦æ³¨æ„ä»¥ä¸‹ä¸¤ç‚¹:\nç»™å®šçš„section-keyæ˜¯å¦å­˜åœ¨, å½“section-keyä¸å­˜åœ¨æ—¶è°ƒç”¨ä¸åŒçš„å‡½æ•°ä¼šæœ‰ä¸åŒçš„å¤„ç†ç­–ç•¥; ä½¿ç”¨operator[]è¿”å›å¼•ç”¨, è‹¥ç»™å®šsectionæˆ–keyä¸å­˜åœ¨åˆ™ä¼šæ’å…¥ç©ºçš„fieldå€¼, å¹¶è®¾ç½®fieldä¸ºç©ºå­—ç¬¦ä¸². (è¡Œä¸ºç±»ä¼¼std::mapçš„[]) ä½¿ç”¨get()å‡½æ•°è¿”å›å€¼, è‹¥ç»™å®šçš„sectionæˆ–keyä¸å­˜åœ¨ä¸ä¼šæ’å…¥field, è€Œæ˜¯è¿”å›ä¸€ä¸ªé»˜è®¤çš„ç©ºfieldå€¼(å¯ä»¥æŒ‡å®šé»˜è®¤å€¼). ä½¿ç”¨at()å‡½æ•°è¿”å›å¼•ç”¨, è‹¥ç»™å®šçš„sectionæˆ–keyä¸å­˜åœ¨åˆ™æŠ›å‡ºå¼‚å¸¸ : std::out_of_range æ˜¯å¦å¯ä»¥æ‰§è¡Œç±»å‹è‡ªåŠ¨è½¬æ¢, ä»¥ä¸Šä¸‰ä¸ªå‡½æ•°è¿”å›çš„æ˜¯ ini::field åŒ…è£…å¯¹è±¡, è‹¥å°†è¯¥å¯¹è±¡è½¬ä¸ºå…¶ä»–ç±»å‹éœ€æ³¨æ„: ç±»å‹è½¬æ¢æ˜¯å¦å…è®¸, è‹¥ç±»å‹è½¬æ¢ä¸å…è®¸åˆ™æŠ›å‡ºå¼‚å¸¸: std::invalid_argument, (ä¾‹å¦‚å°†\u0026quot;abc\u0026quot;è½¬ä¸ºint) æ•°å€¼ç±»å‹è½¬æ¢èŒƒå›´æ˜¯å¦æº¢å‡º, è‹¥è¶…å‡ºç›®æ ‡ç±»å‹çš„èŒƒå›´åˆ™æŠ›å‡ºå¼‚å¸¸: std::out_of_range, (ä¾‹å¦‚å°†INT_MAXè½¬ä¸ºuint8_t) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; /// automatic type conversion std::string s0 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; bool isok = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; int ii0 = inif.get(\u0026#34;section\u0026#34;, \u0026#34;key3\u0026#34;); int ii2 = inif.get(\u0026#34;section\u0026#34;, \u0026#34;key3\u0026#34;, -1); // Specify default values std::string ss2 = inif[\u0026#34;section\u0026#34;].get(\u0026#34;key4\u0026#34;); std::string ss3 = inif[\u0026#34;section\u0026#34;].get(\u0026#34;key5\u0026#34;, \u0026#34;default\u0026#34;); // Specify default values double dd0 = inif.at(\u0026#34;section\u0026#34;).at(\u0026#34;key\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;section-key:\u0026#34; \u0026lt;\u0026lt; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;].as\u0026lt;double\u0026gt;() \u0026lt;\u0026lt; std::endl; } æ³¨é‡ŠåŠŸèƒ½ æœ¬åº“æ”¯æŒè®¾ç½®[section]å’Œkey=valueçš„è¡Œçº§æ³¨é‡Š(ä¸æ”¯æŒè¡Œå°¾æ³¨é‡Š), æ³¨é‡Šç¬¦å·å¯é€‰;å’Œ#ä¸¤ç§; ä¹Ÿèƒ½ä»æ•°æ®æºä¸­ä¿ç•™æ³¨é‡Šå†…å®¹.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; // Set value inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;] = true; inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = 3.141592; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = \u0026#34;value\u0026#34;; // Add comments if necessary inif[\u0026#34;section\u0026#34;].set_comment(\u0026#34;This is a section comment.\u0026#34;); // set section comment, Overwrite Mode inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;].set_comment(\u0026#34;This is a key-value pairs comment\u0026#34;, \u0026#39;#\u0026#39;); // set key=value pairs comment inif[\u0026#34;section\u0026#34;].clear_comment(); // clear section comments inif[\u0026#34;section\u0026#34;].add_comment(\u0026#34;section comment01\u0026#34;); // add section comment, Append Mode inif[\u0026#34;section\u0026#34;].add_comment(\u0026#34;section comment02\\nsection comment03\u0026#34;); // Multi-line comments are allowed, lines separated by `\\n` bool isok = inif.save(\u0026#34;config.ini\u0026#34;); } config.iniçš„å†…å®¹åº”è¯¥ä¸º:\n1 2 3 4 5 6 7 8 ; section comment01 ; section comment02 ; section comment03 [section] key0=true # This is a key-value pairs comment key1=3.141592 key2=value å¤§å°å†™ä¸æ•æ„ŸåŠŸèƒ½ æœ¬åº“æ”¯æŒsectionå’Œkeyçš„å¤§å°å†™ä¸æ•æ„ŸåŠŸèƒ½, ä½¿ç”¨ini::case_insensitive_inifileå³å¯, å…·ä½“æ¡ˆä¾‹è¯·ç‚¹å‡»æŸ¥çœ‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;inifile.h\u0026#34; int main() { const char *str = R\u0026#34;( [Section] KEY=Value Flag=123 hello=world )\u0026#34;; ini::case_insensitive_inifile inif; // Create a case-insensitive INI file object inif.from_string(str); // Read INI data from string // Test case-insensitive section and key access std::cout \u0026lt;\u0026lt; \u0026#34;inif.contains(\\\u0026#34;Section\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.contains(\u0026#34;Section\u0026#34;) \u0026lt;\u0026lt; std::endl; // true std::cout \u0026lt;\u0026lt; \u0026#34;inif.contains(\\\u0026#34;SECTION\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.contains(\u0026#34;SECTION\u0026#34;) \u0026lt;\u0026lt; std::endl; // true std::cout \u0026lt;\u0026lt; \u0026#34;inif.contains(\\\u0026#34;SeCtIoN\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.contains(\u0026#34;SeCtIoN\u0026#34;) \u0026lt;\u0026lt; std::endl; // true std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;section\\\u0026#34;).contains(\\\u0026#34;key\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;section\u0026#34;).contains(\u0026#34;key\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;section\\\u0026#34;).contains(\\\u0026#34;Key\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;section\u0026#34;).contains(\u0026#34;Key\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;SECTION\\\u0026#34;).contains(\\\u0026#34;KEY\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;SECTION\u0026#34;).contains(\u0026#34;KEY\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;SECTION\\\u0026#34;).contains(\\\u0026#34;flag\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;SECTION\u0026#34;).contains(\u0026#34;flag\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;SECTION\\\u0026#34;).contains(\\\u0026#34;FLAG\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;SECTION\u0026#34;).contains(\u0026#34;FLAG\u0026#34;) \u0026lt;\u0026lt; std::endl; return 0; } å…³äºè‡ªåŠ¨ç±»å‹è½¬æ¢ è‡ªåŠ¨ç±»å‹è½¬æ¢ä½œç”¨åœ¨ini::fieldå¯¹è±¡ä¸Š, å…è®¸ini::field \u0026lt;=\u0026gt; other typeäº’ç›¸è½¬æ¢; ä½†æ˜¯éœ€è¦æ³¨æ„: è‹¥è½¬æ¢å¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026#34;inifile.h\u0026#34; int main() { /// other type -\u0026gt; ini::field ini::field f(true); ini::field f1(10); ini::field f2 = 3.14; ini::field f3 = \u0026#39;c\u0026#39;; ini::field f4 = \u0026#34;abc\u0026#34;; /// ini::field -\u0026gt; other type bool b = f; int i = f1; double d = f2; char c = f3; std::string s = f4; ini::inifile inif; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;] = true; // bool -\u0026gt; ini::field /// Get direct type(ini::field) auto val = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; // val type is ini::field ini::field val2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; /// explicit type conversion bool bb = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;].as\u0026lt;bool\u0026gt;(); /// automatic type conversion bool bb2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; /// Type conversion failure throws an exception double n = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; // error: Converting true to double is not allowed. } æ”¯æŒè‡ªåŠ¨è½¬æ¢çš„ç±»å‹åŒ…æ‹¬:\nbool char, signed char, unsigned char short, unsigned short int, unsigned int long, unsigned long long long, unsigned long long float double long double std::string const char * std::string_view (C++17) è‡ªå®šä¹‰ç±»å‹è½¬æ¢ Q: ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹å¯ä»¥åƒä¸Šé¢æåˆ°çš„åŸºæœ¬æ•°æ®ç±»å‹ä¸€æ ·è‡ªåŠ¨è½¬æ¢å—?\nA: ä¹Ÿæ˜¯å¯ä»¥çš„, åªéœ€è¦æŒ‰ä»¥ä¸‹è§„åˆ™è‡ªå®šä¹‰ç±»å‹è½¬æ¢å°±èƒ½è®©inifileè‡ªåŠ¨å¤„ç†ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹.\nä½ å¯ä»¥ä¸ºç”¨æˆ·è‡ªå®šä¹‰ç±»å‹æä¾›è‡ªåŠ¨ç±»å‹è½¬æ¢çš„ç‰¹åŒ–æ¨¡æ¿ç±», å®ƒèƒ½è®©inifileåº“æ ¹æ®ä½ å®šä¹‰çš„è§„åˆ™è¿›è¡Œè‡ªåŠ¨è½¬æ¢, ä½¿å…¶å¯ä»¥å°†è‡ªå®šä¹‰ç±»å­˜å‚¨åœ¨iniå­—æ®µä¸­, è¿™æ ·å¯ä»¥å¤§å¹…å‡å°‘ä»£ç çš„é‡å¤. ä»¥ä¸‹æ˜¯è‡ªå®šä¹‰è§„åˆ™å’Œæ¨¡æ¿:\nä½¿ç”¨INIFILE_TYPE_CONVERTERå®ç‰¹åŒ–è‡ªå®šä¹‰çš„ç±»å‹(å¿…é¡»æä¾›é»˜è®¤æ„é€ å‡½æ•°);\nå®šä¹‰encodeå‡½æ•°, ä½œç”¨æ˜¯å®šä¹‰å¦‚ä½•å°†è‡ªå®šä¹‰ç±»å‹è½¬ä¸ºiniå­˜å‚¨å­—ç¬¦ä¸²(å­˜å‚¨å­—ç¬¦ä¸²ä¸èƒ½åŒ…å«æ¢è¡Œç¬¦);\nå®šä¹‰decodeå‡½æ•°, ä½œç”¨æ˜¯å®šä¹‰å¦‚ä½•å°†iniå­˜å‚¨å­—ç¬¦ä¸²è½¬ä¸ºè‡ªå®šä¹‰ç±»å‹;\n1 2 3 4 5 6 7 8 9 10 11 12 13 /// Specialized type conversion template template \u0026lt;\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;CustomClass\u0026gt; // User-defined type `CustomClass` { void encode(const CustomClass \u0026amp;obj, std::string \u0026amp;value) // pass by reference { // Convert the CustomClass object `obj` to ini storage string `value` } void decode(const std::string \u0026amp;value, CustomClass \u0026amp;obj) { // Convert the ini storage string `value` to a CustomClass object `obj` } } ä¸ºäº†æ–¹ä¾¿ç¼–å†™ encode å’Œ decode å‡½æ•°, æœ¬åº“æä¾›äº† ini::join, ini::split() å’Œ ini::trim() å·¥å…·å‡½æ•°\næ¡ˆä¾‹1: ä¸‹é¢æ˜¯å°†ä¸€ä¸ªç”¨æˆ·è‡ªå®šä¹‰ç±»Personå¯¹è±¡è½¬ä¸ºiniå­—æ®µæ¡ˆä¾‹. ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /// @brief User-defined classes struct Person { Person() = default; // Must have a default constructor Person(int id, int age, const std::string \u0026amp;name) : id(id), age(age), name(name) {} int id = 0; int age = 0; std::string name; }; /// @brief Custom type conversion (Use INIFILE_TYPE_CONVERTER to specialize Person) template \u0026lt;\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;Person\u0026gt; { // \u0026#34;Encode\u0026#34; the Person object into a value string void encode(const Person \u0026amp;obj, std::string \u0026amp;value) { const char delimiter = \u0026#39;,\u0026#39;; // Format: id,age,name; Note: Please do not include line breaks in the value string value = std::to_string(obj.id) + delimiter + std::to_string(obj.age) + delimiter + obj.name; } // \u0026#34;Decode\u0026#34; the value string into a Person object void decode(const std::string \u0026amp;value, Person \u0026amp;obj) { const char delimiter = \u0026#39;,\u0026#39;; std::vector\u0026lt;std::string\u0026gt; info = ini::split(value, delimiter); // Exception handling can be added obj.id = std::stoi(info[0]); obj.age = std::stoi(info[1]); obj.name = info[2]; } }; int main() { ini::inifile inif; Person p = Person{123456, 18, \u0026#34;abin\u0026#34;}; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;] = p; // set person object Person pp = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; // get person object } æ¡ˆä¾‹2: å¯ä»¥åµŒå¥—è°ƒç”¨INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt;, å®ç°STLå®¹å™¨è‡ªåŠ¨è½¬æ¢, èƒ½å®ç°ä»¥ä¸‹ç›´æ¥å¯¹å®¹å™¨èµ‹å€¼æˆ–å–å€¼çš„æ•ˆæœ, å…·ä½“å®ç°è¯·ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Define vectors of different types std::vector\u0026lt;int\u0026gt; vec1 = {1, 2, 3, 4, 5}; std::vector\u0026lt;double\u0026gt; vec2 = {1.1111, 2.2222, 3.3333, 4.4444, 5.5555}; std::vector\u0026lt;std::string\u0026gt; vec3 = {\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;, \u0026#34;eee\u0026#34;}; // Set different types of vectors in the INI file object inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = vec1; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = vec2; inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;] = vec3; // Get different vectors from INI file object std::vector\u0026lt;int\u0026gt; v1 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::vector\u0026lt;double\u0026gt; v2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; std::vector\u0026lt;std::string\u0026gt; v3 = inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;]; å…¶ä»–å·¥å…·å‡½æ•° æä¾›å…¶ä»–å¤šç§å·¥å…·å‡½æ•°, åˆ¤æ–­æ˜¯å¦ä¸ºç©ºempty(), æŸ¥è¯¢æ€»ä¸ªæ•°size(), æŸ¥è¯¢keyçš„ä¸ªæ•°count(), æ˜¯å¦åŒ…å«å…ƒç´ contains(), æŸ¥æ‰¾å…ƒç´ find(), ç§»é™¤å…ƒç´ remove() å’Œ erase(), æ¸…é™¤æ‰€æœ‰å…ƒç´ clear(), è¿­ä»£å™¨è®¿é—®:begin(), end(), cbegin(), cend(), æ”¯æŒèŒƒå›´forå¾ªç¯. å…·ä½“è¯¦æƒ…è¯·æŸ¥çœ‹å¸¸ç”¨ API è¯´æ˜.\nä¸‹é¢æä¾›ä¸€ä¸ªè¿­ä»£å™¨è®¿é—®iniä¿¡æ¯:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026#34;inifile.h\u0026#34; int main() { constexpr char path[] = \u0026#34;path/to/ini/file\u0026#34;; ini::inifile inif; bool isok = inif.load(path); for (const auto \u0026amp;sec_pair : inif) { const std::string \u0026amp;section_name = sec_pair.first; const ini::section \u0026amp;section = sec_pair.second; std::cout \u0026lt;\u0026lt; \u0026#34; section \u0026#39;\u0026#34; \u0026lt;\u0026lt; section_name \u0026lt;\u0026lt; \u0026#34;\u0026#39; has \u0026#34; \u0026lt;\u0026lt; section.size() \u0026lt;\u0026lt; \u0026#34; key-values.\u0026#34; \u0026lt;\u0026lt; std::endl; for (const auto \u0026amp;kv : section) { const std::string \u0026amp;key = kv.first; const auto \u0026amp;value = kv.second; std::cout \u0026lt;\u0026lt; \u0026#34; kv: \u0026#39;\u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34;\u0026#39; = \u0026#39;\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; std::endl; } } } ğŸ“„ å¸¸ç”¨APIè¯´æ˜ class ç±»å‹è¯´æ˜ classåç§° æè¿° ini::inifile å¯¹åº”æ•´ä¸ªiniæ•°æ®, åŒ…å«äº†æ‰€æœ‰çš„section ini::section å¯¹åº”æ•´ä¸ªsectionå†…å®¹, é‡Œé¢åŒ…å«äº†æœ¬sectionæ‰€æœ‰çš„key-valueå€¼ ini::case_insensitive_inifile å¯¹sectionå’Œkeyå¤§å°å†™ä¸æ•æ„Ÿ, å…¶ä»–åŠŸèƒ½å’Œini::inifileä¸€è‡´ ini::case_insensitive_section å¯¹keyå¤§å°å†™ä¸æ•æ„Ÿ, å…¶ä»–åŠŸèƒ½å’Œini::sectionä¸€è‡´ ini::field å¯¹åº”iniæ–‡ä»¶ä¸­çš„ value å­—æ®µ, æ”¯æŒå¤šç§æ•°æ®ç±»å‹, æ”¯æŒè‡ªåŠ¨ç±»å‹è½¬æ¢ ini::fieldç±»APIè¯´æ˜ ç‚¹å‡»å±•å¼€ ä»¥ä¸‹å‡½æ•°ç±»å‹è½¬æ¢å¤±è´¥æˆ–è€…å€¼æº¢å‡ºå°†æŠ›å¼‚å¸¸\nå‡½æ•°å å‡½æ•°ç­¾å åŠŸèƒ½æè¿° field field(const T \u0026amp;other) æ„é€ fieldå¯¹è±¡, å°†Tç±»å‹è½¬ä¸ºfieldå€¼ set void set(const T \u0026amp;value) è®¾ç½®fieldå€¼, å°†Tç±»å‹è½¬ä¸ºfieldå€¼ operator= field \u0026amp;operator=(const T \u0026amp;rhs) è®¾ç½®fieldå€¼, å°†Tç±»å‹è½¬ä¸ºfieldå€¼ operator T operator T() const å°†fieldç±»å‹è½¬ä¸ºTç±»å‹ as T as() const å°†fieldç±»å‹è½¬ä¸ºTç±»å‹ set_comment void set_comment(const std::string \u0026amp;str, char symbol = ';') è®¾ç½®key-valueçš„æ³¨é‡Š, è¦†ç›–æ¨¡å¼ add_comment void add_comment(const std::string \u0026amp;str, char symbol = ';') æ·»åŠ key-valueçš„æ³¨é‡Š, è¿½åŠ æ¨¡å¼ clear_comment void clear_comment() æ¸…é™¤key-valueçš„æ³¨é‡Š ini::sectionç±»APIè¯´æ˜ ç‚¹å‡»å±•å¼€ å‡½æ•°å å‡½æ•°ç­¾å åŠŸèƒ½æè¿° operator[] field \u0026amp;operator[](const std::string \u0026amp;key) è¿”å›ini::fieldå¼•ç”¨, ä¸å­˜åœ¨åˆ™æ’å…¥ç©ºini::field set void set(std::string key, T \u0026amp;\u0026amp;value) æ’å…¥æˆ–æ›´æ–°æŒ‡å®škeyçš„field contains bool contains(std::string key) const åˆ¤æ–­keyæ˜¯å¦å­˜åœ¨ at field \u0026amp;at(std::string key) è¿”å›æŒ‡å®škeyé”®çš„å…ƒç´ çš„å­—æ®µå€¼çš„å¼•ç”¨ã€‚å¦‚æœå…ƒç´ ä¸å­˜åˆ™æŠ› std::out_of_rangeå¼‚å¸¸ get field get(std::string key, field default_value = field{}) const è·å–keyå¯¹åº”çš„å€¼(å‰¯æœ¬), è‹¥keyä¸å­˜åœ¨åˆ™è¿”å›default_valueé»˜è®¤å€¼ find iterator find(const key_type \u0026amp;key) æŸ¥æ‰¾æŒ‡å®škeyå€¼çš„è¿­ä»£å™¨, ä¸å­˜åœ¨è¿”å›endè¿­ä»£å™¨ erase iterator erase(iterator pos) åˆ é™¤æŒ‡å®šè¿­ä»£å™¨çš„key-valueé”®å€¼å¯¹ remove bool remove(std::string key) åˆ é™¤æŒ‡å®šçš„key-valueé”®å€¼å¯¹, è‹¥ä¸å­˜åœ¨åˆ™ä»€ä¹ˆéƒ½ä¸åš empty bool empty() const noexcept åˆ¤æ–­key-valueé”®å€¼å¯¹æ˜¯å¦ä¸ºç©º, ä¸ºç©ºè¿”å›true clear void clear() noexcept æ¸…é™¤æ‰€æœ‰key - valueé”®å€¼å¯¹ size size_type size() const noexcept è¿”å›æœ‰å¤šå°‘key - valueé”®å€¼å¯¹ count size_type count(const key_type \u0026amp;key) const è¿”å›æœ‰å¤šå°‘æŒ‡å®škeyçš„key - valueé”®å€¼å¯¹ begin iterator begin() noexcept è¿”å›èµ·å§‹è¿­ä»£å™¨ end iterator end() noexcept è¿”å›æœ«å°¾è¿­ä»£å™¨ set_comment void set_comment(const std::string \u0026amp;str, char symbol = ';') è®¾ç½®sectionçš„æ³¨é‡Š, è¦†ç›–æ¨¡å¼, æ³¨é‡Šå­—ç¬¦ä¸²å…è®¸æ¢è¡Œ\\n add_comment void add_comment(const std::string \u0026amp;str, char symbol = ';') æ·»åŠ sectionçš„æ³¨é‡Š, è¿½åŠ æ¨¡å¼, æ³¨é‡Šå­—ç¬¦ä¸²å…è®¸æ¢è¡Œ\\n clear_comment void clear_comment() æ¸…é™¤sectionçš„æ³¨é‡Š ini::inifileç±»APIè¯´æ˜ ç‚¹å‡»å±•å¼€ å‡½æ•°å å‡½æ•°ç­¾å åŠŸèƒ½æè¿° operator[] section \u0026amp;operator[](const std::string \u0026amp;section) è¿”å›ini::sectionå¼•ç”¨, ä¸å­˜åœ¨åˆ™æ’å…¥ç©ºini::section set void set(const std::string \u0026amp;section, const std::string \u0026amp;key, T \u0026amp;\u0026amp;value) è®¾ç½®section key-value contains bool contains(std::string section) const åˆ¤æ–­æŒ‡å®šçš„sectionæ˜¯å¦å­˜åœ¨ contains bool contains(std::string section, std::string key) const åˆ¤æ–­æŒ‡å®šsectionä¸‹æŒ‡å®šçš„keyæ˜¯å¦å­˜åœ¨ at section \u0026amp;at(std::string section) è¿”å›æŒ‡å®šsectionçš„å¼•ç”¨ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„å…ƒç´ ï¼Œåˆ™ä¼šæŠ›å‡º std::out_of_range ç±»å‹çš„å¼‚å¸¸ get field get(std::string sec, std::string key, field default_value = field{}) const è¿”å›æŒ‡å®šsectionçš„æŒ‡å®škeyé”®çš„å­—æ®µå€¼, è‹¥sectionæˆ–keyä¸å­˜åœ¨åˆ™è¿”å›é»˜è®¤å€¼default_value find iterator find(const key_type \u0026amp;key) æŸ¥æ‰¾æŒ‡å®šsectionçš„è¿­ä»£å™¨, ä¸å­˜åœ¨è¿”å›endè¿­ä»£å™¨ erase iterator erase(iterator pos) åˆ é™¤æŒ‡å®šè¿­ä»£å™¨çš„section(åŒ…æ‹¬å…¶æ‰€æœ‰å…ƒç´ ) remove bool remove(std::string sec) åˆ é™¤æŒ‡å®šçš„section(åŒ…æ‹¬å…¶æ‰€æœ‰å…ƒç´ ) empty bool empty() const noexcept åˆ¤æ–­æ˜¯å¦æ²¡æœ‰section, æ²¡æœ‰sectionç©ºè¿”å›true clear void clear() noexcept æ¸…ç©ºæ‰€æœ‰çš„section size size_type size() const noexcept è¿”å›æœ‰å¤šå°‘section count size_type count(const key_type \u0026amp;key) const è¿”å›æœ‰å¤šå°‘æŒ‡å®šsection-nameçš„section begin iterator begin() noexcept è¿”å›èµ·å§‹è¿­ä»£å™¨ end iterator end() noexcept è¿”å›æœ«å°¾è¿­ä»£å™¨ read void read(std::istream \u0026amp;is) ä»istreamä¸­è¯»å–iniä¿¡æ¯ write void write(std::ostream \u0026amp;os) const å‘ostreamä¸­å†™å…¥iniä¿¡æ¯ from_string void from_string(const std::string \u0026amp;str) ä»stringä¸­è¯»å–iniä¿¡æ¯ to_string std::string to_string() const å°†inifileå¯¹è±¡è½¬ä¸ºå¯¹åº”å­—ç¬¦ä¸² load bool load(const std::string \u0026amp;filename) ä»iniæ–‡ä»¶ä¸­åŠ è½½iniä¿¡æ¯, è¿”å›æ˜¯å¦æˆåŠŸ save bool save(const std::string \u0026amp;filename) å°†iniä¿¡æ¯ä¿å­˜åˆ°iniæ–‡ä»¶, è¿”å›æ˜¯å¦æˆåŠŸ ","date":"2025-05-04T22:05:03+08:00","permalink":"https://abin-z.github.io/p/%E8%BD%BB%E9%87%8F%E7%BA%A7ini%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%BA%93inifile/","title":"è½»é‡çº§INIé…ç½®è§£æåº“(IniFile)"},{"content":"ä¸€ä¸ªè·¨å¹³å°, ç®€å•æ˜“ç”¨çš„Header-onlyçº¿ç¨‹æ± åº“, åŸºäºTaskæäº¤, æ”¯æŒæäº¤ä»»æ„å‚æ•°æäº¤, æ”¯æŒè·å–è¿”å›å€¼.\nGitHubä»“åº“åœ°å€\nğŸ“Œ çº¿ç¨‹æ± ç®€ä»‹ çº¿ç¨‹æ± ï¼ˆThread Poolï¼‰æ˜¯ä¸€ç§åŸºäºæ± åŒ–æ€æƒ³ç®¡ç†çº¿ç¨‹çš„å·¥å…·ï¼Œç»å¸¸å‡ºç°åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ã€‚\nå®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼šé¢„å…ˆåˆ›å»ºä¸€å®šæ•°é‡çš„çº¿ç¨‹æ”¾åœ¨â€œæ± å­â€é‡Œï¼Œä»»åŠ¡æ¥äº†å°±æŠŠä»»åŠ¡äº¤ç»™ç©ºé—²çš„çº¿ç¨‹æ¥å¤„ç†ï¼Œè€Œä¸æ˜¯æ¯æ¬¡éƒ½æ–°å»ºçº¿ç¨‹ã€‚\nğŸš€ç‰¹æ€§äº®ç‚¹ ä»»åŠ¡æäº¤çµæ´»ï¼šæ”¯æŒä»»æ„å¯è°ƒç”¨å¯¹è±¡ä¸å‚æ•°ç»„åˆï¼Œè¿”å› std::future\u0026lt;T\u0026gt; è·å–æ‰§è¡Œç»“æœ çº¿ç¨‹å®‰å…¨ï¼šä½¿ç”¨ std::mutex / std::condition_variable / std::atomic æ„å»ºåŒæ­¥æœºåˆ¶ è·¨å¹³å°ï¼šçº¯ C++11 å®ç°ï¼Œå…¼å®¹ Windows ä¸ POSIX ç­‰ç³»ç»Ÿ Header-onlyï¼šä»…éœ€åŒ…å« thread_pool.hï¼Œé›¶ä¾èµ–ï¼Œå³å¯ä½¿ç”¨ RAII è‡ªåŠ¨ç®¡ç†èµ„æºï¼šææ„æ—¶è‡ªåŠ¨å…³é—­çº¿ç¨‹æ± ï¼Œé˜²æ­¢èµ„æºæ³„éœ² ä»»åŠ¡ç­‰å¾…æœºåˆ¶ï¼šæ”¯æŒä¸»åŠ¨è°ƒç”¨ wait_all() ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ çµæ´»å…³é—­ç­–ç•¥ï¼šé»˜è®¤æ˜¯è‡ªåŠ¨å…³é—­çº¿ç¨‹æ± çš„, å¦‚æœæœ‰éœ€è¦å¯ä»¥æ‰‹åŠ¨å…³é—­çº¿ç¨‹æ± : WaitForAllTasks: ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆåå…³é—­ DiscardPendingTasks: ä¸¢å¼ƒæœªå¼€å§‹çš„ä»»åŠ¡ç«‹å³å…³é—­ ğŸ“¦ å¿«é€Ÿå¼€å§‹ å®‰è£…ä½¿ç”¨ æ‹·è´thread_pool.håˆ°ä½ çš„é¡¹ç›®ç›®å½•ï¼Œç„¶ååœ¨ä»£ç ä¸­å¼•å…¥ï¼š\n1 #include \u0026#34;thread_pool.h\u0026#34; æ— éœ€é¢å¤–ä¾èµ–ï¼Œå®Œå…¨å¤´æ–‡ä»¶å®ç°ã€‚\nåŸºç¡€ç¤ºä¾‹ä»£ç  åŸºç¡€ä½¿ç”¨\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;thread_pool.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { abin::threadpool pool(4); auto future1 = pool.submit([] { return 42; }); std::cout \u0026lt;\u0026lt; \u0026#34;ç»“æœ: \u0026#34; \u0026lt;\u0026lt; future1.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; auto future2 = pool.submit([](int a, int b) { return a + b; }, 5, 7); std::cout \u0026lt;\u0026lt; \u0026#34;åŠ æ³•ç»“æœ: \u0026#34; \u0026lt;\u0026lt; future2.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } æäº¤ä»»æ„ç±»å‹ä»»æ„å‚æ•°çš„å¯è°ƒç”¨å¯¹è±¡\nç‚¹å‡»æŸ¥çœ‹ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026#34;thread_pool.h\u0026#34; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; void normal_function(int x) { std::cout \u0026lt;\u0026lt; \u0026#34;normal_function: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } struct MyClass { void member_function(int y) { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass::member_function: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; } int add(int a, int b) { return a + b; } }; struct Functor { void operator()(const std::string\u0026amp; msg) const { std::cout \u0026lt;\u0026lt; \u0026#34;Functor called with: \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; int main() { abin::threadpool pool(4); // æäº¤ä¸€ä¸ªæ™®é€šå‡½æ•° pool.submit(normal_function, 42); // æäº¤ä¸€ä¸ªæ— æ•è· lambda pool.submit([] { std::cout \u0026lt;\u0026lt; \u0026#34;lambda no capture\\n\u0026#34;; }); // æäº¤ä¸€ä¸ªæœ‰æ•è· lambda int value = 99; pool.submit([value] { std::cout \u0026lt;\u0026lt; \u0026#34;lambda with capture: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }); // æäº¤æˆå‘˜å‡½æ•°, ä½¿ç”¨lambda MyClass obj; pool.submit([\u0026amp;obj] { obj.member_function(123); }); // æäº¤æˆå‘˜å‡½æ•°, ä½¿ç”¨ std::mem_fn std::future\u0026lt;int\u0026gt; ret = pool.submit(std::mem_fn(\u0026amp;MyClass::add), \u0026amp;obj, 3, 4); std::cout \u0026lt;\u0026lt; \u0026#34;add result1: \u0026#34; \u0026lt;\u0026lt; ret.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // æäº¤æˆå‘˜å‡½æ•°, ä½¿ç”¨ std::bind std::future\u0026lt;int\u0026gt; fut_add = pool.submit(std::bind(\u0026amp;MyClass::add, \u0026amp;obj, 2, 3)); std::cout \u0026lt;\u0026lt; \u0026#34;add result2: \u0026#34; \u0026lt;\u0026lt; fut_add.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // æäº¤ä¸€ä¸ªå‡½æ•°å¯¹è±¡(ä»¿å‡½æ•°) Functor f; pool.submit(f, \u0026#34;hello functor\u0026#34;); // ä½¿ç”¨ std::bind æäº¤ auto bound = std::bind(\u0026amp;MyClass::add, \u0026amp;obj, 5, 6); std::future\u0026lt;int\u0026gt; fut_bound = pool.submit(bound); std::cout \u0026lt;\u0026lt; \u0026#34;bound result: \u0026#34; \u0026lt;\u0026lt; fut_bound.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // æäº¤ä¸€ä¸ª std::packaged_task(æ³¨æ„: ä½ç‰ˆæœ¬msvcå¯èƒ½æŠ¥é”™) std::packaged_task\u0026lt;std::string()\u0026gt; task([] { return std::string(\u0026#34;from packaged_task\u0026#34;); }); std::future\u0026lt;std::string\u0026gt; fut_str = task.get_future(); pool.submit(std::move(task)); // å¿…é¡» move std::cout \u0026lt;\u0026lt; \u0026#34;packaged_task result: \u0026#34; \u0026lt;\u0026lt; fut_str.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; pool.wait_all(); // ç­‰å¾…ä»»åŠ¡å®Œæˆ std::cout \u0026lt;\u0026lt; \u0026#34;===All tasks completed.===\\n\u0026#34;; } ThreadPoolæºç  ç‚¹å‡»æŸ¥çœ‹çº¿ç¨‹æ± æºç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 /************************************************************************************************************** *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * @file: thread_pool.h * @version: v0.9.2 * @description: A cross-platform, lightweight, easy-to-use C++11 thread pool that supports submitting tasks with * arbitrary parameters and obtaining return values * - Futures * - Task-based: Supports tasks with arbitrary parameters, and obtains return values â€‹â€‹through `std::future`. * - Cross-Platform: Works on platforms supporting C++11. * - Thread Safety: Uses `std::mutex`, `std::condition_variable`, and atomic variables for synchronization. * - Flexible Shutdown: Two modes for shutdown: `WaitForAllTasks` and `DiscardPendingTasks`. * - Lightweight \u0026amp; Easy-to-Use: Simple API with minimal setup. * * @author: abin * @date: 2025-04-20 * @license: MIT * @repository: https://github.com/abin-z/ThreadPool *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ **************************************************************************************************************/ #ifndef ABIN_THREADPOOL_H #define ABIN_THREADPOOL_H #include \u0026lt;atomic\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; namespace abin { /// @brief C++11çš„çº¿ç¨‹æ± , æäº¤ä»»åŠ¡æ”¯æŒä»»æ„å¤šå‚æ•°, æ”¯æŒè·å–è¿”å›å€¼ class threadpool { using task_t = std::function\u0026lt;void()\u0026gt;; // å®šä¹‰ä»»åŠ¡ç±»å‹ä¸ºå¯è°ƒç”¨å¯¹è±¡ public: /// @brief çº¿ç¨‹æ± å½“å‰çŠ¶æ€ä¿¡æ¯ç»“æ„ä½“ struct status_info { std::size_t total_threads; // æ€»çº¿ç¨‹æ•° std::size_t busy_threads; // æ­£åœ¨æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹æ•° std::size_t idle_threads; // ç©ºé—²çº¿ç¨‹æ•° std::size_t pending_tasks; // ç­‰å¾…ä¸­çš„ä»»åŠ¡æ•° bool running; // çº¿ç¨‹æ± æ˜¯å¦åœ¨è¿è¡Œ }; /// @brief å…³é—­çº¿ç¨‹æ± çš„æ¨¡å¼ enum class shutdown_mode : unsigned char { /// @brief ç­‰å¾…æ‰€æœ‰å·²æäº¤çš„ä»»åŠ¡å®Œæˆåå†å…³é—­çº¿ç¨‹æ±  /// åœ¨æ­¤æ¨¡å¼ä¸‹, çº¿ç¨‹æ± ä¼šç­‰å¾…æ‰€æœ‰ä»»åŠ¡(åŒ…æ‹¬å·²å¼€å§‹å’Œæœªå¼€å§‹çš„ä»»åŠ¡)æ‰§è¡Œå®Œæˆåå†å…³é—­. WaitForAllTasks, /// @brief ç«‹å³å…³é—­çº¿ç¨‹æ± , ä¸¢å¼ƒå°šæœªå¼€å§‹çš„ä»»åŠ¡. /// åœ¨æ­¤æ¨¡å¼ä¸‹, çº¿ç¨‹æ± ä¼šç«‹å³åœæ­¢æ¥æ”¶æ–°ä»»åŠ¡, ä¸¢å¼ƒæ‰€æœ‰å°šæœªå¼€å§‹æ‰§è¡Œçš„ä»»åŠ¡, /// ä½†å·²ç»å¼€å§‹æ‰§è¡Œçš„ä»»åŠ¡ä¼šç»§ç»­æ‰§è¡Œ, ç›´åˆ°å®ƒä»¬å®Œæˆ. DiscardPendingTasks }; public: /// @brief æ„é€ å‡½æ•°, åˆå§‹åŒ–çº¿ç¨‹æ± å¹¶å¯åŠ¨æŒ‡å®šæ•°é‡çš„å·¥ä½œçº¿ç¨‹ /// @param thread_count è¦åˆ›å»ºçš„çº¿ç¨‹æ•°é‡, é»˜è®¤ä¸ºç¡¬ä»¶æ”¯æŒçš„å¹¶å‘çº¿ç¨‹æ•°(è‹¥æ— æ³•è·å–åˆ™ä¸º 4) explicit threadpool(std::size_t thread_count = default_thread_count()) { launch_threads(validate_thread_count(thread_count)); // åˆ›å»ºçº¿ç¨‹ } /// @brief ææ„å‡½æ•°, åœæ­¢æ‰€æœ‰çº¿ç¨‹å¹¶ç­‰å¾…å®ƒä»¬å®Œæˆ ~threadpool() { shutdown(shutdown_mode::WaitForAllTasks); } /// @brief æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± å¹¶è¿”å›ä¸€ä¸ª future å¯¹è±¡, ç”¨æˆ·å¯ä»¥é€šè¿‡å®ƒè·å–ä»»åŠ¡çš„è¿”å›å€¼ /// /// @tparam F ä»»åŠ¡ç±»å‹çš„å¯è°ƒç”¨å¯¹è±¡ /// @tparam Args å¯è°ƒç”¨å¯¹è±¡çš„å‚æ•°ç±»å‹ /// @param f éœ€è¦æäº¤çš„ä»»åŠ¡ /// @param args ä»»åŠ¡çš„å‚æ•° /// @return std::future\u0026lt;decltype(f(args...))\u0026gt; è¿”å›ä¸€ä¸ª future å¯¹è±¡, å…è®¸ç”¨æˆ·è·å–ä»»åŠ¡çš„è¿”å›å€¼ template \u0026lt;typename F, typename... Args\u0026gt; auto submit(F \u0026amp;\u0026amp;f, Args \u0026amp;\u0026amp;...args) -\u0026gt; std::future\u0026lt;decltype(f(args...))\u0026gt; { if (!running_) throw std::runtime_error(\u0026#34;error: ThreadPool is not running. Cannot submit new tasks.\u0026#34;); using return_type = decltype(f(args...)); // å°† f åŒ…è£…æˆ task, task æ˜¯ä¸€ä¸ª shared_ptr æŒ‡å‘ packaged_task auto task = std::make_shared\u0026lt;std::packaged_task\u0026lt;return_type()\u0026gt;\u0026gt;( std::bind(std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Args\u0026gt;(args)...) // å°†å‡½æ•°å’Œå‚æ•°å°è£…æˆä¸€ä¸ª return_type() çš„å¯è°ƒç”¨å¯¹è±¡ ); std::future\u0026lt;return_type\u0026gt; ret = task-\u0026gt;get_future(); // è·å–ä¸ task ç›¸å…³è”çš„ future { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); task_queue_.emplace([task] { (*task)(); }); // å°†ä»»åŠ¡æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­ } cv_.notify_one(); // é€šçŸ¥ä¸€ä¸ªç­‰å¾…ä¸­çš„å·¥ä½œçº¿ç¨‹æœ‰æ–°çš„ä»»åŠ¡å¯ä»¥æ‰§è¡Œ return ret; // è¿”å› future å¯¹è±¡ } /// @brief é˜»å¡ç›´åˆ°æ‰€æœ‰ä»»åŠ¡å®Œæˆ(ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©ºä¸”æ²¡æœ‰ä»»åŠ¡åœ¨æ‰§è¡Œ), è‹¥æ²¡æœ‰ä»»åŠ¡ï¼Œç«‹å³è¿”å› void wait_all() { if (busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0) return; std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx_done_); cv_done_.wait(lock, [this] { return busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0; }); } /// @brief å…³é—­çº¿ç¨‹æ±  /// @param mode `WaitForAllTasks` ç­‰å¾…æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæˆåå†å…³é—­; `DiscardPendingTasks` ç«‹å³å…³é—­çº¿ç¨‹æ± , /// æŠ›å¼ƒå°šæœªå¼€å§‹çš„ä»»åŠ¡. void shutdown(shutdown_mode mode = shutdown_mode::WaitForAllTasks) { { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); if (!running_) return; // å·²ç»å…³é—­åˆ™ç›´æ¥è¿”å› running_ = false; if (mode == shutdown_mode::DiscardPendingTasks) // æ”¾å¼ƒä»»åŠ¡æ¨¡å¼ { std::queue\u0026lt;task_t\u0026gt; empty; std::swap(task_queue_, empty); // æ¸…ç©ºä»»åŠ¡é˜Ÿåˆ— } } cv_.notify_all(); for (std::thread \u0026amp;worker : workers_) { if (worker.joinable()) worker.join(); } workers_.clear(); } /// @brief é‡å¯çº¿ç¨‹æ± , å…ˆå…³é—­å½“å‰çº¿ç¨‹æ± (ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ), ç„¶åä»¥æŒ‡å®šçš„çº¿ç¨‹æ•°é‡é‡æ–°å¯åŠ¨çº¿ç¨‹æ± . /// @param thread_count è¦åˆ›å»ºçš„å·¥ä½œçº¿ç¨‹æ•°é‡ void reboot(std::size_t thread_count) { shutdown(shutdown_mode::WaitForAllTasks); { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); if (running_) return; // å·²é‡å¯, æ— éœ€å†æ¬¡åˆå§‹åŒ–(å¹‚ç­‰) running_ = true; launch_threads(validate_thread_count(thread_count)); } } /// @brief å½“å‰çº¿ç¨‹æ± çš„æ€»çº¿ç¨‹æ•°é‡ std::size_t total_threads() const noexcept { return workers_.size(); } /// @brief è·å–å½“å‰ç­‰å¾…çš„ä»»åŠ¡æ•°é‡ std::size_t pending_tasks() const noexcept { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); return task_queue_.size(); } /// @brief è·å–ç¹å¿™çš„çº¿ç¨‹æ•°é‡ std::size_t busy_threads() const noexcept { return busy_count_.load(); } /// @brief è·å–ç©ºé—²çº¿ç¨‹æ•°é‡ std::size_t idle_threads() const noexcept { return workers_.size() - busy_count_.load(); } /// @brief å½“å‰çº¿ç¨‹æ± æ˜¯å¦æ­£åœ¨è¿è¡Œ(æœªåœæ­¢) bool is_running() const noexcept { return running_.load(); } /// @brief è·å–çº¿ç¨‹æ± çš„å½“å‰çŠ¶æ€ä¿¡æ¯ status_info status() const noexcept { std::size_t total = 0; std::size_t pending = 0; { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); total = workers_.size(); pending = task_queue_.size(); } std::size_t busy = busy_count_.load(); std::size_t idle = total - busy; return {total, busy, idle, pending, running_.load()}; } // ç¦ç”¨æ‹·è´æ„é€ å‡½æ•°å’Œæ‹·è´èµ‹å€¼æ“ä½œç¬¦ threadpool(const threadpool \u0026amp;) = delete; threadpool \u0026amp;operator=(const threadpool \u0026amp;) = delete; // ç¦ç”¨ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼æ“ä½œç¬¦ threadpool(threadpool \u0026amp;\u0026amp;) = delete; threadpool \u0026amp;operator=(threadpool \u0026amp;\u0026amp;) = delete; private: /// @brief é»˜è®¤çº¿ç¨‹æ•°, è·å–ç¡¬ä»¶æ”¯æŒçš„å¹¶å‘çº¿ç¨‹æ•°, è‹¥æ— æ³•è·å–åˆ™é»˜è®¤ä¸º4 static std::size_t default_thread_count() { auto n = std::thread::hardware_concurrency(); return n == 0 ? 4 : n; } /// @brief éªŒè¯çº¿ç¨‹æ•°æ˜¯å¦åˆæ³•, 1 \u0026lt;= count \u0026lt;= 4096 static std::size_t validate_thread_count(std::size_t count) { if (count \u0026lt; 1 || count \u0026gt; 4096) throw std::invalid_argument(\u0026#34;invalid thread_count: must be in range [1, 1024]\u0026#34;); return count; } /// @brief å¯åŠ¨çº¿ç¨‹æ± , åˆ›å»ºæŒ‡å®šæ•°é‡çš„å·¥ä½œçº¿ç¨‹ /// @param thread_count çº¿ç¨‹æ± ä¸­çº¿ç¨‹çš„æ•°é‡ void launch_threads(std::size_t thread_count) { if (!workers_.empty()) return; // å·²ç»åˆå§‹åŒ–è¿‡ for (std::size_t i = 0; i \u0026lt; thread_count; ++i) { // åˆ›å»ºå¹¶å¯åŠ¨å·¥ä½œçº¿ç¨‹ workers_.emplace_back([this] { while (true) { task_t task; { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx_); // ç­‰å¾…ç›´åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­æœ‰ä»»åŠ¡, æˆ–è€…çº¿ç¨‹æ± å·²åœæ­¢ cv_.wait(lock, [this] { return !running_ || !task_queue_.empty(); }); if (!running_ \u0026amp;\u0026amp; task_queue_.empty()) return; // å¦‚æœçº¿ç¨‹æ± å·²ç»åœæ­¢å¹¶ä¸”é˜Ÿåˆ—ä¸ºç©º, é€€å‡ºçº¿ç¨‹ task = std::move(task_queue_.front()); // ä»é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡ task_queue_.pop(); } ++busy_count_; task(); // æ‰§è¡Œä»»åŠ¡ --busy_count_; // åˆ¤æ–­ä»»åŠ¡æ˜¯å¦å·²å…¨éƒ¨å®Œæˆ if (busy_count_ == 0 \u0026amp;\u0026amp; task_queue_.empty()) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_done_); if (busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0) // äºŒæ¬¡ç¡®è®¤, é¿å…ç«æ€ { cv_done_.notify_all(); } } } }); } } private: std::vector\u0026lt;std::thread\u0026gt; workers_; // å·¥ä½œçº¿ç¨‹é›†åˆï¼Œç”¨äºå¹¶å‘æ‰§è¡Œä»»åŠ¡ std::queue\u0026lt;task_t\u0026gt; task_queue_; // ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡é˜Ÿåˆ— std::condition_variable cv_; // æ¡ä»¶å˜é‡ï¼Œç”¨äºé€šçŸ¥å·¥ä½œçº¿ç¨‹æœ‰æ–°ä»»åŠ¡åˆ°æ¥ mutable std::mutex mtx_; // ä¸»äº’æ–¥é”ï¼Œä¿æŠ¤ä»»åŠ¡é˜Ÿåˆ—å’Œä¸å…¶ç›¸å…³çš„çŠ¶æ€ std::atomic\u0026lt;std::size_t\u0026gt; busy_count_{0}; // æ­£åœ¨æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹æ•°é‡ std::atomic\u0026lt;bool\u0026gt; running_{true}; // çº¿ç¨‹æ± æ˜¯å¦å¤„äºè¿è¡ŒçŠ¶æ€ mutable std::mutex mtx_done_; // ç”¨äºä¿æŠ¤å®Œæˆé€šçŸ¥çš„äº’æ–¥é”(wait_all ç”¨) std::condition_variable cv_done_; // æ¡ä»¶å˜é‡ï¼Œç”¨äºç­‰å¾…æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæ¯•(é…åˆ wait_all ä½¿ç”¨) }; } // namespace abin #endif // ABIN_THREADPOOL_H ","date":"2025-04-26T17:29:58+08:00","permalink":"https://abin-z.github.io/p/threadpool/","title":"C++è·¨å¹³å°è½»é‡çº§çº¿ç¨‹æ± (ThreadPool)"},{"content":"SimpleTimer æ˜¯ä¸€ä¸ªè·¨å¹³å°çš„è½»é‡çº§å®šæ—¶å™¨ç±»ï¼Œæ”¯æŒåœ¨åå°çº¿ç¨‹ä¸­å®šæœŸæ‰§è¡Œä»»åŠ¡ï¼Œé€‚ç”¨äºéœ€è¦å®šæ—¶æ‰§è¡Œä»»åŠ¡çš„åœºæ™¯ã€‚å®ƒæ”¯æŒæš‚åœã€æ¢å¤ã€ä¿®æ”¹æ—¶é—´é—´éš”ç­‰åŠŸèƒ½ï¼Œä¸”ä¸ä¾èµ–ä»»ä½•ç¬¬ä¸‰æ–¹åº“ï¼Œä»…ä½¿ç”¨ C++11 æ ‡å‡†åº“å®ç°ã€‚\nç‰¹æ€§ è·¨å¹³å°æ”¯æŒï¼šåœ¨å¤šä¸ªå¹³å°ä¸Šï¼ˆå¦‚ Windowsã€Linuxã€macOSï¼‰å‡å¯è¿è¡Œï¼ŒåŸºäº C++11 æ ‡å‡†åº“å®ç°ã€‚ çº¿ç¨‹å®‰å…¨ï¼šå†…éƒ¨ä½¿ç”¨ std::thread å’Œ std::condition_variableï¼Œä¿è¯çº¿ç¨‹å®‰å…¨ã€‚ çµæ´»çš„æ—¶é—´é—´éš”ï¼šæ”¯æŒä½¿ç”¨ std::chrono::duration è®¾ç½®ä»»æ„æ—¶é—´å•ä½ï¼ˆåˆ†é’Ÿã€ç§’ã€æ¯«ç§’ç­‰ï¼‰ã€‚ æ”¯æŒå¤šç§æ‰§è¡Œæ¨¡å¼ï¼šåŒ…æ‹¬å•æ¬¡æ‰§è¡Œï¼ˆone-shotï¼‰å’Œé‡å¤æ‰§è¡Œï¼ˆå‘¨æœŸæ€§ï¼‰ã€‚ æ§åˆ¶åŠŸèƒ½å®Œå–„ï¼šæ”¯æŒæš‚åœã€æ¢å¤ã€é‡å¯å®šæ—¶å™¨ï¼Œæ”¯æŒåŠ¨æ€ä¿®æ”¹æ—¶é—´é—´éš”ã€‚ æ—¶é—´ç²¾åº¦è‰¯å¥½ï¼šå®šæ—¶å™¨ç²¾åº¦å–å†³äºç³»ç»Ÿæ—¶é’Ÿï¼Œé€šå¸¸ä¸ºæ¯«ç§’çº§åˆ«ã€‚ è‡ªåŠ¨èµ„æºç®¡ç†ï¼šSimpleTimer å¯¹è±¡ææ„æ—¶ä¼šè‡ªåŠ¨åœæ­¢å®šæ—¶å™¨ï¼Œå³ä½¿å¿˜è®°è°ƒç”¨ stop ä¹Ÿèƒ½ç¡®ä¿èµ„æºæ­£ç¡®é‡Šæ”¾ã€‚ ä½¿ç”¨æ–¹å¼ å°† simple_timer.h æ–‡ä»¶å¤åˆ¶åˆ°ä½ çš„é¡¹ç›®ç›®å½•ä¸­ï¼Œåœ¨æºç ä¸­å¼•å…¥å³å¯ä½¿ç”¨:\n1 #include \u0026#34;simple_timer.h\u0026#34; åœ¨ POSIX ç³»ç»Ÿï¼ˆå¦‚ Linuxã€macOSï¼‰ä¸­ï¼Œstd::thread åŸºäº pthread å®ç°ï¼Œå› æ­¤éœ€è¦åœ¨ç¼–è¯‘æ—¶åŠ ä¸Š -lpthread é“¾æ¥é€‰é¡¹ã€‚\nç¤ºä¾‹ä»£ç  ä»¥ä¸‹æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ SimpleTimer ç±»ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026#34;simple_timer.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { SimpleTimer timer(std::chrono::seconds(1)); // å®šæ—¶å™¨é—´éš”ä¸º1ç§’ï¼Œé‡å¤æ‰§è¡Œä»»åŠ¡ timer.start([]() { std::cout \u0026lt;\u0026lt; \u0026#34;å®šæ—¶å™¨ä»»åŠ¡æ‰§è¡Œï¼\u0026#34; \u0026lt;\u0026lt; std::endl; }); std::this_thread::sleep_for(std::chrono::seconds(5)); // ç­‰å¾…5ç§’ timer.pause(); // æš‚åœå®šæ—¶å™¨ std::cout \u0026lt;\u0026lt; \u0026#34;å®šæ—¶å™¨å·²æš‚åœ...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(3)); // ç­‰å¾…3ç§’ timer.resume(); // æ¢å¤å®šæ—¶å™¨ std::cout \u0026lt;\u0026lt; \u0026#34;å®šæ—¶å™¨å·²æ¢å¤...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(5)); // ç­‰å¾…5ç§’ timer.stop(); // åœæ­¢å®šæ—¶å™¨ std::cout \u0026lt;\u0026lt; \u0026#34;å®šæ—¶å™¨å·²åœæ­¢\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ä»£ç å®ç°: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 /** * @author: abin * @date: 2025-04-12 * @license: MIT * @repository: https://github.com/abin-z/SimpleTimer */ #ifndef SIMPLE_TIMER_H #define SIMPLE_TIMER_H #include \u0026lt;atomic\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; /** * @brief ä½¿ç”¨ std::condition_variable çš„ wait_until æ–¹æ³• (ä¹Ÿå¯ä»¥ä½¿ç”¨wait_foræ–¹æ³•, ä½†æ˜¯ä¼šç´¯è®¡è¯¯å·®) * å‡½æ•°åŸå‹: * cv.wait_until(lock, time_point, predicate); * * wait_until çš„è¡Œä¸º: * - wait_until æ–¹æ³•çš„ä½œç”¨æ˜¯è®©å½“å‰çº¿ç¨‹åœ¨æŒ‡å®šçš„æ—¶é—´ç‚¹ä¹‹å‰ç­‰å¾…, ç›´åˆ°æ¡ä»¶å˜é‡è¢«é€šçŸ¥æˆ–è€…è¶…æ—¶ * - è¿›å…¥ç­‰å¾…å‰ä¼šå…ˆæ£€æŸ¥ predicate() çš„å€¼. * - å¦‚æœ predicate() åœ¨è¿›å…¥ç­‰å¾…å‰ç«‹å³ä¸º true, åˆ™ç›´æ¥è¿”å› true, ä¸ä¼šè¿›å…¥ç­‰å¾…çŠ¶æ€ * - å¦‚æœ predicate() ä¸º false, åˆ™è¿›å…¥ç­‰å¾…çŠ¶æ€, ç›´åˆ° time_point åˆ°è¾¾ * - å¦‚æœåœ¨ time_point åˆ°è¾¾å‰ `notify_*` è¢«è°ƒç”¨, å¹¶ä¸”æ­¤æ—¶ predicate() ä¸º true, åˆ™å”¤é†’å¹¶è¿”å› true * - å¦‚æœåœ¨ time_point åˆ°è¾¾å‰ `notify_*` è¢«è°ƒç”¨, ä½†æ­¤æ—¶ predicate() ä¸º false, åˆ™ç»§ç»­ç­‰å¾…(å¯èƒ½æ˜¯è™šå‡å”¤é†’) * - å¦‚æœç›´åˆ° time_point åˆ°è¾¾æ—¶ predicate() ä»ä¸º false, è¿”å› false(è¡¨ç¤ºè¶…æ—¶) * * ç®€è¦æ¥è¯´: * - `wait_until` è¿”å› true è¡¨ç¤ºæ¡ä»¶å˜é‡è¢«å”¤é†’å¹¶ä¸”æ¡ä»¶æˆç«‹ * - `wait_until` è¿”å› false è¡¨ç¤ºå·²è¶…æ—¶, ä¸”æ¡ä»¶ä»æœªæ»¡è¶³(å³è¶…æ—¶è§¦å‘ä»»åŠ¡) */ /// @brief A simple timer class class SimpleTimer { using clock = std::chrono::steady_clock; // å•è°ƒæ—¶é’Ÿ, ä¸å—ç³»ç»Ÿæ—¶é—´å˜åŒ–å½±å“ public: /// @brief Timer state enum class State : unsigned char { Stopped = 0, // åœæ­¢ Running = 1, // è¿è¡Œä¸­ Paused = 2, // æš‚åœ }; /// @brief Constructs a SimpleTimer with a given duration /// @tparam Rep Duration representation type (e.g., int, long) /// @tparam Period Duration unit type (e.g., seconds, milliseconds) /// @param interval The time interval /// @param one_shot If true, the timer will only trigger once template \u0026lt;typename Rep, typename Period\u0026gt; SimpleTimer(std::chrono::duration\u0026lt;Rep, Period\u0026gt; interval, bool one_shot = false) : interval_(interval), one_shot_(one_shot), state_(State::Stopped) { } /// @brief Constructs a SimpleTimer with a millisecond interval /// @param milliseconds The time interval in milliseconds /// @param one_shot If true, the timer will only trigger once explicit SimpleTimer(long long milliseconds, bool one_shot = false) : SimpleTimer(std::chrono::milliseconds(milliseconds), one_shot) // ä»£ç†åˆ°ä¸»æ„é€ å‡½æ•° { } /// @brief Constructs a SimpleTimer with a default interval of 10 seconds /// @param one_shot If true, the timer will only trigger once SimpleTimer(bool one_shot = false) : SimpleTimer(std::chrono::seconds(10), one_shot) // é»˜è®¤é—´éš”ä¸º10ç§’ { } /// @brief Destructor. Automatically stops the timer to clean up resources. ~SimpleTimer() { stop(); } // Delete copy constructor and copy assignment operator SimpleTimer(const SimpleTimer\u0026amp;) = delete; SimpleTimer\u0026amp; operator=(const SimpleTimer\u0026amp;) = delete; // Delete move constructor and move assignment operator SimpleTimer(SimpleTimer\u0026amp;\u0026amp;) = delete; SimpleTimer\u0026amp; operator=(SimpleTimer\u0026amp;\u0026amp;) = delete; /// @brief Starts the timer /// @tparam Func Callable object type /// @param f A callable object to be executed when the timer expires /// @note The timer task will be executed in a new thread template \u0026lt;typename Func\u0026gt; void start(Func\u0026amp;\u0026amp; f) { stop(); // ç¡®ä¿æ²¡æœ‰å…¶ä»–çº¿ç¨‹åœ¨è¿è¡Œ(æ›¿æ¢æ—§ä»»åŠ¡) state_ = State::Running; // è®¾ç½®çŠ¶æ€ä¸ºè¿è¡Œä¸­ auto task = std::move(std::forward\u0026lt;Func\u0026gt;(f)); // å®Œç¾è½¬å‘åå† move, æé«˜æ•ˆç‡ // ä½¿ç”¨ std::thread åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹æ¥æ‰§è¡Œå®šæ—¶å™¨ä»»åŠ¡ thread_ = std::thread([this, task]() mutable { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mutex_); auto next_time = clock::now() + interval_; while (true) { if (state_ == State::Stopped) { break; } while (state_ == State::Paused) { cv_.wait(lock, [this]() { return state_ != State::Paused; }); next_time = clock::now() + interval_; // é‡æ–°è®¡ç®—ä¸‹ä¸€æ¬¡è§¦å‘æ—¶é—´ } if (cv_.wait_until(lock, next_time, [this]() { return state_ != State::Running || interval_changed_; })) { if (interval_changed_) // interval_ä¿®æ”¹åç«‹å³ä½¿ç”¨æ–°é—´éš” { next_time = clock::now() + interval_; interval_changed_ = false; } continue; // è‹¥çŠ¶æ€ä¸æ˜¯ Running, ç»§ç»­å¾ªç¯åˆ¤æ–­; è‹¥æ˜¯ interval_ è¢«ä¿®æ”¹, åˆ™æ›´æ–° next_time å¹¶ç«‹å³è·³è¿‡ç­‰å¾… } lock.unlock(); // Timer å†…éƒ¨å¤„ç†å¼‚å¸¸, æ‰§è¡Œtaské‡åˆ°å¼‚å¸¸åç›´æ¥åœæ­¢timer try { task(); // æ‰§è¡Œä»»åŠ¡ } catch (const std::exception\u0026amp; e) { state_ = State::Stopped; // å‡ºç°å¼‚å¸¸æ—¶åœæ­¢å®šæ—¶å™¨ (ä¸èƒ½è°ƒç”¨stop()ä¼šæ­»é”) std::fprintf(stderr, \u0026#34;[SimpleTimer] Exception: %s\\n\u0026#34;, e.what()); } catch (...) { state_ = State::Stopped; // å‡ºç°å¼‚å¸¸æ—¶åœæ­¢å®šæ—¶å™¨ std::fprintf(stderr, \u0026#34;[SimpleTimer] Unknown exception occurred.\\n\u0026#34;); } lock.lock(); if (one_shot_) { state_ = State::Stopped; break; } next_time += interval_; // ç²¾ç¡®æ¨è¿›æ—¶é—´ç‚¹, é¿å…åå·® } }); } /// @brief Restarts the timer /// @tparam Func Callable object type /// @param f A callable object to be executed when the timer expires template \u0026lt;typename Func\u0026gt; void restart(Func\u0026amp;\u0026amp; f) { stop(); start(std::forward\u0026lt;Func\u0026gt;(f)); } /// @brief Stops the timer; waits for the current task to complete before fully stopping /// @note This method may block until the running task completes. void stop() { state_ = State::Stopped; cv_.notify_all(); // å”¤é†’ç­‰å¾…çš„çº¿ç¨‹ if (thread_.joinable()) { thread_.join(); // ç­‰å¾…çº¿ç¨‹ç»“æŸ } } /// @brief Pauses the timer void pause() { if (state_ == State::Running) { state_ = State::Paused; } } /// @brief Resumes the timer if it was paused void resume() { if (state_ == State::Paused) { state_ = State::Running; cv_.notify_all(); // å”¤é†’æ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹ } } /// @brief Gets the current timer interval /// @return The interval in milliseconds std::chrono::milliseconds interval() const { return std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(interval_); } /// @brief Sets a new timer interval, takes effect immediately /// @param new_interval A duration representing the new interval template \u0026lt;typename Rep, typename Period\u0026gt; void set_interval(std::chrono::duration\u0026lt;Rep, Period\u0026gt; new_interval) { { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); interval_ = new_interval; interval_changed_ = true; // æ ‡è®°ä¸ºå·²æ”¹å˜ } cv_.notify_all(); // ç¡®ä¿çº¿ç¨‹èƒ½è·å–åˆ°æ–°çš„æ—¶é—´é—´éš” } /// @brief Sets a new timer interval, takes effect immediately /// @param milliseconds New interval in milliseconds void set_interval(long long milliseconds) { set_interval(std::chrono::milliseconds(milliseconds)); } /// @brief Gets the current state of the timer /// @return The state of the timer State state() const { return state_; } /// @brief Checks if the timer is currently running /// @return true if running, false otherwise bool is_running() const { return state_ == State::Running; } /// @brief Checks if the timer is currently paused /// @return true if paused, false otherwise bool is_paused() const { return state_ == State::Paused; } /// @brief Checks if the timer is currently stopped /// @return true if stopped, false otherwise bool is_stopped() const { return state_ == State::Stopped; } private: // å®šæ—¶å™¨é—´éš”, é»˜è®¤10ç§’ clock::duration interval_ = std::chrono::seconds(10); bool interval_changed_ = false; // æ—¶é—´é—´éš”æ˜¯å¦è¢«ä¿®æ”¹è¿‡ bool one_shot_ = false; // æ˜¯å¦åªè§¦å‘ä¸€æ¬¡ std::atomic\u0026lt;State\u0026gt; state_; // å®šæ—¶å™¨çŠ¶æ€ std::thread thread_; // å®šæ—¶å™¨çº¿ç¨‹ std::mutex mutex_; // äº’æ–¥é”, ç¡®ä¿çº¿ç¨‹å®‰å…¨ std::condition_variable cv_; // æ¡ä»¶å˜é‡, ç”¨äºæš‚åœå’Œæ¢å¤ }; #endif // SIMPLE_TIMER_H ","date":"2025-04-13T01:20:56+08:00","permalink":"https://abin-z.github.io/p/simpletimer/","title":"åŸºäºC++11çš„ç®€å•å®šæ—¶å™¨(SimpleTimer)"},{"content":"ä¸­æ–‡å­—ç¬¦ä¸²åœ¨msvcç¼–è¯‘å™¨ä¸‹å‡ºç°å¼‚å¸¸æŠ¥é”™ æˆ‘åœ¨å†™ä¸­æ–‡å•å…ƒæµ‹è¯•ç”¨ä¾‹,æœ‰ä»¥ä¸‹cppä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TEST_CASE(\u0026#34;case insensitive test08\u0026#34;, \u0026#34;[inifile][case_insensitive]\u0026#34;) { ini::case_insensitive_inifile inif; // æ·»åŠ ä¸€äº›ä¸­æ–‡çš„æµ‹è¯• inif[\u0026#34;ä¸­æ–‡èŠ‚\u0026#34;][\u0026#34;ä¸­æ–‡é”®\u0026#34;] = \u0026#34;ä¸­æ–‡å€¼\u0026#34;; // æµ‹è¯•ä¸­æ–‡çš„å¤§å°å†™ä¸æ•æ„Ÿæ€§ï¼ˆå®é™…ä¸Šä¸­æ–‡æ²¡æœ‰å¤§å°å†™ï¼Œä½†æµ‹è¯•æ˜¯å¦å—å½±å“ï¼‰ CHECK(inif.contains(\u0026#34;ä¸­æ–‡èŠ‚\u0026#34;) == true); CHECK(inif.contains(\u0026#34;ä¸­æ–‡èŠ‚\u0026#34;, \u0026#34;ä¸­æ–‡é”®\u0026#34;) == true); CHECK(inif[\u0026#34;ä¸­æ–‡èŠ‚\u0026#34;][\u0026#34;ä¸­æ–‡é”®\u0026#34;].as\u0026lt;std::string\u0026gt;() == \u0026#34;ä¸­æ–‡å€¼\u0026#34;); // ä¿®æ”¹ä¸­æ–‡å€¼ inif[\u0026#34;ä¸­æ–‡èŠ‚\u0026#34;][\u0026#34;ä¸­æ–‡é”®\u0026#34;] = \u0026#34;æ–°çš„ä¸­æ–‡å€¼\u0026#34;; CHECK(inif[\u0026#34;ä¸­æ–‡èŠ‚\u0026#34;][\u0026#34;ä¸­æ–‡é”®\u0026#34;].as\u0026lt;std::string\u0026gt;() == \u0026#34;æ–°çš„ä¸­æ–‡å€¼\u0026#34;); // æµ‹è¯•ä¸å­˜åœ¨çš„ä¸­æ–‡é”® CHECK(inif.contains(\u0026#34;ä¸­æ–‡èŠ‚\u0026#34;, \u0026#34;ä¸å­˜åœ¨çš„é”®\u0026#34;) == false); // æµ‹è¯•ä¸­æ–‡é»˜è®¤å€¼ CHECK(inif.get(\u0026#34;ä¸­æ–‡èŠ‚\u0026#34;, \u0026#34;ä¸å­˜åœ¨çš„é”®\u0026#34;, \u0026#34;é»˜è®¤å€¼\u0026#34;).as\u0026lt;std::string\u0026gt;() == \u0026#34;é»˜è®¤å€¼\u0026#34;); } é‡åˆ°çš„é—®é¢˜: è¿™æ®µä»£ç æœ¬èº«å…¶å®æ²¡å•¥é—®é¢˜, åœ¨linuxä¸‹ä½¿ç”¨gccå’Œclangéƒ½å¯ä»¥é€šè¿‡ç¼–è¯‘, ä½†æ˜¯åœ¨msvcç¼–è¯‘å™¨ä¸‹å°±æœ‰ä»¥ä¸‹çš„ç¼–è¯‘é”™è¯¯:\né—®é¢˜åŸå› : é—®é¢˜çš„æ ¹æœ¬åŸå› æ˜¯ Windows ä¸‹çš„ MSVC é»˜è®¤ä½¿ç”¨æœ¬åœ°ç³»ç»Ÿä»£ç é¡µï¼ˆä¾‹å¦‚ GBK/936ï¼‰è¯»å–æºä»£ç æ–‡ä»¶ï¼Œè€Œä¸æ˜¯ UTF-8ï¼Œè€Œä½ å†™çš„æºä»£ç ä¸­å«æœ‰ä¸­æ–‡å­—ç¬¦ï¼ˆUTF-8 ç¼–ç ï¼‰ã€‚MSVC åœ¨ä¸çŸ¥æƒ…çš„æƒ…å†µä¸‹ç”¨æœ¬åœ°ä»£ç é¡µè§£é‡Š UTF-8 å†…å®¹ï¼Œå°±ä¼šï¼š\né”™è¯¯åœ°å°† UTF-8 å­—èŠ‚å½“ä½œ GBK è§£æï¼Œå¯¼è‡´ä¸­æ–‡ä¹±ç  æŸäº› UTF-8 å­—èŠ‚ç»„åˆä¸åˆæ³•ï¼Œä¼šè¢«å½“æˆéæ³•å­—ç¬¦æˆ–æ¢è¡Œç¬¦å¤„ç† è¿™äº›éæ³•å­—ç¬¦ä¸€æ—¦å‡ºç°åœ¨å­—ç¬¦ä¸²ã€å®ã€ç”šè‡³æ ‡è¯†ç¬¦ä¸­ï¼Œå°±ä¼šå¼•å‘å„ç§æŠ¥é”™ ä¸ºä»€ä¹ˆ Linux å’Œ GCC/Clang æ²¡é—®é¢˜ï¼Ÿ\nGCC å’Œ Clang é»˜è®¤å°±æ˜¯æŒ‰ UTF-8 è¯»å–æºä»£ç æ–‡ä»¶ï¼Œå°¤å…¶æ˜¯åœ¨ UTF-8 ç¯å¢ƒä¸‹ï¼ˆæ¯”å¦‚å¤§å¤šæ•° Linux ç³»ç»Ÿï¼‰ã€‚æ‰€ä»¥å®ƒä»¬ä¸ä¼šæŠŠ UTF-8 ä¸­çš„åˆæ³•å­—ç¬¦è¯¯è§£ä¸ºéæ³•å­—ç¬¦æˆ–ä¹±ç ï¼Œè‡ªç„¶ä¸ä¼šå‡ºé”™ã€‚\nè§£å†³æ–¹æ¡ˆ æ ¸å¿ƒç‚¹: åªéœ€è¦è®©msvcèƒ½æŒ‰æ­£ç¡®çš„encodingè¯»å–æºæ–‡ä»¶å³å¯.\næ–¹å¼1: æ˜ç¡®å‘Šè¯‰msvcï¼Œä½¿ç”¨ UTF-8 è¯»å–ç¼–è¯‘æºæ–‡ä»¶, ä½¿ç”¨ç¼–è¯‘å‚æ•°/utf-8, æ¯”å¦‚åœ¨cmakeä¸­å¯ä»¥æ·»åŠ ä¸€ä¸‹å†…å®¹:\n1 2 3 4 # å¦‚æœæ˜¯ MSVC ç¼–è¯‘å™¨ï¼Œè®¾ç½®æºæ–‡ä»¶ä¸º UTF-8 ç¼–ç  if (MSVC) add_compile_options(\u0026#34;/utf-8\u0026#34;) endif() è¿™è¡Œä»£ç ä¼šä¸º MSVC ç¼–è¯‘å™¨æ·»åŠ  /utf-8 é€‰é¡¹ï¼ŒæŒ‡ç¤º MSVC ä½¿ç”¨ UTF-8 ç¼–ç æ¥è¯»å–å’Œå¤„ç†æºæ–‡ä»¶ä¸­çš„å­—ç¬¦ã€‚\næ–¹å¼2: å°†æºç æ–‡ä»¶è½¬ä¸ºUTF-8 with BOM, vscodeå’Œnotepad++éƒ½å¯ä»¥è½¬æ¢, è½¬æ¢åå°±èƒ½æˆåŠŸè¯†åˆ«å¹¶æŒ‰ç…§utf-8è§£ææºæ–‡ä»¶.(WindowsçœŸæ˜¯å¤Ÿæ— è¯­çš„, ä¸å¸¦BOMçš„UTF-8ä¸è¯†åˆ«)\næœ€æ¨èçš„è§£å†³æ–¹æ¡ˆï¼š\nç¡®ä¿æ‰€æœ‰æºä»£ç æ–‡ä»¶ä¿å­˜ä¸º UTF-8 ç¼–ç ï¼ˆæ—  BOMï¼‰ã€‚ åœ¨ CMakeLists.txt ä¸­æ·»åŠ  add_compile_options(\u0026quot;/utf-8\u0026quot;)ï¼Œå‘Šè¯‰ MSVC ä½¿ç”¨ UTF-8 ç¼–ç ã€‚ å¦‚æœä½ ä½¿ç”¨ Visual Studioï¼Œè®¾ç½®é»˜è®¤ä¿å­˜ä¸º UTF-8ã€‚ tipsï¼šè¿™ä¸ªé—®é¢˜å›°æ‰°æˆ‘å¾ˆå¤šå¹´äº†ï¼Œä¸€ç›´æ²¡ææ˜ç™½ï¼Œæ‰€ä»¥ç®€å•è®°å½•ä¸‹(æˆ–è®¸ä¹Ÿæ˜¯æˆ‘å¤ªèœäº†ğŸ™ˆ)\n","date":"2025-04-10T19:39:24+08:00","permalink":"https://abin-z.github.io/p/msvc%E4%B8%8B%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/","title":"msvcä¸‹ä¸­æ–‡å­—ç¬¦æŠ¥é”™è®°å½•"},{"content":"è¿™æ˜¯æˆ‘çš„ç¬¬äºŒä¸ªåšå®¢\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; // è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•° struct CaseInsensitiveHash { std::size_t operator()(const std::string \u0026amp;s) const { std::string lower_s = s; std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), [](unsigned char c) { return std::tolower(c); }); return std::hash\u0026lt;std::string\u0026gt;{}(lower_s); } }; // è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•° struct CaseInsensitiveEqual { bool operator()(const std::string \u0026amp;lhs, const std::string \u0026amp;rhs) const { return lhs.size() == rhs.size() \u0026amp;\u0026amp; std::equal(lhs.begin(), lhs.end(), rhs.begin(), [](unsigned char a, unsigned char b) { return std::tolower(a) == std::tolower(b); }); } }; // field ç±»å®šä¹‰ class field { public: using comment_container = std::vector\u0026lt;std::string\u0026gt;; }; // å…ˆå£°æ˜ basic_inifile template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_inifile; // ini sectionï¼ˆæ”¯æŒå¤§å°å†™ä¸æ•æ„Ÿé”®ï¼‰ template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_section { // å…è®¸ basic_inifile è®¿é—® private æˆå‘˜ template \u0026lt;typename H, typename E\u0026gt; friend class basic_inifile; using DataContainer = std::unordered_map\u0026lt;std::string, field, Hash, Equal\u0026gt;; public: using comment_container = field::comment_container; using key_type = typename DataContainer::key_type; using mapped_type = typename DataContainer::mapped_type; using value_type = typename DataContainer::value_type; using size_type = typename DataContainer::size_type; using difference_type = typename DataContainer::difference_type; using iterator = typename DataContainer::iterator; using const_iterator = typename DataContainer::const_iterator; // é»˜è®¤æ„é€  basic_section() = default; // é»˜è®¤ææ„å‡½æ•° ~basic_section() = default; // é»˜è®¤ç§»åŠ¨æ„é€ å‡½æ•° basic_section(basic_section \u0026amp;\u0026amp;) noexcept = default; // é»˜è®¤ç§»åŠ¨èµ‹å€¼å‡½æ•° basic_section \u0026amp;operator=(basic_section \u0026amp;\u0026amp;) noexcept = default; private: DataContainer data_; // å­˜å‚¨é”®å€¼å¯¹ }; // ini æ–‡ä»¶ç±»ï¼Œå­˜å‚¨å¤šä¸ª section template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_inifile { public: using section = basic_section\u0026lt;Hash, Equal\u0026gt;; // åœ¨ basic_inifile å†…éƒ¨å®šä¹‰ section åˆ«å using SectionContainer = std::unordered_map\u0026lt;std::string, section, Hash, Equal\u0026gt;; using key_type = typename SectionContainer::key_type; using mapped_type = typename SectionContainer::mapped_type; using value_type = typename SectionContainer::value_type; using size_type = typename SectionContainer::size_type; using difference_type = typename SectionContainer::difference_type; using iterator = typename SectionContainer::iterator; using const_iterator = typename SectionContainer::const_iterator; // é»˜è®¤æ„é€  basic_inifile() = default; // é»˜è®¤ææ„ ~basic_inifile() = default; // é»˜è®¤ç§»åŠ¨æ„é€  basic_inifile(basic_inifile \u0026amp;\u0026amp;) noexcept = default; // é»˜è®¤ç§»åŠ¨èµ‹å€¼ basic_inifile \u0026amp;operator=(basic_inifile \u0026amp;\u0026amp;) noexcept = default; // æ·»åŠ ä¸€ä¸ª section section \u0026amp;add_section(const std::string \u0026amp;name) { return sections_[name]; // å¦‚æœ name å­˜åœ¨ï¼Œè¿”å›å·²æœ‰çš„ sectionï¼Œå¦åˆ™åˆ›å»ºæ–° section } // è·å–ä¸€ä¸ª sectionï¼ˆå¯å˜ç‰ˆæœ¬ï¼‰ section *get_section(const std::string \u0026amp;name) { auto it = sections_.find(name); return it != sections_.end() ? \u0026amp;it-\u0026gt;second : nullptr; } // è·å–ä¸€ä¸ª sectionï¼ˆåªè¯»ç‰ˆæœ¬ï¼‰ const section *get_section(const std::string \u0026amp;name) const { auto it = sections_.find(name); return it != sections_.end() ? \u0026amp;it-\u0026gt;second : nullptr; } private: SectionContainer sections_; // å­˜å‚¨å¤šä¸ª section }; // æä¾›é»˜è®¤å¤§å°å†™ä¸æ•æ„Ÿçš„ç±»å‹åˆ«åï¼ˆç±»ä¼¼ std::stringï¼‰ using section = basic_section\u0026lt;CaseInsensitiveHash, CaseInsensitiveEqual\u0026gt;; using inifile = basic_inifile\u0026lt;CaseInsensitiveHash, CaseInsensitiveEqual\u0026gt;; #include \u0026lt;iostream\u0026gt; int main() { inifile ini; // é»˜è®¤ä½¿ç”¨å¤§å°å†™ä¸æ•æ„Ÿæ¨¡å¼ ini.add_section(\u0026#34;General\u0026#34;); ini.add_section(\u0026#34;Database\u0026#34;); // æµ‹è¯•å¤§å°å†™ä¸æ•æ„Ÿ if (ini.get_section(\u0026#34;general\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;Section \u0026#39;General\u0026#39; exists (case insensitive)\u0026#34; \u0026lt;\u0026lt; std::endl; } if (ini.get_section(\u0026#34;DATABASE\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;Section \u0026#39;Database\u0026#39; exists (case insensitive)\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } ","date":"2025-04-02T21:38:50+08:00","permalink":"https://abin-z.github.io/p/secondblog/","title":"SecondBlog"},{"content":"ä½ å¥½, ä¸–ç•Œ è¿™æ˜¯æˆ‘çš„ç¬¬ä¸€ä¸ªåšå®¢\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;inifile/inifile.h\u0026gt; /// @brief Specialization of INIFILE_TYPE_CONVERTER for std::vector\u0026lt;T\u0026gt;. /// @tparam T The type of elements in the vector. template \u0026lt;typename T\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { /// @brief Encodes a vector into a delimited string. void encode(const std::vector\u0026lt;T\u0026gt; \u0026amp;vec, std::string \u0026amp;value) { constexpr char delimiter = \u0026#39;,\u0026#39;; // Delimiter used to separate elements in the string std::string encoded_item; for (const auto \u0026amp;v : vec) { INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt; conv; conv.encode(v, encoded_item); // Encode each element of the vector value += encoded_item + delimiter; // Append the encoded element and delimiter } if (value.back() == delimiter) value.pop_back(); // Remove the trailing delimiter } /// @brief Decodes a delimited string into a vector. void decode(const std::string \u0026amp;value, std::vector\u0026lt;T\u0026gt; \u0026amp;vec) { constexpr char delimiter = \u0026#39;,\u0026#39;; // Delimiter used to separate elements in the string std::vector\u0026lt;std::string\u0026gt; info = ini::split(value, delimiter); // Split the string T encoded_item; for (const auto \u0026amp;v : info) { INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt; conv; conv.decode(v, encoded_item); // Decode each part of the string vec.emplace_back(std::move(encoded_item)); // Add the decoded element to the vector } } }; /// @brief Print the contents of a vector to the console. template \u0026lt;typename T\u0026gt; void print_vector(const std::vector\u0026lt;T\u0026gt; \u0026amp;vec) { std::cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (size_t i = 0; i \u0026lt; vec.size(); ++i) { std::cout \u0026lt;\u0026lt; vec[i]; if (i != vec.size() - 1) { std::cout \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; } } std::cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { ini::inifile inif; // Create an INI file object // Define vectors of different types std::vector\u0026lt;int\u0026gt; vec1 = {1, 2, 3, 4, 5}; std::vector\u0026lt;double\u0026gt; vec2 = {1.1111, 2.2222, 3.3333, 4.4444, 5.5555}; std::vector\u0026lt;std::string\u0026gt; vec3 = {\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;, \u0026#34;eee\u0026#34;}; // Set different types of vectors in the INI file object inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = vec1; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = vec2; inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;] = vec3; // Get different vectors from INI file object std::vector\u0026lt;int\u0026gt; v1 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::vector\u0026lt;double\u0026gt; v2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; std::vector\u0026lt;std::string\u0026gt; v3 = inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;]; // Print the vectors to the console print_vector(v1); print_vector(v2); print_vector(v3); // Print the entire INI file content as a string std::cout \u0026lt;\u0026lt; \u0026#34;ini info:\\n\u0026#34; \u0026lt;\u0026lt; inif.to_string() \u0026lt;\u0026lt; std::endl; return 0; // Exit the program } æ·»åŠ äº†è‡ªåŠ¨éƒ¨ç½²åŠŸèƒ½\næµ‹è¯•éƒ¨ç½²åŠŸèƒ½\n","date":"2025-04-01T23:37:26+08:00","permalink":"https://abin-z.github.io/p/firstblog/","title":"Firstblog"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;â€”\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\nâ€” Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements â€” abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-03-11T00:00:00Z","image":"https://abin-z.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://abin-z.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"æ­£æ–‡æµ‹è¯• è€Œè¿™äº›å¹¶ä¸æ˜¯å®Œå…¨é‡è¦ï¼Œæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ï¼Œ å¸¦ç€è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬æ¥å®¡è§†ä¸€ä¸‹å­¦ç”Ÿä¼šé€€ä¼šã€‚ æ—¢ç„¶å¦‚ä½•ï¼Œ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ æˆ‘ä»¬ä¸å¾—ä¸é¢å¯¹ä¸€ä¸ªéå¸¸å°´å°¬çš„äº‹å®ï¼Œé‚£å°±æ˜¯ï¼Œ å¯æ˜¯ï¼Œå³ä½¿æ˜¯è¿™æ ·ï¼Œå­¦ç”Ÿä¼šé€€ä¼šçš„å‡ºç°ä»ç„¶ä»£è¡¨äº†ä¸€å®šçš„æ„ä¹‰ã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œå‘ç”Ÿäº†ä¼šå¦‚ä½•ï¼Œä¸å‘ç”Ÿåˆä¼šå¦‚ä½•ã€‚ ç»è¿‡ä¸Šè¿°è®¨è®ºï¼Œ ç”Ÿæ´»ä¸­ï¼Œè‹¥å­¦ç”Ÿä¼šé€€ä¼šå‡ºç°äº†ï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸è€ƒè™‘å®ƒå‡ºç°äº†çš„äº‹å®ã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•åº”è¯¥å¦‚ä½•å®ç°ã€‚ è¿™æ ·çœ‹æ¥ï¼Œ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ å°±æˆ‘ä¸ªäººæ¥è¯´ï¼Œå­¦ç”Ÿä¼šé€€ä¼šå¯¹æˆ‘çš„æ„ä¹‰ï¼Œä¸èƒ½ä¸è¯´éå¸¸é‡å¤§ã€‚ èå£«æ¯”äºšæ›¾ç»æåˆ°è¿‡ï¼Œäººçš„ä¸€ç”Ÿæ˜¯çŸ­çš„ï¼Œä½†å¦‚æœå‘åŠ£åœ°è¿‡è¿™ä¸€ç”Ÿï¼Œå°±å¤ªé•¿äº†ã€‚è¿™ä¼¼ä¹è§£ç­”äº†æˆ‘çš„ç–‘æƒ‘ã€‚ è«æ‰ç‰¹è¯´è¿‡ä¸€å¥å¯Œæœ‰å“²ç†çš„è¯ï¼Œè°å’Œæˆ‘ä¸€æ ·ç”¨åŠŸï¼Œè°å°±ä¼šå’Œæˆ‘ä¸€æ ·æˆåŠŸã€‚è¿™å¯å‘äº†æˆ‘ï¼Œ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•åº”è¯¥å¦‚ä½•å®ç°ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œ ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œ è¿™ç§äº‹å®å¯¹æœ¬äººæ¥è¯´æ„ä¹‰é‡å¤§ï¼Œç›¸ä¿¡å¯¹è¿™ä¸ªä¸–ç•Œä¹Ÿæ˜¯æœ‰ä¸€å®šæ„ä¹‰çš„ã€‚ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ äº†è§£æ¸…æ¥šå­¦ç”Ÿä¼šé€€ä¼šåˆ°åº•æ˜¯ä¸€ç§æ€ä¹ˆæ ·çš„å­˜åœ¨ï¼Œæ˜¯è§£å†³ä¸€åˆ‡é—®é¢˜çš„å…³é”®ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œ ç”Ÿæ´»ä¸­ï¼Œè‹¥å­¦ç”Ÿä¼šé€€ä¼šå‡ºç°äº†ï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸è€ƒè™‘å®ƒå‡ºç°äº†çš„äº‹å®ã€‚ é—®é¢˜çš„å…³é”®ç©¶ç«Ÿä¸ºä½•ï¼Ÿ è€Œè¿™äº›å¹¶ä¸æ˜¯å®Œå…¨é‡è¦ï¼Œæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ã€‚\nå¥¥æ–¯ç‰¹æ´›å¤«æ–¯åŸºæ›¾ç»è¯´è¿‡ï¼Œå…±åŒçš„äº‹ä¸šï¼Œå…±åŒçš„æ–—äº‰ï¼Œå¯ä»¥ä½¿äººä»¬äº§ç”Ÿå¿å—ä¸€åˆ‡çš„åŠ›é‡ã€‚ã€€å¸¦ç€è¿™å¥è¯ï¼Œæˆ‘ä»¬è¿˜è¦æ›´åŠ æ…é‡çš„å®¡è§†è¿™ä¸ªé—®é¢˜ï¼š ä¸€èˆ¬æ¥è®²ï¼Œæˆ‘ä»¬éƒ½å¿…é¡»åŠ¡å¿…æ…é‡çš„è€ƒè™‘è€ƒè™‘ã€‚ æ—¢ç„¶å¦‚æ­¤ï¼Œ è¿™ç§äº‹å®å¯¹æœ¬äººæ¥è¯´æ„ä¹‰é‡å¤§ï¼Œç›¸ä¿¡å¯¹è¿™ä¸ªä¸–ç•Œä¹Ÿæ˜¯æœ‰ä¸€å®šæ„ä¹‰çš„ã€‚ å¸¦ç€è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬æ¥å®¡è§†ä¸€ä¸‹å­¦ç”Ÿä¼šé€€ä¼šã€‚ æˆ‘è®¤ä¸ºï¼Œ æˆ‘è®¤ä¸ºï¼Œ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ é—®é¢˜çš„å…³é”®ç©¶ç«Ÿä¸ºä½•ï¼Ÿ æ¯ä¸ªäººéƒ½ä¸å¾—ä¸é¢å¯¹è¿™äº›é—®é¢˜ã€‚ åœ¨é¢å¯¹è¿™ç§é—®é¢˜æ—¶ï¼Œ è¦æƒ³æ¸…æ¥šï¼Œå­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•æ˜¯ä¸€ç§æ€ä¹ˆæ ·çš„å­˜åœ¨ã€‚ æˆ‘è®¤ä¸ºï¼Œ æ—¢ç„¶å¦‚æ­¤ï¼Œ æ¯ä¸ªäººéƒ½ä¸å¾—ä¸é¢å¯¹è¿™äº›é—®é¢˜ã€‚ åœ¨é¢å¯¹è¿™ç§é—®é¢˜æ—¶ï¼Œ é‚£ä¹ˆï¼Œ æˆ‘è®¤ä¸ºï¼Œ å­¦ç”Ÿä¼šé€€ä¼šå› ä½•è€Œå‘ç”Ÿã€‚\nå¼•ç”¨ æ€å¿µæ˜¯æœ€æš–çš„å¿§ä¼¤åƒä¸€åŒç¿…è†€\nè®©æˆ‘åœä¸äº†é£ä¸è¿œåœ¨è¿‡å¾€æ¸¸è¡\nä¸å‘Šè€Œåˆ«çš„ä½  å°±ç®—ä¸ºäº†æˆ‘ç€æƒ³\nè¿™ä¹ˆæ²‰ç—›çš„å‘µæŠ¤ æˆ‘æ€ä¹ˆèƒ½ç¿±ç¿”\næœ€æš–çš„æ†‚å‚· - ç”°é¦¥ç”„\nå›¾ç‰‡ 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) ç›¸å†Œè¯­æ³•æ¥è‡ª Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://abin-z.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://abin-z.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://abin-z.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://abin-z.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887â€¦$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://abin-z.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nğŸ™ˆ :see_no_evil: ğŸ™‰ :hear_no_evil: ğŸ™Š :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://abin-z.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://abin-z.github.io/p/emoji-support/","title":"Emoji Support"}]