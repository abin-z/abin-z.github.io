[{"content":"一个跨平台, 简单易用的Header-only线程池库, 基于Task提交, 支持提交任意参数提交, 支持获取返回值.\nGitHub仓库地址\n📌 线程池简介 线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程编程中。\n它的核心思想是：预先创建一定数量的线程放在“池子”里，任务来了就把任务交给空闲的线程来处理，而不是每次都新建线程。\n🚀特性亮点 任务提交灵活：支持任意可调用对象与参数组合，返回 std::future\u0026lt;T\u0026gt; 获取执行结果 线程安全：使用 std::mutex / std::condition_variable / std::atomic 构建同步机制 跨平台：纯 C++11 实现，兼容 Windows 与 POSIX 等系统 Header-only：仅需包含 thread_pool.h，零依赖，即可使用 RAII 自动管理资源：析构时自动关闭线程池，防止资源泄露 任务等待机制：支持主动调用 wait_all() 等待所有任务完成 灵活关闭策略：默认是自动关闭线程池的, 如果有需要可以手动关闭线程池: WaitForAllTasks: 等待所有任务完成后关闭 DiscardPendingTasks: 丢弃未开始的任务立即关闭 📦 快速开始 安装使用 拷贝thread_pool.h到你的项目目录，然后在代码中引入：\n1 #include \u0026#34;thread_pool.h\u0026#34; 无需额外依赖，完全头文件实现。\n基础示例代码 基础使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;thread_pool.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { abin::threadpool pool(4); auto future1 = pool.submit([] { return 42; }); std::cout \u0026lt;\u0026lt; \u0026#34;结果: \u0026#34; \u0026lt;\u0026lt; future1.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; auto future2 = pool.submit([](int a, int b) { return a + b; }, 5, 7); std::cout \u0026lt;\u0026lt; \u0026#34;加法结果: \u0026#34; \u0026lt;\u0026lt; future2.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 提交任意类型任意参数的可调用对象\n点击展开查看代码 ```cpp #include \"thread_pool.h\" #include #include #include #include void normal_function(int x) { std::cout \u0026laquo; \u0026ldquo;normal_function: \u0026quot; \u0026laquo; x \u0026laquo; std::endl; }\nstruct MyClass { void member_function(int y) { std::cout \u0026laquo; \u0026ldquo;MyClass::member_function: \u0026quot; \u0026laquo; y \u0026laquo; std::endl; } int add(int a, int b) { return a + b; } };\nstruct Functor { void operator()(const std::string\u0026amp; msg) const { std::cout \u0026laquo; \u0026ldquo;Functor called with: \u0026quot; \u0026laquo; msg \u0026laquo; std::endl; } };\nint main() { abin::threadpool pool(4);\n// 提交一个普通函数 pool.submit(normal_function, 42);\n// 提交一个无捕获 lambda pool.submit([] { std::cout \u0026laquo; \u0026ldquo;lambda no capture\\n\u0026rdquo;; });\n// 提交一个有捕获 lambda int value = 99; pool.submit([value] { std::cout \u0026laquo; \u0026ldquo;lambda with capture: \u0026quot; \u0026laquo; value \u0026laquo; \u0026ldquo;\\n\u0026rdquo;; });\n// 提交成员函数, 使用lambda MyClass obj; pool.submit([\u0026amp;obj] { obj.member_function(123); });\n// 提交成员函数, 使用 std::mem_fn std::future ret = pool.submit(std::mem_fn(\u0026amp;MyClass::add), \u0026amp;obj, 3, 4); std::cout \u0026laquo; \u0026ldquo;add result1: \u0026quot; \u0026laquo; ret.get() \u0026laquo; \u0026ldquo;\\n\u0026rdquo;;\n// 提交成员函数, 使用 std::bind std::future fut_add = pool.submit(std::bind(\u0026amp;MyClass::add, \u0026amp;obj, 2, 3)); std::cout \u0026laquo; \u0026ldquo;add result2: \u0026quot; \u0026laquo; fut_add.get() \u0026laquo; \u0026ldquo;\\n\u0026rdquo;;\n// 提交一个函数对象(仿函数) Functor f; pool.submit(f, \u0026ldquo;hello functor\u0026rdquo;);\n// 使用 std::bind 提交 auto bound = std::bind(\u0026amp;MyClass::add, \u0026amp;obj, 5, 6); std::future fut_bound = pool.submit(bound); std::cout \u0026laquo; \u0026ldquo;bound result: \u0026quot; \u0026laquo; fut_bound.get() \u0026laquo; \u0026ldquo;\\n\u0026rdquo;;\n// 提交一个 std::packaged_task(注意: 低版本msvc可能报错) std::packaged_taskstd::string() task([] { return std::string(\u0026ldquo;from packaged_task\u0026rdquo;); }); std::futurestd::string fut_str = task.get_future(); pool.submit(std::move(task)); // 必须 move std::cout \u0026laquo; \u0026ldquo;packaged_task result: \u0026quot; \u0026laquo; fut_str.get() \u0026laquo; \u0026ldquo;\\n\u0026rdquo;;\npool.wait_all(); // 等待任务完成 std::cout \u0026laquo; \u0026ldquo;===All tasks completed.===\\n\u0026rdquo;; }\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 \u0026lt;/details\u0026gt; ### ThreadPool源码 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;点击查看线程池源码\u0026lt;/summary\u0026gt; ```cpp /************************************************************************************************************** *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * @file: thread_pool.h * @version: v0.9.2 * @description: A cross-platform, lightweight, easy-to-use C++11 thread pool that supports submitting tasks with * arbitrary parameters and obtaining return values * - Futures * - Task-based: Supports tasks with arbitrary parameters, and obtains return values ​​through `std::future`. * - Cross-Platform: Works on platforms supporting C++11. * - Thread Safety: Uses `std::mutex`, `std::condition_variable`, and atomic variables for synchronization. * - Flexible Shutdown: Two modes for shutdown: `WaitForAllTasks` and `DiscardPendingTasks`. * - Lightweight \u0026amp; Easy-to-Use: Simple API with minimal setup. * * @author: abin * @date: 2025-04-20 * @license: MIT * @repository: https://github.com/abin-z/ThreadPool *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ **************************************************************************************************************/ #ifndef ABIN_THREADPOOL_H #define ABIN_THREADPOOL_H #include \u0026lt;atomic\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; namespace abin { /// @brief C++11的线程池, 提交任务支持任意多参数, 支持获取返回值 class threadpool { using task_t = std::function\u0026lt;void()\u0026gt;; // 定义任务类型为可调用对象 public: /// @brief 线程池当前状态信息结构体 struct status_info { std::size_t total_threads; // 总线程数 std::size_t busy_threads; // 正在执行任务的线程数 std::size_t idle_threads; // 空闲线程数 std::size_t pending_tasks; // 等待中的任务数 bool running; // 线程池是否在运行 }; /// @brief 关闭线程池的模式 enum class shutdown_mode : unsigned char { /// @brief 等待所有已提交的任务完成后再关闭线程池 /// 在此模式下, 线程池会等待所有任务(包括已开始和未开始的任务)执行完成后再关闭. WaitForAllTasks, /// @brief 立即关闭线程池, 丢弃尚未开始的任务. /// 在此模式下, 线程池会立即停止接收新任务, 丢弃所有尚未开始执行的任务, /// 但已经开始执行的任务会继续执行, 直到它们完成. DiscardPendingTasks }; public: /// @brief 构造函数, 初始化线程池并启动指定数量的工作线程 /// @param thread_count 要创建的线程数量, 默认为硬件支持的并发线程数(若无法获取则为 4) explicit threadpool(std::size_t thread_count = default_thread_count()) { launch_threads(validate_thread_count(thread_count)); // 创建线程 } /// @brief 析构函数, 停止所有线程并等待它们完成 ~threadpool() { shutdown(shutdown_mode::WaitForAllTasks); } /// @brief 提交任务到线程池并返回一个 future 对象, 用户可以通过它获取任务的返回值 /// /// @tparam F 任务类型的可调用对象 /// @tparam Args 可调用对象的参数类型 /// @param f 需要提交的任务 /// @param args 任务的参数 /// @return std::future\u0026lt;decltype(f(args...))\u0026gt; 返回一个 future 对象, 允许用户获取任务的返回值 template \u0026lt;typename F, typename... Args\u0026gt; auto submit(F \u0026amp;\u0026amp;f, Args \u0026amp;\u0026amp;...args) -\u0026gt; std::future\u0026lt;decltype(f(args...))\u0026gt; { if (!running_) throw std::runtime_error(\u0026#34;error: ThreadPool is not running. Cannot submit new tasks.\u0026#34;); using return_type = decltype(f(args...)); // 将 f 包装成 task, task 是一个 shared_ptr 指向 packaged_task auto task = std::make_shared\u0026lt;std::packaged_task\u0026lt;return_type()\u0026gt;\u0026gt;( std::bind(std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Args\u0026gt;(args)...) // 将函数和参数封装成一个 return_type() 的可调用对象 ); std::future\u0026lt;return_type\u0026gt; ret = task-\u0026gt;get_future(); // 获取与 task 相关联的 future { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); task_queue_.emplace([task] { (*task)(); }); // 将任务添加到任务队列中 } cv_.notify_one(); // 通知一个等待中的工作线程有新的任务可以执行 return ret; // 返回 future 对象 } /// @brief 阻塞直到所有任务完成(任务队列为空且没有任务在执行), 若没有任务，立即返回 void wait_all() { if (busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0) return; std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx_done_); cv_done_.wait(lock, [this] { return busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0; }); } /// @brief 关闭线程池 /// @param mode `WaitForAllTasks` 等待所有任务执行完成后再关闭; `DiscardPendingTasks` 立即关闭线程池, /// 抛弃尚未开始的任务. void shutdown(shutdown_mode mode = shutdown_mode::WaitForAllTasks) { { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); if (!running_) return; // 已经关闭则直接返回 running_ = false; if (mode == shutdown_mode::DiscardPendingTasks) // 放弃任务模式 { std::queue\u0026lt;task_t\u0026gt; empty; std::swap(task_queue_, empty); // 清空任务队列 } } cv_.notify_all(); for (std::thread \u0026amp;worker : workers_) { if (worker.joinable()) worker.join(); } workers_.clear(); } /// @brief 重启线程池, 先关闭当前线程池(等待所有任务完成), 然后以指定的线程数量重新启动线程池. /// @param thread_count 要创建的工作线程数量 void reboot(std::size_t thread_count) { shutdown(shutdown_mode::WaitForAllTasks); { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); if (running_) return; // 已重启, 无需再次初始化(幂等) running_ = true; launch_threads(validate_thread_count(thread_count)); } } /// @brief 当前线程池的总线程数量 std::size_t total_threads() const noexcept { return workers_.size(); } /// @brief 获取当前等待的任务数量 std::size_t pending_tasks() const noexcept { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); return task_queue_.size(); } /// @brief 获取繁忙的线程数量 std::size_t busy_threads() const noexcept { return busy_count_.load(); } /// @brief 获取空闲线程数量 std::size_t idle_threads() const noexcept { return workers_.size() - busy_count_.load(); } /// @brief 当前线程池是否正在运行(未停止) bool is_running() const noexcept { return running_.load(); } /// @brief 获取线程池的当前状态信息 status_info status() const noexcept { std::size_t total = 0; std::size_t pending = 0; { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); total = workers_.size(); pending = task_queue_.size(); } std::size_t busy = busy_count_.load(); std::size_t idle = total - busy; return {total, busy, idle, pending, running_.load()}; } // 禁用拷贝构造函数和拷贝赋值操作符 threadpool(const threadpool \u0026amp;) = delete; threadpool \u0026amp;operator=(const threadpool \u0026amp;) = delete; // 禁用移动构造函数和移动赋值操作符 threadpool(threadpool \u0026amp;\u0026amp;) = delete; threadpool \u0026amp;operator=(threadpool \u0026amp;\u0026amp;) = delete; private: /// @brief 默认线程数, 获取硬件支持的并发线程数, 若无法获取则默认为4 static std::size_t default_thread_count() { auto n = std::thread::hardware_concurrency(); return n == 0 ? 4 : n; } /// @brief 验证线程数是否合法, 1 \u0026lt;= count \u0026lt;= 4096 static std::size_t validate_thread_count(std::size_t count) { if (count \u0026lt; 1 || count \u0026gt; 4096) throw std::invalid_argument(\u0026#34;invalid thread_count: must be in range [1, 1024]\u0026#34;); return count; } /// @brief 启动线程池, 创建指定数量的工作线程 /// @param thread_count 线程池中线程的数量 void launch_threads(std::size_t thread_count) { if (!workers_.empty()) return; // 已经初始化过 for (std::size_t i = 0; i \u0026lt; thread_count; ++i) { // 创建并启动工作线程 workers_.emplace_back([this] { while (true) { task_t task; { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx_); // 等待直到任务队列中有任务, 或者线程池已停止 cv_.wait(lock, [this] { return !running_ || !task_queue_.empty(); }); if (!running_ \u0026amp;\u0026amp; task_queue_.empty()) return; // 如果线程池已经停止并且队列为空, 退出线程 task = std::move(task_queue_.front()); // 从队列中取出任务 task_queue_.pop(); } ++busy_count_; task(); // 执行任务 --busy_count_; // 判断任务是否已全部完成 if (busy_count_ == 0 \u0026amp;\u0026amp; task_queue_.empty()) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_done_); if (busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0) // 二次确认, 避免竞态 { cv_done_.notify_all(); } } } }); } } private: std::vector\u0026lt;std::thread\u0026gt; workers_; // 工作线程集合，用于并发执行任务 std::queue\u0026lt;task_t\u0026gt; task_queue_; // 等待执行的任务队列 std::condition_variable cv_; // 条件变量，用于通知工作线程有新任务到来 mutable std::mutex mtx_; // 主互斥锁，保护任务队列和与其相关的状态 std::atomic\u0026lt;std::size_t\u0026gt; busy_count_{0}; // 正在执行任务的线程数量 std::atomic\u0026lt;bool\u0026gt; running_{true}; // 线程池是否处于运行状态 mutable std::mutex mtx_done_; // 用于保护完成通知的互斥锁(wait_all 用) std::condition_variable cv_done_; // 条件变量，用于等待所有任务执行完毕(配合 wait_all 使用) }; } // namespace abin #endif // ABIN_THREADPOOL_H ","date":"2025-04-26T17:29:58+08:00","permalink":"https://abin-z.github.io/p/threadpool/","title":"C++跨平台轻量级线程池(ThreadPool)"},{"content":"SimpleTimer 是一个跨平台的轻量级定时器类，支持在后台线程中定期执行任务，适用于需要定时执行任务的场景。它支持暂停、恢复、修改时间间隔等功能，且不依赖任何第三方库，仅使用 C++11 标准库实现。\n特性 跨平台支持：在多个平台上（如 Windows、Linux、macOS）均可运行，基于 C++11 标准库实现。 线程安全：内部使用 std::thread 和 std::condition_variable，保证线程安全。 灵活的时间间隔：支持使用 std::chrono::duration 设置任意时间单位（分钟、秒、毫秒等）。 支持多种执行模式：包括单次执行（one-shot）和重复执行（周期性）。 控制功能完善：支持暂停、恢复、重启定时器，支持动态修改时间间隔。 时间精度良好：定时器精度取决于系统时钟，通常为毫秒级别。 自动资源管理：SimpleTimer 对象析构时会自动停止定时器，即使忘记调用 stop 也能确保资源正确释放。 使用方式 将 simple_timer.h 文件复制到你的项目目录中，在源码中引入即可使用:\n1 #include \u0026#34;simple_timer.h\u0026#34; 在 POSIX 系统（如 Linux、macOS）中，std::thread 基于 pthread 实现，因此需要在编译时加上 -lpthread 链接选项。\n示例代码 以下是一个完整的示例代码，展示了如何使用 SimpleTimer 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026#34;simple_timer.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { SimpleTimer timer(std::chrono::seconds(1)); // 定时器间隔为1秒，重复执行任务 timer.start([]() { std::cout \u0026lt;\u0026lt; \u0026#34;定时器任务执行！\u0026#34; \u0026lt;\u0026lt; std::endl; }); std::this_thread::sleep_for(std::chrono::seconds(5)); // 等待5秒 timer.pause(); // 暂停定时器 std::cout \u0026lt;\u0026lt; \u0026#34;定时器已暂停...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(3)); // 等待3秒 timer.resume(); // 恢复定时器 std::cout \u0026lt;\u0026lt; \u0026#34;定时器已恢复...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(5)); // 等待5秒 timer.stop(); // 停止定时器 std::cout \u0026lt;\u0026lt; \u0026#34;定时器已停止\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 代码实现: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 /** * @author: abin * @date: 2025-04-12 * @license: MIT * @repository: https://github.com/abin-z/SimpleTimer */ #ifndef SIMPLE_TIMER_H #define SIMPLE_TIMER_H #include \u0026lt;atomic\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; /** * @brief 使用 std::condition_variable 的 wait_until 方法 (也可以使用wait_for方法, 但是会累计误差) * 函数原型: * cv.wait_until(lock, time_point, predicate); * * wait_until 的行为: * - wait_until 方法的作用是让当前线程在指定的时间点之前等待, 直到条件变量被通知或者超时 * - 进入等待前会先检查 predicate() 的值. * - 如果 predicate() 在进入等待前立即为 true, 则直接返回 true, 不会进入等待状态 * - 如果 predicate() 为 false, 则进入等待状态, 直到 time_point 到达 * - 如果在 time_point 到达前 `notify_*` 被调用, 并且此时 predicate() 为 true, 则唤醒并返回 true * - 如果在 time_point 到达前 `notify_*` 被调用, 但此时 predicate() 为 false, 则继续等待(可能是虚假唤醒) * - 如果直到 time_point 到达时 predicate() 仍为 false, 返回 false(表示超时) * * 简要来说: * - `wait_until` 返回 true 表示条件变量被唤醒并且条件成立 * - `wait_until` 返回 false 表示已超时, 且条件仍未满足(即超时触发任务) */ /// @brief A simple timer class class SimpleTimer { using clock = std::chrono::steady_clock; // 单调时钟, 不受系统时间变化影响 public: /// @brief Timer state enum class State : unsigned char { Stopped = 0, // 停止 Running = 1, // 运行中 Paused = 2, // 暂停 }; /// @brief Constructs a SimpleTimer with a given duration /// @tparam Rep Duration representation type (e.g., int, long) /// @tparam Period Duration unit type (e.g., seconds, milliseconds) /// @param interval The time interval /// @param one_shot If true, the timer will only trigger once template \u0026lt;typename Rep, typename Period\u0026gt; SimpleTimer(std::chrono::duration\u0026lt;Rep, Period\u0026gt; interval, bool one_shot = false) : interval_(interval), one_shot_(one_shot), state_(State::Stopped) { } /// @brief Constructs a SimpleTimer with a millisecond interval /// @param milliseconds The time interval in milliseconds /// @param one_shot If true, the timer will only trigger once explicit SimpleTimer(long long milliseconds, bool one_shot = false) : SimpleTimer(std::chrono::milliseconds(milliseconds), one_shot) // 代理到主构造函数 { } /// @brief Constructs a SimpleTimer with a default interval of 10 seconds /// @param one_shot If true, the timer will only trigger once SimpleTimer(bool one_shot = false) : SimpleTimer(std::chrono::seconds(10), one_shot) // 默认间隔为10秒 { } /// @brief Destructor. Automatically stops the timer to clean up resources. ~SimpleTimer() { stop(); } // Delete copy constructor and copy assignment operator SimpleTimer(const SimpleTimer\u0026amp;) = delete; SimpleTimer\u0026amp; operator=(const SimpleTimer\u0026amp;) = delete; // Delete move constructor and move assignment operator SimpleTimer(SimpleTimer\u0026amp;\u0026amp;) = delete; SimpleTimer\u0026amp; operator=(SimpleTimer\u0026amp;\u0026amp;) = delete; /// @brief Starts the timer /// @tparam Func Callable object type /// @param f A callable object to be executed when the timer expires /// @note The timer task will be executed in a new thread template \u0026lt;typename Func\u0026gt; void start(Func\u0026amp;\u0026amp; f) { stop(); // 确保没有其他线程在运行(替换旧任务) state_ = State::Running; // 设置状态为运行中 auto task = std::move(std::forward\u0026lt;Func\u0026gt;(f)); // 完美转发后再 move, 提高效率 // 使用 std::thread 创建一个新的线程来执行定时器任务 thread_ = std::thread([this, task]() mutable { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mutex_); auto next_time = clock::now() + interval_; while (true) { if (state_ == State::Stopped) { break; } while (state_ == State::Paused) { cv_.wait(lock, [this]() { return state_ != State::Paused; }); next_time = clock::now() + interval_; // 重新计算下一次触发时间 } if (cv_.wait_until(lock, next_time, [this]() { return state_ != State::Running || interval_changed_; })) { if (interval_changed_) // interval_修改后立即使用新间隔 { next_time = clock::now() + interval_; interval_changed_ = false; } continue; // 若状态不是 Running, 继续循环判断; 若是 interval_ 被修改, 则更新 next_time 并立即跳过等待 } lock.unlock(); // Timer 内部处理异常, 执行task遇到异常后直接停止timer try { task(); // 执行任务 } catch (const std::exception\u0026amp; e) { state_ = State::Stopped; // 出现异常时停止定时器 (不能调用stop()会死锁) std::fprintf(stderr, \u0026#34;[SimpleTimer] Exception: %s\\n\u0026#34;, e.what()); } catch (...) { state_ = State::Stopped; // 出现异常时停止定时器 std::fprintf(stderr, \u0026#34;[SimpleTimer] Unknown exception occurred.\\n\u0026#34;); } lock.lock(); if (one_shot_) { state_ = State::Stopped; break; } next_time += interval_; // 精确推进时间点, 避免偏差 } }); } /// @brief Restarts the timer /// @tparam Func Callable object type /// @param f A callable object to be executed when the timer expires template \u0026lt;typename Func\u0026gt; void restart(Func\u0026amp;\u0026amp; f) { stop(); start(std::forward\u0026lt;Func\u0026gt;(f)); } /// @brief Stops the timer; waits for the current task to complete before fully stopping /// @note This method may block until the running task completes. void stop() { state_ = State::Stopped; cv_.notify_all(); // 唤醒等待的线程 if (thread_.joinable()) { thread_.join(); // 等待线程结束 } } /// @brief Pauses the timer void pause() { if (state_ == State::Running) { state_ = State::Paused; } } /// @brief Resumes the timer if it was paused void resume() { if (state_ == State::Paused) { state_ = State::Running; cv_.notify_all(); // 唤醒正在等待的线程 } } /// @brief Gets the current timer interval /// @return The interval in milliseconds std::chrono::milliseconds interval() const { return std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(interval_); } /// @brief Sets a new timer interval, takes effect immediately /// @param new_interval A duration representing the new interval template \u0026lt;typename Rep, typename Period\u0026gt; void set_interval(std::chrono::duration\u0026lt;Rep, Period\u0026gt; new_interval) { { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); interval_ = new_interval; interval_changed_ = true; // 标记为已改变 } cv_.notify_all(); // 确保线程能获取到新的时间间隔 } /// @brief Sets a new timer interval, takes effect immediately /// @param milliseconds New interval in milliseconds void set_interval(long long milliseconds) { set_interval(std::chrono::milliseconds(milliseconds)); } /// @brief Gets the current state of the timer /// @return The state of the timer State state() const { return state_; } /// @brief Checks if the timer is currently running /// @return true if running, false otherwise bool is_running() const { return state_ == State::Running; } /// @brief Checks if the timer is currently paused /// @return true if paused, false otherwise bool is_paused() const { return state_ == State::Paused; } /// @brief Checks if the timer is currently stopped /// @return true if stopped, false otherwise bool is_stopped() const { return state_ == State::Stopped; } private: // 定时器间隔, 默认10秒 clock::duration interval_ = std::chrono::seconds(10); bool interval_changed_ = false; // 时间间隔是否被修改过 bool one_shot_ = false; // 是否只触发一次 std::atomic\u0026lt;State\u0026gt; state_; // 定时器状态 std::thread thread_; // 定时器线程 std::mutex mutex_; // 互斥锁, 确保线程安全 std::condition_variable cv_; // 条件变量, 用于暂停和恢复 }; #endif // SIMPLE_TIMER_H ","date":"2025-04-13T01:20:56+08:00","permalink":"https://abin-z.github.io/p/simpletimer/","title":"SimpleTimer (基于C++11的简单定时器)"},{"content":"中文字符串在msvc编译器下出现异常报错 我在写中文单元测试用例,有以下cpp代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TEST_CASE(\u0026#34;case insensitive test08\u0026#34;, \u0026#34;[inifile][case_insensitive]\u0026#34;) { ini::case_insensitive_inifile inif; // 添加一些中文的测试 inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;] = \u0026#34;中文值\u0026#34;; // 测试中文的大小写不敏感性（实际上中文没有大小写，但测试是否受影响） CHECK(inif.contains(\u0026#34;中文节\u0026#34;) == true); CHECK(inif.contains(\u0026#34;中文节\u0026#34;, \u0026#34;中文键\u0026#34;) == true); CHECK(inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;].as\u0026lt;std::string\u0026gt;() == \u0026#34;中文值\u0026#34;); // 修改中文值 inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;] = \u0026#34;新的中文值\u0026#34;; CHECK(inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;].as\u0026lt;std::string\u0026gt;() == \u0026#34;新的中文值\u0026#34;); // 测试不存在的中文键 CHECK(inif.contains(\u0026#34;中文节\u0026#34;, \u0026#34;不存在的键\u0026#34;) == false); // 测试中文默认值 CHECK(inif.get(\u0026#34;中文节\u0026#34;, \u0026#34;不存在的键\u0026#34;, \u0026#34;默认值\u0026#34;).as\u0026lt;std::string\u0026gt;() == \u0026#34;默认值\u0026#34;); } 遇到的问题: 这段代码本身其实没啥问题, 在linux下使用gcc和clang都可以通过编译, 但是在msvc编译器下就有以下的编译错误:\n问题原因: 问题的根本原因是 Windows 下的 MSVC 默认使用本地系统代码页（例如 GBK/936）读取源代码文件，而不是 UTF-8，而你写的源代码中含有中文字符（UTF-8 编码）。MSVC 在不知情的情况下用本地代码页解释 UTF-8 内容，就会：\n错误地将 UTF-8 字节当作 GBK 解析，导致中文乱码 某些 UTF-8 字节组合不合法，会被当成非法字符或换行符处理 这些非法字符一旦出现在字符串、宏、甚至标识符中，就会引发各种报错 为什么 Linux 和 GCC/Clang 没问题？\nGCC 和 Clang 默认就是按 UTF-8 读取源代码文件，尤其是在 UTF-8 环境下（比如大多数 Linux 系统）。所以它们不会把 UTF-8 中的合法字符误解为非法字符或乱码，自然不会出错。\n解决方案 核心点: 只需要让msvc能按正确的encoding读取源文件即可.\n方式1: 明确告诉msvc，使用 UTF-8 读取编译源文件, 使用编译参数/utf-8, 比如在cmake中可以添加一下内容:\n1 2 3 4 # 如果是 MSVC 编译器，设置源文件为 UTF-8 编码 if (MSVC) add_compile_options(\u0026#34;/utf-8\u0026#34;) endif() 这行代码会为 MSVC 编译器添加 /utf-8 选项，指示 MSVC 使用 UTF-8 编码来读取和处理源文件中的字符。\n方式2: 将源码文件转为UTF-8 with BOM, vscode和notepad++都可以转换, 转换后就能成功识别并按照utf-8解析源文件.(Windows真是够无语的, 不带BOM的UTF-8不识别)\n最推荐的解决方案：\n确保所有源代码文件保存为 UTF-8 编码（无 BOM）。 在 CMakeLists.txt 中添加 add_compile_options(\u0026quot;/utf-8\u0026quot;)，告诉 MSVC 使用 UTF-8 编码。 如果你使用 Visual Studio，设置默认保存为 UTF-8。 tips：这个问题困扰我很多年了，一直没搞明白，所以简单记录下(或许也是我太菜了🙈)\n","date":"2025-04-10T19:39:24+08:00","permalink":"https://abin-z.github.io/p/msvc%E4%B8%8B%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/","title":"msvc下中文字符报错记录"},{"content":"这是我的第二个博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; // 自定义哈希函数 struct CaseInsensitiveHash { std::size_t operator()(const std::string \u0026amp;s) const { std::string lower_s = s; std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), [](unsigned char c) { return std::tolower(c); }); return std::hash\u0026lt;std::string\u0026gt;{}(lower_s); } }; // 自定义比较函数 struct CaseInsensitiveEqual { bool operator()(const std::string \u0026amp;lhs, const std::string \u0026amp;rhs) const { return lhs.size() == rhs.size() \u0026amp;\u0026amp; std::equal(lhs.begin(), lhs.end(), rhs.begin(), [](unsigned char a, unsigned char b) { return std::tolower(a) == std::tolower(b); }); } }; // field 类定义 class field { public: using comment_container = std::vector\u0026lt;std::string\u0026gt;; }; // 先声明 basic_inifile template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_inifile; // ini section（支持大小写不敏感键） template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_section { // 允许 basic_inifile 访问 private 成员 template \u0026lt;typename H, typename E\u0026gt; friend class basic_inifile; using DataContainer = std::unordered_map\u0026lt;std::string, field, Hash, Equal\u0026gt;; public: using comment_container = field::comment_container; using key_type = typename DataContainer::key_type; using mapped_type = typename DataContainer::mapped_type; using value_type = typename DataContainer::value_type; using size_type = typename DataContainer::size_type; using difference_type = typename DataContainer::difference_type; using iterator = typename DataContainer::iterator; using const_iterator = typename DataContainer::const_iterator; // 默认构造 basic_section() = default; // 默认析构函数 ~basic_section() = default; // 默认移动构造函数 basic_section(basic_section \u0026amp;\u0026amp;) noexcept = default; // 默认移动赋值函数 basic_section \u0026amp;operator=(basic_section \u0026amp;\u0026amp;) noexcept = default; private: DataContainer data_; // 存储键值对 }; // ini 文件类，存储多个 section template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_inifile { public: using section = basic_section\u0026lt;Hash, Equal\u0026gt;; // 在 basic_inifile 内部定义 section 别名 using SectionContainer = std::unordered_map\u0026lt;std::string, section, Hash, Equal\u0026gt;; using key_type = typename SectionContainer::key_type; using mapped_type = typename SectionContainer::mapped_type; using value_type = typename SectionContainer::value_type; using size_type = typename SectionContainer::size_type; using difference_type = typename SectionContainer::difference_type; using iterator = typename SectionContainer::iterator; using const_iterator = typename SectionContainer::const_iterator; // 默认构造 basic_inifile() = default; // 默认析构 ~basic_inifile() = default; // 默认移动构造 basic_inifile(basic_inifile \u0026amp;\u0026amp;) noexcept = default; // 默认移动赋值 basic_inifile \u0026amp;operator=(basic_inifile \u0026amp;\u0026amp;) noexcept = default; // 添加一个 section section \u0026amp;add_section(const std::string \u0026amp;name) { return sections_[name]; // 如果 name 存在，返回已有的 section，否则创建新 section } // 获取一个 section（可变版本） section *get_section(const std::string \u0026amp;name) { auto it = sections_.find(name); return it != sections_.end() ? \u0026amp;it-\u0026gt;second : nullptr; } // 获取一个 section（只读版本） const section *get_section(const std::string \u0026amp;name) const { auto it = sections_.find(name); return it != sections_.end() ? \u0026amp;it-\u0026gt;second : nullptr; } private: SectionContainer sections_; // 存储多个 section }; // 提供默认大小写不敏感的类型别名（类似 std::string） using section = basic_section\u0026lt;CaseInsensitiveHash, CaseInsensitiveEqual\u0026gt;; using inifile = basic_inifile\u0026lt;CaseInsensitiveHash, CaseInsensitiveEqual\u0026gt;; #include \u0026lt;iostream\u0026gt; int main() { inifile ini; // 默认使用大小写不敏感模式 ini.add_section(\u0026#34;General\u0026#34;); ini.add_section(\u0026#34;Database\u0026#34;); // 测试大小写不敏感 if (ini.get_section(\u0026#34;general\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;Section \u0026#39;General\u0026#39; exists (case insensitive)\u0026#34; \u0026lt;\u0026lt; std::endl; } if (ini.get_section(\u0026#34;DATABASE\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;Section \u0026#39;Database\u0026#39; exists (case insensitive)\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } ","date":"2025-04-02T21:38:50+08:00","permalink":"https://abin-z.github.io/p/secondblog/","title":"SecondBlog"},{"content":"你好, 世界 这是我的第一个博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;inifile/inifile.h\u0026gt; /// @brief Specialization of INIFILE_TYPE_CONVERTER for std::vector\u0026lt;T\u0026gt;. /// @tparam T The type of elements in the vector. template \u0026lt;typename T\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { /// @brief Encodes a vector into a delimited string. void encode(const std::vector\u0026lt;T\u0026gt; \u0026amp;vec, std::string \u0026amp;value) { constexpr char delimiter = \u0026#39;,\u0026#39;; // Delimiter used to separate elements in the string std::string encoded_item; for (const auto \u0026amp;v : vec) { INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt; conv; conv.encode(v, encoded_item); // Encode each element of the vector value += encoded_item + delimiter; // Append the encoded element and delimiter } if (value.back() == delimiter) value.pop_back(); // Remove the trailing delimiter } /// @brief Decodes a delimited string into a vector. void decode(const std::string \u0026amp;value, std::vector\u0026lt;T\u0026gt; \u0026amp;vec) { constexpr char delimiter = \u0026#39;,\u0026#39;; // Delimiter used to separate elements in the string std::vector\u0026lt;std::string\u0026gt; info = ini::split(value, delimiter); // Split the string T encoded_item; for (const auto \u0026amp;v : info) { INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt; conv; conv.decode(v, encoded_item); // Decode each part of the string vec.emplace_back(std::move(encoded_item)); // Add the decoded element to the vector } } }; /// @brief Print the contents of a vector to the console. template \u0026lt;typename T\u0026gt; void print_vector(const std::vector\u0026lt;T\u0026gt; \u0026amp;vec) { std::cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (size_t i = 0; i \u0026lt; vec.size(); ++i) { std::cout \u0026lt;\u0026lt; vec[i]; if (i != vec.size() - 1) { std::cout \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; } } std::cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { ini::inifile inif; // Create an INI file object // Define vectors of different types std::vector\u0026lt;int\u0026gt; vec1 = {1, 2, 3, 4, 5}; std::vector\u0026lt;double\u0026gt; vec2 = {1.1111, 2.2222, 3.3333, 4.4444, 5.5555}; std::vector\u0026lt;std::string\u0026gt; vec3 = {\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;, \u0026#34;eee\u0026#34;}; // Set different types of vectors in the INI file object inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = vec1; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = vec2; inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;] = vec3; // Get different vectors from INI file object std::vector\u0026lt;int\u0026gt; v1 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::vector\u0026lt;double\u0026gt; v2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; std::vector\u0026lt;std::string\u0026gt; v3 = inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;]; // Print the vectors to the console print_vector(v1); print_vector(v2); print_vector(v3); // Print the entire INI file content as a string std::cout \u0026lt;\u0026lt; \u0026#34;ini info:\\n\u0026#34; \u0026lt;\u0026lt; inif.to_string() \u0026lt;\u0026lt; std::endl; return 0; // Exit the program } 添加了自动部署功能\n","date":"2025-04-01T23:37:26+08:00","permalink":"https://abin-z.github.io/p/firstblog/","title":"Firstblog"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-03-11T00:00:00Z","image":"https://abin-z.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://abin-z.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://abin-z.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://abin-z.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://abin-z.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://abin-z.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://abin-z.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://abin-z.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://abin-z.github.io/p/emoji-support/","title":"Emoji Support"}]