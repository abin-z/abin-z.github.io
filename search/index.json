[{"content":"🌟 轻量级ini文件解析库 📌 项目简介 这是一个轻量级、跨平台、高效且 header-only 的 INI 配置解析库，专为 C++ 项目打造。它提供简洁、直观且优雅的 API，支持从文件、std::istream 或 std::string 解析、修改并写入 INI 配置信息，并具备行级注释保留功能，确保原始注释不丢失，使配置管理更加轻松高效。\n仓库地址: https://github.com/abin-z/IniFile\n🚀 特性 轻量级 \u0026amp; 无依赖：仅依赖 C++11 标准库，无需额外依赖项 易于集成：Header-only 设计，开箱即用，足够简单 直观 API：提供清晰友好的接口，简化 INI 配置操作 跨平台支持：支持Linux, Windows, MacOS等系统, 以及主流编译器 多种数据源：支持从文件，std::string 或 std::istream 解析 INI 数据，并写入其中 自动类型转换：支持多种数据类型，能自动处理类型转换(优雅的api接口) 支持注释功能: 支持ini行注释(;或者#), 可以为[section]和key=value添加行注释(不支持行尾注释) 自定义类型转换: 可以自定义类型转换, inifile将根据你写的定义进行自动转换(减少重复) 支持大小写不敏感功能: 提供可选的大小写不敏感功能(针对section和key) 适用于对 INI 配置有 解析、编辑、存储 需求的 C++ 项目。以下是基础的ini格式:\n1 2 3 ; comment [section] key = value 注: 本库内部使用std::string类型封装filed值, 可以很好的和 UTF-8 编码兼容, 但其他编码具体情况可能会有所不同.\n📦 使用方式 方式1: Header-only\n直接将inifile.h头文件复制到您的项目文件夹中\n然后在源代码文件中直接#include \u0026quot;inifile.h\u0026quot;即可使用\n方式2: 使用CMake\n在项目中创建一个inifile文件夹(名称随意)\n将本项目的include文件夹中的所有内容复制到刚才步骤1创建的inifile文件夹内\n然后在您的主CMakeLists.txt中添加以下内容\n1 add_subdirectory(inifile) # inifile为步骤1创建的文件夹名称 在源代码中添加#include \u0026lt;inifile/inifile.h\u0026gt;即可使用\n🛠️ 基础使用案例 下面提供简单的使用案例, 更多详细的案例请查看./examples/文件夹下的案例\n创建并保存ini文件 1 2 3 4 5 6 7 8 9 10 11 #include \u0026#34;inifile.h\u0026#34; int main() { constexpr char path[] = \u0026#34;path/to/ini/file\u0026#34;; ini::inifile inif; inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;] = true; inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = 3.14159; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = \u0026#34;value\u0026#34;; // Save the ini file, returns whether the save was successful or not. bool isok = inif.save(path); } 读取ini文件 1 2 3 4 5 6 7 8 9 10 11 #include \u0026#34;inifile.h\u0026#34; int main() { constexpr char path[] = \u0026#34;path/to/ini/file\u0026#34;; ini::inifile inif; // Load the ini file, return whether the loading was successful or not. bool isok = inif.load(path); bool b = inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;]; double d = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::string s = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; } stream流中读/写ini信息 支持stream流, 允许从std::istream流中读取ini数据, 也能向std::ostream中写入ini数据.\n1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { // create istream object \u0026#34;is\u0026#34; ... ini::inifile inif; inif.read(is); } 1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { // create ostream object \u0026#34;os\u0026#34; ... ini::inifile inif; inif.write(os); } std::string中读写ini信息 支持从std::string中读取ini数据, 也能将inifile 转为std::string.\n1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { // create string object \u0026#34;s\u0026#34; ... ini::inifile inif; inif.from_string(s); } 1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;] = \u0026#34;value\u0026#34;; std::string s = inif.to_string(); } 设置值 说明: 若section-key不存在, operator[]操作符和set函数会直接插入section-key, 若section-key存在则更新field值.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; /// Setting a single value inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = \u0026#34;value\u0026#34;; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;].set(\u0026#34;hello\u0026#34;); inif.set(\u0026#34;section\u0026#34;, \u0026#34;key3\u0026#34;, true); inif[\u0026#34;section\u0026#34;].set(\u0026#34;key4\u0026#34;, 3.14159); /// Setting multiple values for the same section, supporting different types inif[\u0026#34;section2\u0026#34;].set({{\u0026#34;bool\u0026#34;, false}, {\u0026#34;int\u0026#34;, 123}, {\u0026#34;double\u0026#34;, 999.888}, {\u0026#34;string\u0026#34;, \u0026#34;ABC\u0026#34;}, {\u0026#34;char\u0026#34;, \u0026#39;m\u0026#39;}}); } 获取值 说明: 获取值的时候需要注意以下两点:\n给定的section-key是否存在, 当section-key不存在时调用不同的函数会有不同的处理策略; 使用operator[]返回引用, 若给定section或key不存在则会插入空的field值, 并设置field为空字符串. (行为类似std::map的[]) 使用get()函数返回值, 若给定的section或key不存在不会插入field, 而是返回一个默认的空field值(可以指定默认值). 使用at()函数返回引用, 若给定的section或key不存在则抛出异常 : std::out_of_range 是否可以执行类型自动转换, 以上三个函数返回的是 ini::field 包装对象, 若将该对象转为其他类型需注意: 类型转换是否允许, 若类型转换不允许则抛出异常: std::invalid_argument, (例如将\u0026quot;abc\u0026quot;转为int) 数值类型转换范围是否溢出, 若超出目标类型的范围则抛出异常: std::out_of_range, (例如将INT_MAX转为uint8_t) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; /// automatic type conversion std::string s0 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; bool isok = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; int ii0 = inif.get(\u0026#34;section\u0026#34;, \u0026#34;key3\u0026#34;); int ii2 = inif.get(\u0026#34;section\u0026#34;, \u0026#34;key3\u0026#34;, -1); // Specify default values std::string ss2 = inif[\u0026#34;section\u0026#34;].get(\u0026#34;key4\u0026#34;); std::string ss3 = inif[\u0026#34;section\u0026#34;].get(\u0026#34;key5\u0026#34;, \u0026#34;default\u0026#34;); // Specify default values double dd0 = inif.at(\u0026#34;section\u0026#34;).at(\u0026#34;key\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;section-key:\u0026#34; \u0026lt;\u0026lt; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;].as\u0026lt;double\u0026gt;() \u0026lt;\u0026lt; std::endl; } 注释功能 本库支持设置[section]和key=value的行级注释(不支持行尾注释), 注释符号可选;和#两种; 也能从数据源中保留注释内容.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; // Set value inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;] = true; inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = 3.141592; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = \u0026#34;value\u0026#34;; // Add comments if necessary inif[\u0026#34;section\u0026#34;].set_comment(\u0026#34;This is a section comment.\u0026#34;); // set section comment, Overwrite Mode inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;].set_comment(\u0026#34;This is a key-value pairs comment\u0026#34;, \u0026#39;#\u0026#39;); // set key=value pairs comment inif[\u0026#34;section\u0026#34;].clear_comment(); // clear section comments inif[\u0026#34;section\u0026#34;].add_comment(\u0026#34;section comment01\u0026#34;); // add section comment, Append Mode inif[\u0026#34;section\u0026#34;].add_comment(\u0026#34;section comment02\\nsection comment03\u0026#34;); // Multi-line comments are allowed, lines separated by `\\n` bool isok = inif.save(\u0026#34;config.ini\u0026#34;); } config.ini的内容应该为:\n1 2 3 4 5 6 7 8 ; section comment01 ; section comment02 ; section comment03 [section] key0=true # This is a key-value pairs comment key1=3.141592 key2=value 大小写不敏感功能 本库支持section和key的大小写不敏感功能, 使用ini::case_insensitive_inifile即可, 具体案例请点击查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;inifile.h\u0026#34; int main() { const char *str = R\u0026#34;( [Section] KEY=Value Flag=123 hello=world )\u0026#34;; ini::case_insensitive_inifile inif; // Create a case-insensitive INI file object inif.from_string(str); // Read INI data from string // Test case-insensitive section and key access std::cout \u0026lt;\u0026lt; \u0026#34;inif.contains(\\\u0026#34;Section\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.contains(\u0026#34;Section\u0026#34;) \u0026lt;\u0026lt; std::endl; // true std::cout \u0026lt;\u0026lt; \u0026#34;inif.contains(\\\u0026#34;SECTION\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.contains(\u0026#34;SECTION\u0026#34;) \u0026lt;\u0026lt; std::endl; // true std::cout \u0026lt;\u0026lt; \u0026#34;inif.contains(\\\u0026#34;SeCtIoN\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.contains(\u0026#34;SeCtIoN\u0026#34;) \u0026lt;\u0026lt; std::endl; // true std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;section\\\u0026#34;).contains(\\\u0026#34;key\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;section\u0026#34;).contains(\u0026#34;key\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;section\\\u0026#34;).contains(\\\u0026#34;Key\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;section\u0026#34;).contains(\u0026#34;Key\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;SECTION\\\u0026#34;).contains(\\\u0026#34;KEY\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;SECTION\u0026#34;).contains(\u0026#34;KEY\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;SECTION\\\u0026#34;).contains(\\\u0026#34;flag\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;SECTION\u0026#34;).contains(\u0026#34;flag\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;SECTION\\\u0026#34;).contains(\\\u0026#34;FLAG\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;SECTION\u0026#34;).contains(\u0026#34;FLAG\u0026#34;) \u0026lt;\u0026lt; std::endl; return 0; } 关于自动类型转换 自动类型转换作用在ini::field对象上, 允许ini::field \u0026lt;=\u0026gt; other type互相转换; 但是需要注意: 若转换失败会抛出异常.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026#34;inifile.h\u0026#34; int main() { /// other type -\u0026gt; ini::field ini::field f(true); ini::field f1(10); ini::field f2 = 3.14; ini::field f3 = \u0026#39;c\u0026#39;; ini::field f4 = \u0026#34;abc\u0026#34;; /// ini::field -\u0026gt; other type bool b = f; int i = f1; double d = f2; char c = f3; std::string s = f4; ini::inifile inif; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;] = true; // bool -\u0026gt; ini::field /// Get direct type(ini::field) auto val = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; // val type is ini::field ini::field val2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; /// explicit type conversion bool bb = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;].as\u0026lt;bool\u0026gt;(); /// automatic type conversion bool bb2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; /// Type conversion failure throws an exception double n = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; // error: Converting true to double is not allowed. } 支持自动转换的类型包括:\nbool char, signed char, unsigned char short, unsigned short int, unsigned int long, unsigned long long long, unsigned long long float double long double std::string const char * std::string_view (C++17) 自定义类型转换 Q: 用户自定义类型可以像上面提到的基本数据类型一样自动转换吗?\nA: 也是可以的, 只需要按以下规则自定义类型转换就能让inifile自动处理用户自定义类型.\n你可以为用户自定义类型提供自动类型转换的特化模板类, 它能让inifile库根据你定义的规则进行自动转换, 使其可以将自定义类存储在ini字段中, 这样可以大幅减少代码的重复. 以下是自定义规则和模板:\n使用INIFILE_TYPE_CONVERTER宏特化自定义的类型(必须提供默认构造函数);\n定义encode函数, 作用是定义如何将自定义类型转为ini存储字符串(存储字符串不能包含换行符);\n定义decode函数, 作用是定义如何将ini存储字符串转为自定义类型;\n1 2 3 4 5 6 7 8 9 10 11 12 13 /// Specialized type conversion template template \u0026lt;\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;CustomClass\u0026gt; // User-defined type `CustomClass` { void encode(const CustomClass \u0026amp;obj, std::string \u0026amp;value) // pass by reference { // Convert the CustomClass object `obj` to ini storage string `value` } void decode(const std::string \u0026amp;value, CustomClass \u0026amp;obj) { // Convert the ini storage string `value` to a CustomClass object `obj` } } 为了方便编写 encode 和 decode 函数, 本库提供了 ini::join, ini::split() 和 ini::trim() 工具函数\n案例1: 下面是将一个用户自定义类Person对象转为ini字段案例. 点击查看详情\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /// @brief User-defined classes struct Person { Person() = default; // Must have a default constructor Person(int id, int age, const std::string \u0026amp;name) : id(id), age(age), name(name) {} int id = 0; int age = 0; std::string name; }; /// @brief Custom type conversion (Use INIFILE_TYPE_CONVERTER to specialize Person) template \u0026lt;\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;Person\u0026gt; { // \u0026#34;Encode\u0026#34; the Person object into a value string void encode(const Person \u0026amp;obj, std::string \u0026amp;value) { const char delimiter = \u0026#39;,\u0026#39;; // Format: id,age,name; Note: Please do not include line breaks in the value string value = std::to_string(obj.id) + delimiter + std::to_string(obj.age) + delimiter + obj.name; } // \u0026#34;Decode\u0026#34; the value string into a Person object void decode(const std::string \u0026amp;value, Person \u0026amp;obj) { const char delimiter = \u0026#39;,\u0026#39;; std::vector\u0026lt;std::string\u0026gt; info = ini::split(value, delimiter); // Exception handling can be added obj.id = std::stoi(info[0]); obj.age = std::stoi(info[1]); obj.name = info[2]; } }; int main() { ini::inifile inif; Person p = Person{123456, 18, \u0026#34;abin\u0026#34;}; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;] = p; // set person object Person pp = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; // get person object } 案例2: 可以嵌套调用INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt;, 实现STL容器自动转换, 能实现以下直接对容器赋值或取值的效果, 具体实现请点击查看详情\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Define vectors of different types std::vector\u0026lt;int\u0026gt; vec1 = {1, 2, 3, 4, 5}; std::vector\u0026lt;double\u0026gt; vec2 = {1.1111, 2.2222, 3.3333, 4.4444, 5.5555}; std::vector\u0026lt;std::string\u0026gt; vec3 = {\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;, \u0026#34;eee\u0026#34;}; // Set different types of vectors in the INI file object inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = vec1; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = vec2; inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;] = vec3; // Get different vectors from INI file object std::vector\u0026lt;int\u0026gt; v1 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::vector\u0026lt;double\u0026gt; v2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; std::vector\u0026lt;std::string\u0026gt; v3 = inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;]; 其他工具函数 提供其他多种工具函数, 判断是否为空empty(), 查询总个数size(), 查询key的个数count(), 是否包含元素contains(), 查找元素find(), 移除元素remove() 和 erase(), 清除所有元素clear(), 迭代器访问:begin(), end(), cbegin(), cend(), 支持范围for循环. 具体详情请查看常用 API 说明.\n下面提供一个迭代器访问ini信息:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026#34;inifile.h\u0026#34; int main() { constexpr char path[] = \u0026#34;path/to/ini/file\u0026#34;; ini::inifile inif; bool isok = inif.load(path); for (const auto \u0026amp;sec_pair : inif) { const std::string \u0026amp;section_name = sec_pair.first; const ini::section \u0026amp;section = sec_pair.second; std::cout \u0026lt;\u0026lt; \u0026#34; section \u0026#39;\u0026#34; \u0026lt;\u0026lt; section_name \u0026lt;\u0026lt; \u0026#34;\u0026#39; has \u0026#34; \u0026lt;\u0026lt; section.size() \u0026lt;\u0026lt; \u0026#34; key-values.\u0026#34; \u0026lt;\u0026lt; std::endl; for (const auto \u0026amp;kv : section) { const std::string \u0026amp;key = kv.first; const auto \u0026amp;value = kv.second; std::cout \u0026lt;\u0026lt; \u0026#34; kv: \u0026#39;\u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34;\u0026#39; = \u0026#39;\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; std::endl; } } } 📄 常用API说明 class 类型说明 class名称 描述 ini::inifile 对应整个ini数据, 包含了所有的section ini::section 对应整个section内容, 里面包含了本section所有的key-value值 ini::case_insensitive_inifile 对section和key大小写不敏感, 其他功能和ini::inifile一致 ini::case_insensitive_section 对key大小写不敏感, 其他功能和ini::section一致 ini::field 对应ini文件中的 value 字段, 支持多种数据类型, 支持自动类型转换 ini::field类API说明 点击展开 以下函数类型转换失败或者值溢出将抛异常\n函数名 函数签名 功能描述 field field(const T \u0026amp;other) 构造field对象, 将T类型转为field值 set void set(const T \u0026amp;value) 设置field值, 将T类型转为field值 operator= field \u0026amp;operator=(const T \u0026amp;rhs) 设置field值, 将T类型转为field值 operator T operator T() const 将field类型转为T类型 as T as() const 将field类型转为T类型 set_comment void set_comment(const std::string \u0026amp;str, char symbol = ';') 设置key-value的注释, 覆盖模式 add_comment void add_comment(const std::string \u0026amp;str, char symbol = ';') 添加key-value的注释, 追加模式 clear_comment void clear_comment() 清除key-value的注释 ini::section类API说明 点击展开 函数名 函数签名 功能描述 operator[] field \u0026amp;operator[](const std::string \u0026amp;key) 返回ini::field引用, 不存在则插入空ini::field set void set(std::string key, T \u0026amp;\u0026amp;value) 插入或更新指定key的field contains bool contains(std::string key) const 判断key是否存在 at field \u0026amp;at(std::string key) 返回指定key键的元素的字段值的引用。如果元素不存则抛 std::out_of_range异常 get field get(std::string key, field default_value = field{}) const 获取key对应的值(副本), 若key不存在则返回default_value默认值 find iterator find(const key_type \u0026amp;key) 查找指定key值的迭代器, 不存在返回end迭代器 erase iterator erase(iterator pos) 删除指定迭代器的key-value键值对 remove bool remove(std::string key) 删除指定的key-value键值对, 若不存在则什么都不做 empty bool empty() const noexcept 判断key-value键值对是否为空, 为空返回true clear void clear() noexcept 清除所有key - value键值对 size size_type size() const noexcept 返回有多少key - value键值对 count size_type count(const key_type \u0026amp;key) const 返回有多少指定key的key - value键值对 begin iterator begin() noexcept 返回起始迭代器 end iterator end() noexcept 返回末尾迭代器 set_comment void set_comment(const std::string \u0026amp;str, char symbol = ';') 设置section的注释, 覆盖模式, 注释字符串允许换行\\n add_comment void add_comment(const std::string \u0026amp;str, char symbol = ';') 添加section的注释, 追加模式, 注释字符串允许换行\\n clear_comment void clear_comment() 清除section的注释 ini::inifile类API说明 点击展开 函数名 函数签名 功能描述 operator[] section \u0026amp;operator[](const std::string \u0026amp;section) 返回ini::section引用, 不存在则插入空ini::section set void set(const std::string \u0026amp;section, const std::string \u0026amp;key, T \u0026amp;\u0026amp;value) 设置section key-value contains bool contains(std::string section) const 判断指定的section是否存在 contains bool contains(std::string section, std::string key) const 判断指定section下指定的key是否存在 at section \u0026amp;at(std::string section) 返回指定section的引用。如果不存在这样的元素，则会抛出 std::out_of_range 类型的异常 get field get(std::string sec, std::string key, field default_value = field{}) const 返回指定section的指定key键的字段值, 若section或key不存在则返回默认值default_value find iterator find(const key_type \u0026amp;key) 查找指定section的迭代器, 不存在返回end迭代器 erase iterator erase(iterator pos) 删除指定迭代器的section(包括其所有元素) remove bool remove(std::string sec) 删除指定的section(包括其所有元素) empty bool empty() const noexcept 判断是否没有section, 没有section空返回true clear void clear() noexcept 清空所有的section size size_type size() const noexcept 返回有多少section count size_type count(const key_type \u0026amp;key) const 返回有多少指定section-name的section begin iterator begin() noexcept 返回起始迭代器 end iterator end() noexcept 返回末尾迭代器 read void read(std::istream \u0026amp;is) 从istream中读取ini信息 write void write(std::ostream \u0026amp;os) const 向ostream中写入ini信息 from_string void from_string(const std::string \u0026amp;str) 从string中读取ini信息 to_string std::string to_string() const 将inifile对象转为对应字符串 load bool load(const std::string \u0026amp;filename) 从ini文件中加载ini信息, 返回是否成功 save bool save(const std::string \u0026amp;filename) 将ini信息保存到ini文件, 返回是否成功 ","date":"2025-05-04T22:05:03+08:00","permalink":"https://abin-z.github.io/p/%E8%BD%BB%E9%87%8F%E7%BA%A7ini%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%BA%93inifile/","title":"轻量级INI配置解析库(IniFile)"},{"content":"一个跨平台, 简单易用的Header-only线程池库, 基于Task提交, 支持提交任意参数提交, 支持获取返回值.\nGitHub仓库地址\n📌 线程池简介 线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程编程中。\n它的核心思想是：预先创建一定数量的线程放在“池子”里，任务来了就把任务交给空闲的线程来处理，而不是每次都新建线程。\n🚀特性亮点 任务提交灵活：支持任意可调用对象与参数组合，返回 std::future\u0026lt;T\u0026gt; 获取执行结果 线程安全：使用 std::mutex / std::condition_variable / std::atomic 构建同步机制 跨平台：纯 C++11 实现，兼容 Windows 与 POSIX 等系统 Header-only：仅需包含 thread_pool.h，零依赖，即可使用 RAII 自动管理资源：析构时自动关闭线程池，防止资源泄露 任务等待机制：支持主动调用 wait_all() 等待所有任务完成 灵活关闭策略：默认是自动关闭线程池的, 如果有需要可以手动关闭线程池: WaitForAllTasks: 等待所有任务完成后关闭 DiscardPendingTasks: 丢弃未开始的任务立即关闭 📦 快速开始 安装使用 拷贝thread_pool.h到你的项目目录，然后在代码中引入：\n1 #include \u0026#34;thread_pool.h\u0026#34; 无需额外依赖，完全头文件实现。\n基础示例代码 基础使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;thread_pool.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { abin::threadpool pool(4); auto future1 = pool.submit([] { return 42; }); std::cout \u0026lt;\u0026lt; \u0026#34;结果: \u0026#34; \u0026lt;\u0026lt; future1.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; auto future2 = pool.submit([](int a, int b) { return a + b; }, 5, 7); std::cout \u0026lt;\u0026lt; \u0026#34;加法结果: \u0026#34; \u0026lt;\u0026lt; future2.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 提交任意类型任意参数的可调用对象\n点击查看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026#34;thread_pool.h\u0026#34; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; void normal_function(int x) { std::cout \u0026lt;\u0026lt; \u0026#34;normal_function: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } struct MyClass { void member_function(int y) { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass::member_function: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; } int add(int a, int b) { return a + b; } }; struct Functor { void operator()(const std::string\u0026amp; msg) const { std::cout \u0026lt;\u0026lt; \u0026#34;Functor called with: \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; int main() { abin::threadpool pool(4); // 提交一个普通函数 pool.submit(normal_function, 42); // 提交一个无捕获 lambda pool.submit([] { std::cout \u0026lt;\u0026lt; \u0026#34;lambda no capture\\n\u0026#34;; }); // 提交一个有捕获 lambda int value = 99; pool.submit([value] { std::cout \u0026lt;\u0026lt; \u0026#34;lambda with capture: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }); // 提交成员函数, 使用lambda MyClass obj; pool.submit([\u0026amp;obj] { obj.member_function(123); }); // 提交成员函数, 使用 std::mem_fn std::future\u0026lt;int\u0026gt; ret = pool.submit(std::mem_fn(\u0026amp;MyClass::add), \u0026amp;obj, 3, 4); std::cout \u0026lt;\u0026lt; \u0026#34;add result1: \u0026#34; \u0026lt;\u0026lt; ret.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 提交成员函数, 使用 std::bind std::future\u0026lt;int\u0026gt; fut_add = pool.submit(std::bind(\u0026amp;MyClass::add, \u0026amp;obj, 2, 3)); std::cout \u0026lt;\u0026lt; \u0026#34;add result2: \u0026#34; \u0026lt;\u0026lt; fut_add.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 提交一个函数对象(仿函数) Functor f; pool.submit(f, \u0026#34;hello functor\u0026#34;); // 使用 std::bind 提交 auto bound = std::bind(\u0026amp;MyClass::add, \u0026amp;obj, 5, 6); std::future\u0026lt;int\u0026gt; fut_bound = pool.submit(bound); std::cout \u0026lt;\u0026lt; \u0026#34;bound result: \u0026#34; \u0026lt;\u0026lt; fut_bound.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 提交一个 std::packaged_task(注意: 低版本msvc可能报错) std::packaged_task\u0026lt;std::string()\u0026gt; task([] { return std::string(\u0026#34;from packaged_task\u0026#34;); }); std::future\u0026lt;std::string\u0026gt; fut_str = task.get_future(); pool.submit(std::move(task)); // 必须 move std::cout \u0026lt;\u0026lt; \u0026#34;packaged_task result: \u0026#34; \u0026lt;\u0026lt; fut_str.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; pool.wait_all(); // 等待任务完成 std::cout \u0026lt;\u0026lt; \u0026#34;===All tasks completed.===\\n\u0026#34;; } ThreadPool源码 点击查看线程池源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 /************************************************************************************************************** *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * @file: thread_pool.h * @version: v0.9.2 * @description: A cross-platform, lightweight, easy-to-use C++11 thread pool that supports submitting tasks with * arbitrary parameters and obtaining return values * - Futures * - Task-based: Supports tasks with arbitrary parameters, and obtains return values ​​through `std::future`. * - Cross-Platform: Works on platforms supporting C++11. * - Thread Safety: Uses `std::mutex`, `std::condition_variable`, and atomic variables for synchronization. * - Flexible Shutdown: Two modes for shutdown: `WaitForAllTasks` and `DiscardPendingTasks`. * - Lightweight \u0026amp; Easy-to-Use: Simple API with minimal setup. * * @author: abin * @date: 2025-04-20 * @license: MIT * @repository: https://github.com/abin-z/ThreadPool *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ **************************************************************************************************************/ #ifndef ABIN_THREADPOOL_H #define ABIN_THREADPOOL_H #include \u0026lt;atomic\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; namespace abin { /// @brief C++11的线程池, 提交任务支持任意多参数, 支持获取返回值 class threadpool { using task_t = std::function\u0026lt;void()\u0026gt;; // 定义任务类型为可调用对象 public: /// @brief 线程池当前状态信息结构体 struct status_info { std::size_t total_threads; // 总线程数 std::size_t busy_threads; // 正在执行任务的线程数 std::size_t idle_threads; // 空闲线程数 std::size_t pending_tasks; // 等待中的任务数 bool running; // 线程池是否在运行 }; /// @brief 关闭线程池的模式 enum class shutdown_mode : unsigned char { /// @brief 等待所有已提交的任务完成后再关闭线程池 /// 在此模式下, 线程池会等待所有任务(包括已开始和未开始的任务)执行完成后再关闭. WaitForAllTasks, /// @brief 立即关闭线程池, 丢弃尚未开始的任务. /// 在此模式下, 线程池会立即停止接收新任务, 丢弃所有尚未开始执行的任务, /// 但已经开始执行的任务会继续执行, 直到它们完成. DiscardPendingTasks }; public: /// @brief 构造函数, 初始化线程池并启动指定数量的工作线程 /// @param thread_count 要创建的线程数量, 默认为硬件支持的并发线程数(若无法获取则为 4) explicit threadpool(std::size_t thread_count = default_thread_count()) { launch_threads(validate_thread_count(thread_count)); // 创建线程 } /// @brief 析构函数, 停止所有线程并等待它们完成 ~threadpool() { shutdown(shutdown_mode::WaitForAllTasks); } /// @brief 提交任务到线程池并返回一个 future 对象, 用户可以通过它获取任务的返回值 /// /// @tparam F 任务类型的可调用对象 /// @tparam Args 可调用对象的参数类型 /// @param f 需要提交的任务 /// @param args 任务的参数 /// @return std::future\u0026lt;decltype(f(args...))\u0026gt; 返回一个 future 对象, 允许用户获取任务的返回值 template \u0026lt;typename F, typename... Args\u0026gt; auto submit(F \u0026amp;\u0026amp;f, Args \u0026amp;\u0026amp;...args) -\u0026gt; std::future\u0026lt;decltype(f(args...))\u0026gt; { if (!running_) throw std::runtime_error(\u0026#34;error: ThreadPool is not running. Cannot submit new tasks.\u0026#34;); using return_type = decltype(f(args...)); // 将 f 包装成 task, task 是一个 shared_ptr 指向 packaged_task auto task = std::make_shared\u0026lt;std::packaged_task\u0026lt;return_type()\u0026gt;\u0026gt;( std::bind(std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Args\u0026gt;(args)...) // 将函数和参数封装成一个 return_type() 的可调用对象 ); std::future\u0026lt;return_type\u0026gt; ret = task-\u0026gt;get_future(); // 获取与 task 相关联的 future { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); task_queue_.emplace([task] { (*task)(); }); // 将任务添加到任务队列中 } cv_.notify_one(); // 通知一个等待中的工作线程有新的任务可以执行 return ret; // 返回 future 对象 } /// @brief 阻塞直到所有任务完成(任务队列为空且没有任务在执行), 若没有任务，立即返回 void wait_all() { if (busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0) return; std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx_done_); cv_done_.wait(lock, [this] { return busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0; }); } /// @brief 关闭线程池 /// @param mode `WaitForAllTasks` 等待所有任务执行完成后再关闭; `DiscardPendingTasks` 立即关闭线程池, /// 抛弃尚未开始的任务. void shutdown(shutdown_mode mode = shutdown_mode::WaitForAllTasks) { { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); if (!running_) return; // 已经关闭则直接返回 running_ = false; if (mode == shutdown_mode::DiscardPendingTasks) // 放弃任务模式 { std::queue\u0026lt;task_t\u0026gt; empty; std::swap(task_queue_, empty); // 清空任务队列 } } cv_.notify_all(); for (std::thread \u0026amp;worker : workers_) { if (worker.joinable()) worker.join(); } workers_.clear(); } /// @brief 重启线程池, 先关闭当前线程池(等待所有任务完成), 然后以指定的线程数量重新启动线程池. /// @param thread_count 要创建的工作线程数量 void reboot(std::size_t thread_count) { shutdown(shutdown_mode::WaitForAllTasks); { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); if (running_) return; // 已重启, 无需再次初始化(幂等) running_ = true; launch_threads(validate_thread_count(thread_count)); } } /// @brief 当前线程池的总线程数量 std::size_t total_threads() const noexcept { return workers_.size(); } /// @brief 获取当前等待的任务数量 std::size_t pending_tasks() const noexcept { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); return task_queue_.size(); } /// @brief 获取繁忙的线程数量 std::size_t busy_threads() const noexcept { return busy_count_.load(); } /// @brief 获取空闲线程数量 std::size_t idle_threads() const noexcept { return workers_.size() - busy_count_.load(); } /// @brief 当前线程池是否正在运行(未停止) bool is_running() const noexcept { return running_.load(); } /// @brief 获取线程池的当前状态信息 status_info status() const noexcept { std::size_t total = 0; std::size_t pending = 0; { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); total = workers_.size(); pending = task_queue_.size(); } std::size_t busy = busy_count_.load(); std::size_t idle = total - busy; return {total, busy, idle, pending, running_.load()}; } // 禁用拷贝构造函数和拷贝赋值操作符 threadpool(const threadpool \u0026amp;) = delete; threadpool \u0026amp;operator=(const threadpool \u0026amp;) = delete; // 禁用移动构造函数和移动赋值操作符 threadpool(threadpool \u0026amp;\u0026amp;) = delete; threadpool \u0026amp;operator=(threadpool \u0026amp;\u0026amp;) = delete; private: /// @brief 默认线程数, 获取硬件支持的并发线程数, 若无法获取则默认为4 static std::size_t default_thread_count() { auto n = std::thread::hardware_concurrency(); return n == 0 ? 4 : n; } /// @brief 验证线程数是否合法, 1 \u0026lt;= count \u0026lt;= 4096 static std::size_t validate_thread_count(std::size_t count) { if (count \u0026lt; 1 || count \u0026gt; 4096) throw std::invalid_argument(\u0026#34;invalid thread_count: must be in range [1, 1024]\u0026#34;); return count; } /// @brief 启动线程池, 创建指定数量的工作线程 /// @param thread_count 线程池中线程的数量 void launch_threads(std::size_t thread_count) { if (!workers_.empty()) return; // 已经初始化过 for (std::size_t i = 0; i \u0026lt; thread_count; ++i) { // 创建并启动工作线程 workers_.emplace_back([this] { while (true) { task_t task; { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx_); // 等待直到任务队列中有任务, 或者线程池已停止 cv_.wait(lock, [this] { return !running_ || !task_queue_.empty(); }); if (!running_ \u0026amp;\u0026amp; task_queue_.empty()) return; // 如果线程池已经停止并且队列为空, 退出线程 task = std::move(task_queue_.front()); // 从队列中取出任务 task_queue_.pop(); } ++busy_count_; task(); // 执行任务 --busy_count_; // 判断任务是否已全部完成 if (busy_count_ == 0 \u0026amp;\u0026amp; task_queue_.empty()) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_done_); if (busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0) // 二次确认, 避免竞态 { cv_done_.notify_all(); } } } }); } } private: std::vector\u0026lt;std::thread\u0026gt; workers_; // 工作线程集合，用于并发执行任务 std::queue\u0026lt;task_t\u0026gt; task_queue_; // 等待执行的任务队列 std::condition_variable cv_; // 条件变量，用于通知工作线程有新任务到来 mutable std::mutex mtx_; // 主互斥锁，保护任务队列和与其相关的状态 std::atomic\u0026lt;std::size_t\u0026gt; busy_count_{0}; // 正在执行任务的线程数量 std::atomic\u0026lt;bool\u0026gt; running_{true}; // 线程池是否处于运行状态 mutable std::mutex mtx_done_; // 用于保护完成通知的互斥锁(wait_all 用) std::condition_variable cv_done_; // 条件变量，用于等待所有任务执行完毕(配合 wait_all 使用) }; } // namespace abin #endif // ABIN_THREADPOOL_H ","date":"2025-04-26T17:29:58+08:00","permalink":"https://abin-z.github.io/p/threadpool/","title":"C++跨平台轻量级线程池(ThreadPool)"},{"content":"SimpleTimer 是一个跨平台的轻量级定时器类，支持在后台线程中定期执行任务，适用于需要定时执行任务的场景。它支持暂停、恢复、修改时间间隔等功能，且不依赖任何第三方库，仅使用 C++11 标准库实现。\n特性 跨平台支持：在多个平台上（如 Windows、Linux、macOS）均可运行，基于 C++11 标准库实现。 线程安全：内部使用 std::thread 和 std::condition_variable，保证线程安全。 灵活的时间间隔：支持使用 std::chrono::duration 设置任意时间单位（分钟、秒、毫秒等）。 支持多种执行模式：包括单次执行（one-shot）和重复执行（周期性）。 控制功能完善：支持暂停、恢复、重启定时器，支持动态修改时间间隔。 时间精度良好：定时器精度取决于系统时钟，通常为毫秒级别。 自动资源管理：SimpleTimer 对象析构时会自动停止定时器，即使忘记调用 stop 也能确保资源正确释放。 使用方式 将 simple_timer.h 文件复制到你的项目目录中，在源码中引入即可使用:\n1 #include \u0026#34;simple_timer.h\u0026#34; 在 POSIX 系统（如 Linux、macOS）中，std::thread 基于 pthread 实现，因此需要在编译时加上 -lpthread 链接选项。\n示例代码 以下是一个完整的示例代码，展示了如何使用 SimpleTimer 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026#34;simple_timer.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { SimpleTimer timer(std::chrono::seconds(1)); // 定时器间隔为1秒，重复执行任务 timer.start([]() { std::cout \u0026lt;\u0026lt; \u0026#34;定时器任务执行！\u0026#34; \u0026lt;\u0026lt; std::endl; }); std::this_thread::sleep_for(std::chrono::seconds(5)); // 等待5秒 timer.pause(); // 暂停定时器 std::cout \u0026lt;\u0026lt; \u0026#34;定时器已暂停...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(3)); // 等待3秒 timer.resume(); // 恢复定时器 std::cout \u0026lt;\u0026lt; \u0026#34;定时器已恢复...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(5)); // 等待5秒 timer.stop(); // 停止定时器 std::cout \u0026lt;\u0026lt; \u0026#34;定时器已停止\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 代码实现: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 /** * @author: abin * @date: 2025-04-12 * @license: MIT * @repository: https://github.com/abin-z/SimpleTimer */ #ifndef SIMPLE_TIMER_H #define SIMPLE_TIMER_H #include \u0026lt;atomic\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; /** * @brief 使用 std::condition_variable 的 wait_until 方法 (也可以使用wait_for方法, 但是会累计误差) * 函数原型: * cv.wait_until(lock, time_point, predicate); * * wait_until 的行为: * - wait_until 方法的作用是让当前线程在指定的时间点之前等待, 直到条件变量被通知或者超时 * - 进入等待前会先检查 predicate() 的值. * - 如果 predicate() 在进入等待前立即为 true, 则直接返回 true, 不会进入等待状态 * - 如果 predicate() 为 false, 则进入等待状态, 直到 time_point 到达 * - 如果在 time_point 到达前 `notify_*` 被调用, 并且此时 predicate() 为 true, 则唤醒并返回 true * - 如果在 time_point 到达前 `notify_*` 被调用, 但此时 predicate() 为 false, 则继续等待(可能是虚假唤醒) * - 如果直到 time_point 到达时 predicate() 仍为 false, 返回 false(表示超时) * * 简要来说: * - `wait_until` 返回 true 表示条件变量被唤醒并且条件成立 * - `wait_until` 返回 false 表示已超时, 且条件仍未满足(即超时触发任务) */ /// @brief A simple timer class class SimpleTimer { using clock = std::chrono::steady_clock; // 单调时钟, 不受系统时间变化影响 public: /// @brief Timer state enum class State : unsigned char { Stopped = 0, // 停止 Running = 1, // 运行中 Paused = 2, // 暂停 }; /// @brief Constructs a SimpleTimer with a given duration /// @tparam Rep Duration representation type (e.g., int, long) /// @tparam Period Duration unit type (e.g., seconds, milliseconds) /// @param interval The time interval /// @param one_shot If true, the timer will only trigger once template \u0026lt;typename Rep, typename Period\u0026gt; SimpleTimer(std::chrono::duration\u0026lt;Rep, Period\u0026gt; interval, bool one_shot = false) : interval_(interval), one_shot_(one_shot), state_(State::Stopped) { } /// @brief Constructs a SimpleTimer with a millisecond interval /// @param milliseconds The time interval in milliseconds /// @param one_shot If true, the timer will only trigger once explicit SimpleTimer(long long milliseconds, bool one_shot = false) : SimpleTimer(std::chrono::milliseconds(milliseconds), one_shot) // 代理到主构造函数 { } /// @brief Constructs a SimpleTimer with a default interval of 10 seconds /// @param one_shot If true, the timer will only trigger once SimpleTimer(bool one_shot = false) : SimpleTimer(std::chrono::seconds(10), one_shot) // 默认间隔为10秒 { } /// @brief Destructor. Automatically stops the timer to clean up resources. ~SimpleTimer() { stop(); } // Delete copy constructor and copy assignment operator SimpleTimer(const SimpleTimer\u0026amp;) = delete; SimpleTimer\u0026amp; operator=(const SimpleTimer\u0026amp;) = delete; // Delete move constructor and move assignment operator SimpleTimer(SimpleTimer\u0026amp;\u0026amp;) = delete; SimpleTimer\u0026amp; operator=(SimpleTimer\u0026amp;\u0026amp;) = delete; /// @brief Starts the timer /// @tparam Func Callable object type /// @param f A callable object to be executed when the timer expires /// @note The timer task will be executed in a new thread template \u0026lt;typename Func\u0026gt; void start(Func\u0026amp;\u0026amp; f) { stop(); // 确保没有其他线程在运行(替换旧任务) state_ = State::Running; // 设置状态为运行中 auto task = std::move(std::forward\u0026lt;Func\u0026gt;(f)); // 完美转发后再 move, 提高效率 // 使用 std::thread 创建一个新的线程来执行定时器任务 thread_ = std::thread([this, task]() mutable { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mutex_); auto next_time = clock::now() + interval_; while (true) { if (state_ == State::Stopped) { break; } while (state_ == State::Paused) { cv_.wait(lock, [this]() { return state_ != State::Paused; }); next_time = clock::now() + interval_; // 重新计算下一次触发时间 } if (cv_.wait_until(lock, next_time, [this]() { return state_ != State::Running || interval_changed_; })) { if (interval_changed_) // interval_修改后立即使用新间隔 { next_time = clock::now() + interval_; interval_changed_ = false; } continue; // 若状态不是 Running, 继续循环判断; 若是 interval_ 被修改, 则更新 next_time 并立即跳过等待 } lock.unlock(); // Timer 内部处理异常, 执行task遇到异常后直接停止timer try { task(); // 执行任务 } catch (const std::exception\u0026amp; e) { state_ = State::Stopped; // 出现异常时停止定时器 (不能调用stop()会死锁) std::fprintf(stderr, \u0026#34;[SimpleTimer] Exception: %s\\n\u0026#34;, e.what()); } catch (...) { state_ = State::Stopped; // 出现异常时停止定时器 std::fprintf(stderr, \u0026#34;[SimpleTimer] Unknown exception occurred.\\n\u0026#34;); } lock.lock(); if (one_shot_) { state_ = State::Stopped; break; } next_time += interval_; // 精确推进时间点, 避免偏差 } }); } /// @brief Restarts the timer /// @tparam Func Callable object type /// @param f A callable object to be executed when the timer expires template \u0026lt;typename Func\u0026gt; void restart(Func\u0026amp;\u0026amp; f) { stop(); start(std::forward\u0026lt;Func\u0026gt;(f)); } /// @brief Stops the timer; waits for the current task to complete before fully stopping /// @note This method may block until the running task completes. void stop() { state_ = State::Stopped; cv_.notify_all(); // 唤醒等待的线程 if (thread_.joinable()) { thread_.join(); // 等待线程结束 } } /// @brief Pauses the timer void pause() { if (state_ == State::Running) { state_ = State::Paused; } } /// @brief Resumes the timer if it was paused void resume() { if (state_ == State::Paused) { state_ = State::Running; cv_.notify_all(); // 唤醒正在等待的线程 } } /// @brief Gets the current timer interval /// @return The interval in milliseconds std::chrono::milliseconds interval() const { return std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(interval_); } /// @brief Sets a new timer interval, takes effect immediately /// @param new_interval A duration representing the new interval template \u0026lt;typename Rep, typename Period\u0026gt; void set_interval(std::chrono::duration\u0026lt;Rep, Period\u0026gt; new_interval) { { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); interval_ = new_interval; interval_changed_ = true; // 标记为已改变 } cv_.notify_all(); // 确保线程能获取到新的时间间隔 } /// @brief Sets a new timer interval, takes effect immediately /// @param milliseconds New interval in milliseconds void set_interval(long long milliseconds) { set_interval(std::chrono::milliseconds(milliseconds)); } /// @brief Gets the current state of the timer /// @return The state of the timer State state() const { return state_; } /// @brief Checks if the timer is currently running /// @return true if running, false otherwise bool is_running() const { return state_ == State::Running; } /// @brief Checks if the timer is currently paused /// @return true if paused, false otherwise bool is_paused() const { return state_ == State::Paused; } /// @brief Checks if the timer is currently stopped /// @return true if stopped, false otherwise bool is_stopped() const { return state_ == State::Stopped; } private: // 定时器间隔, 默认10秒 clock::duration interval_ = std::chrono::seconds(10); bool interval_changed_ = false; // 时间间隔是否被修改过 bool one_shot_ = false; // 是否只触发一次 std::atomic\u0026lt;State\u0026gt; state_; // 定时器状态 std::thread thread_; // 定时器线程 std::mutex mutex_; // 互斥锁, 确保线程安全 std::condition_variable cv_; // 条件变量, 用于暂停和恢复 }; #endif // SIMPLE_TIMER_H ","date":"2025-04-13T01:20:56+08:00","permalink":"https://abin-z.github.io/p/simpletimer/","title":"基于C++11的简单定时器(SimpleTimer)"},{"content":"中文字符串在msvc编译器下出现异常报错 我在写中文单元测试用例,有以下cpp代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TEST_CASE(\u0026#34;case insensitive test08\u0026#34;, \u0026#34;[inifile][case_insensitive]\u0026#34;) { ini::case_insensitive_inifile inif; // 添加一些中文的测试 inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;] = \u0026#34;中文值\u0026#34;; // 测试中文的大小写不敏感性（实际上中文没有大小写，但测试是否受影响） CHECK(inif.contains(\u0026#34;中文节\u0026#34;) == true); CHECK(inif.contains(\u0026#34;中文节\u0026#34;, \u0026#34;中文键\u0026#34;) == true); CHECK(inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;].as\u0026lt;std::string\u0026gt;() == \u0026#34;中文值\u0026#34;); // 修改中文值 inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;] = \u0026#34;新的中文值\u0026#34;; CHECK(inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;].as\u0026lt;std::string\u0026gt;() == \u0026#34;新的中文值\u0026#34;); // 测试不存在的中文键 CHECK(inif.contains(\u0026#34;中文节\u0026#34;, \u0026#34;不存在的键\u0026#34;) == false); // 测试中文默认值 CHECK(inif.get(\u0026#34;中文节\u0026#34;, \u0026#34;不存在的键\u0026#34;, \u0026#34;默认值\u0026#34;).as\u0026lt;std::string\u0026gt;() == \u0026#34;默认值\u0026#34;); } 遇到的问题: 这段代码本身其实没啥问题, 在linux下使用gcc和clang都可以通过编译, 但是在msvc编译器下就有以下的编译错误:\n问题原因: 问题的根本原因是 Windows 下的 MSVC 默认使用本地系统代码页（例如 GBK/936）读取源代码文件，而不是 UTF-8，而你写的源代码中含有中文字符（UTF-8 编码）。MSVC 在不知情的情况下用本地代码页解释 UTF-8 内容，就会：\n错误地将 UTF-8 字节当作 GBK 解析，导致中文乱码 某些 UTF-8 字节组合不合法，会被当成非法字符或换行符处理 这些非法字符一旦出现在字符串、宏、甚至标识符中，就会引发各种报错 为什么 Linux 和 GCC/Clang 没问题？\nGCC 和 Clang 默认就是按 UTF-8 读取源代码文件，尤其是在 UTF-8 环境下（比如大多数 Linux 系统）。所以它们不会把 UTF-8 中的合法字符误解为非法字符或乱码，自然不会出错。\n解决方案 核心点: 只需要让msvc能按正确的encoding读取源文件即可.\n方式1: 明确告诉msvc，使用 UTF-8 读取编译源文件, 使用编译参数/utf-8, 比如在cmake中可以添加一下内容:\n1 2 3 4 # 如果是 MSVC 编译器，设置源文件为 UTF-8 编码 if (MSVC) add_compile_options(\u0026#34;/utf-8\u0026#34;) endif() 这行代码会为 MSVC 编译器添加 /utf-8 选项，指示 MSVC 使用 UTF-8 编码来读取和处理源文件中的字符。\n方式2: 将源码文件转为UTF-8 with BOM, vscode和notepad++都可以转换, 转换后就能成功识别并按照utf-8解析源文件.(Windows真是够无语的, 不带BOM的UTF-8不识别)\n最推荐的解决方案：\n确保所有源代码文件保存为 UTF-8 编码（无 BOM）。 在 CMakeLists.txt 中添加 add_compile_options(\u0026quot;/utf-8\u0026quot;)，告诉 MSVC 使用 UTF-8 编码。 如果你使用 Visual Studio，设置默认保存为 UTF-8。 tips：这个问题困扰我很多年了，一直没搞明白，所以简单记录下(或许也是我太菜了🙈)\n","date":"2025-04-10T19:39:24+08:00","permalink":"https://abin-z.github.io/p/msvc%E4%B8%8B%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/","title":"msvc下中文字符报错记录"},{"content":"这是我的第二个博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; // 自定义哈希函数 struct CaseInsensitiveHash { std::size_t operator()(const std::string \u0026amp;s) const { std::string lower_s = s; std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), [](unsigned char c) { return std::tolower(c); }); return std::hash\u0026lt;std::string\u0026gt;{}(lower_s); } }; // 自定义比较函数 struct CaseInsensitiveEqual { bool operator()(const std::string \u0026amp;lhs, const std::string \u0026amp;rhs) const { return lhs.size() == rhs.size() \u0026amp;\u0026amp; std::equal(lhs.begin(), lhs.end(), rhs.begin(), [](unsigned char a, unsigned char b) { return std::tolower(a) == std::tolower(b); }); } }; // field 类定义 class field { public: using comment_container = std::vector\u0026lt;std::string\u0026gt;; }; // 先声明 basic_inifile template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_inifile; // ini section（支持大小写不敏感键） template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_section { // 允许 basic_inifile 访问 private 成员 template \u0026lt;typename H, typename E\u0026gt; friend class basic_inifile; using DataContainer = std::unordered_map\u0026lt;std::string, field, Hash, Equal\u0026gt;; public: using comment_container = field::comment_container; using key_type = typename DataContainer::key_type; using mapped_type = typename DataContainer::mapped_type; using value_type = typename DataContainer::value_type; using size_type = typename DataContainer::size_type; using difference_type = typename DataContainer::difference_type; using iterator = typename DataContainer::iterator; using const_iterator = typename DataContainer::const_iterator; // 默认构造 basic_section() = default; // 默认析构函数 ~basic_section() = default; // 默认移动构造函数 basic_section(basic_section \u0026amp;\u0026amp;) noexcept = default; // 默认移动赋值函数 basic_section \u0026amp;operator=(basic_section \u0026amp;\u0026amp;) noexcept = default; private: DataContainer data_; // 存储键值对 }; // ini 文件类，存储多个 section template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_inifile { public: using section = basic_section\u0026lt;Hash, Equal\u0026gt;; // 在 basic_inifile 内部定义 section 别名 using SectionContainer = std::unordered_map\u0026lt;std::string, section, Hash, Equal\u0026gt;; using key_type = typename SectionContainer::key_type; using mapped_type = typename SectionContainer::mapped_type; using value_type = typename SectionContainer::value_type; using size_type = typename SectionContainer::size_type; using difference_type = typename SectionContainer::difference_type; using iterator = typename SectionContainer::iterator; using const_iterator = typename SectionContainer::const_iterator; // 默认构造 basic_inifile() = default; // 默认析构 ~basic_inifile() = default; // 默认移动构造 basic_inifile(basic_inifile \u0026amp;\u0026amp;) noexcept = default; // 默认移动赋值 basic_inifile \u0026amp;operator=(basic_inifile \u0026amp;\u0026amp;) noexcept = default; // 添加一个 section section \u0026amp;add_section(const std::string \u0026amp;name) { return sections_[name]; // 如果 name 存在，返回已有的 section，否则创建新 section } // 获取一个 section（可变版本） section *get_section(const std::string \u0026amp;name) { auto it = sections_.find(name); return it != sections_.end() ? \u0026amp;it-\u0026gt;second : nullptr; } // 获取一个 section（只读版本） const section *get_section(const std::string \u0026amp;name) const { auto it = sections_.find(name); return it != sections_.end() ? \u0026amp;it-\u0026gt;second : nullptr; } private: SectionContainer sections_; // 存储多个 section }; // 提供默认大小写不敏感的类型别名（类似 std::string） using section = basic_section\u0026lt;CaseInsensitiveHash, CaseInsensitiveEqual\u0026gt;; using inifile = basic_inifile\u0026lt;CaseInsensitiveHash, CaseInsensitiveEqual\u0026gt;; #include \u0026lt;iostream\u0026gt; int main() { inifile ini; // 默认使用大小写不敏感模式 ini.add_section(\u0026#34;General\u0026#34;); ini.add_section(\u0026#34;Database\u0026#34;); // 测试大小写不敏感 if (ini.get_section(\u0026#34;general\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;Section \u0026#39;General\u0026#39; exists (case insensitive)\u0026#34; \u0026lt;\u0026lt; std::endl; } if (ini.get_section(\u0026#34;DATABASE\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;Section \u0026#39;Database\u0026#39; exists (case insensitive)\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } ","date":"2025-04-02T21:38:50+08:00","permalink":"https://abin-z.github.io/p/secondblog/","title":"SecondBlog"},{"content":"你好, 世界 这是我的第一个博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;inifile/inifile.h\u0026gt; /// @brief Specialization of INIFILE_TYPE_CONVERTER for std::vector\u0026lt;T\u0026gt;. /// @tparam T The type of elements in the vector. template \u0026lt;typename T\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { /// @brief Encodes a vector into a delimited string. void encode(const std::vector\u0026lt;T\u0026gt; \u0026amp;vec, std::string \u0026amp;value) { constexpr char delimiter = \u0026#39;,\u0026#39;; // Delimiter used to separate elements in the string std::string encoded_item; for (const auto \u0026amp;v : vec) { INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt; conv; conv.encode(v, encoded_item); // Encode each element of the vector value += encoded_item + delimiter; // Append the encoded element and delimiter } if (value.back() == delimiter) value.pop_back(); // Remove the trailing delimiter } /// @brief Decodes a delimited string into a vector. void decode(const std::string \u0026amp;value, std::vector\u0026lt;T\u0026gt; \u0026amp;vec) { constexpr char delimiter = \u0026#39;,\u0026#39;; // Delimiter used to separate elements in the string std::vector\u0026lt;std::string\u0026gt; info = ini::split(value, delimiter); // Split the string T encoded_item; for (const auto \u0026amp;v : info) { INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt; conv; conv.decode(v, encoded_item); // Decode each part of the string vec.emplace_back(std::move(encoded_item)); // Add the decoded element to the vector } } }; /// @brief Print the contents of a vector to the console. template \u0026lt;typename T\u0026gt; void print_vector(const std::vector\u0026lt;T\u0026gt; \u0026amp;vec) { std::cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (size_t i = 0; i \u0026lt; vec.size(); ++i) { std::cout \u0026lt;\u0026lt; vec[i]; if (i != vec.size() - 1) { std::cout \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; } } std::cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { ini::inifile inif; // Create an INI file object // Define vectors of different types std::vector\u0026lt;int\u0026gt; vec1 = {1, 2, 3, 4, 5}; std::vector\u0026lt;double\u0026gt; vec2 = {1.1111, 2.2222, 3.3333, 4.4444, 5.5555}; std::vector\u0026lt;std::string\u0026gt; vec3 = {\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;, \u0026#34;eee\u0026#34;}; // Set different types of vectors in the INI file object inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = vec1; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = vec2; inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;] = vec3; // Get different vectors from INI file object std::vector\u0026lt;int\u0026gt; v1 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::vector\u0026lt;double\u0026gt; v2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; std::vector\u0026lt;std::string\u0026gt; v3 = inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;]; // Print the vectors to the console print_vector(v1); print_vector(v2); print_vector(v3); // Print the entire INI file content as a string std::cout \u0026lt;\u0026lt; \u0026#34;ini info:\\n\u0026#34; \u0026lt;\u0026lt; inif.to_string() \u0026lt;\u0026lt; std::endl; return 0; // Exit the program } 添加了自动部署功能\n测试部署功能\n","date":"2025-04-01T23:37:26+08:00","permalink":"https://abin-z.github.io/p/firstblog/","title":"Firstblog"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-03-11T00:00:00Z","image":"https://abin-z.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://abin-z.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://abin-z.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://abin-z.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://abin-z.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://abin-z.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://abin-z.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://abin-z.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://abin-z.github.io/p/emoji-support/","title":"Emoji Support"}]