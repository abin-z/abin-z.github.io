[{"content":"🌟 轻量级ini文件解析库 🌍 Languages/语言: English | 简体中文\n📌 项目简介 这是一个轻量级、跨平台、高效且 header-only 的 INI 配置解析库，专为 C++ 项目打造。它提供简洁、直观且优雅的 API，支持从文件、std::istream 或 std::string 解析、修改并写入 INI 配置信息，并具备行级注释保留功能，确保原始注释不丢失，使配置管理更加轻松高效。\n项目仓库地址: https://github.com/abin-z/IniFile\n🎯设计理念 INI 解析库数不胜数，每个库甚至都有自己存在的理由。我们的设计理念是:\n极致简洁，开箱即用：Header-only，零依赖，仅需 C++11，轻松集成任意项目。 专注体验，贴近实用：支持注释保留、自动类型转换、自定义解析，专注提升开发者日常使用体验。 跨平台、可维护、可信赖：兼容主流平台，结合单元测试与内存检查，保障长期稳定运行。 如果您正在寻找一个简单、实用、优雅、稳定的现代 C++ 解决方案，那么该库就是您的不二之选。如果你知道如何使用std::map，你就已经准备好了。\n🚀 特性 轻量级 \u0026amp; 无依赖：仅依赖 C++11 标准库，无需额外依赖项 易于集成：Header-only 设计，开箱即用，足够简单 直观 API：提供清晰友好的接口，简化 INI 配置操作 跨平台支持：支持Linux, Windows, MacOS等系统, 以及主流编译器 多种数据源：支持从文件，std::string 或 std::istream 解析 INI 数据，并写入其中 自动类型转换：支持多种数据类型，能自动处理类型转换(优雅的api接口) 支持注释功能: 支持ini行注释(;或者#), 可以为[section]和key=value添加行注释(不支持行尾注释) 自定义类型转换: 可以自定义类型转换, inifile将根据你写的定义进行自动转换(减少重复) 支持大小写不敏感功能: 提供可选的大小写不敏感功能(针对section和key) 全面测试与内存安全：已通过 Catch2 单元测试框架验证功能正确性，并使用 Valgrind 确保内存管理无泄漏 适用于对 INI 配置有 解析、编辑、存储 需求的 C++ 项目。以下是基础的ini格式:\n1 2 3 ; comment [section] key = value 注: 本库内部使用std::string类型封装filed值, 可以很好的和 UTF-8 编码兼容, 但其他编码具体情况可能会有所不同.\n📦 使用方式 方式1: Header-only\n直接将inifile.h头文件复制到您的项目文件夹中\n然后在源代码文件中直接#include \u0026quot;inifile.h\u0026quot;即可使用\n方式2: 使用CMake\n在项目中创建一个inifile文件夹(名称随意)\n将本项目的include文件夹中的所有内容复制到刚才步骤1创建的inifile文件夹内\n然后在您的主CMakeLists.txt中添加以下内容\n1 add_subdirectory(inifile) # inifile为步骤1创建的文件夹名称 在源代码中添加#include \u0026lt;inifile/inifile.h\u0026gt;即可使用\n🛠️ 基础使用案例 下面提供简单的使用案例, 更多详细的案例请查看./examples/文件夹下的案例\n创建并保存ini文件 1 2 3 4 5 6 7 8 9 10 11 #include \u0026#34;inifile.h\u0026#34; int main() { constexpr char path[] = \u0026#34;path/to/ini/file\u0026#34;; ini::inifile inif; inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;] = true; inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = 3.14159; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = \u0026#34;value\u0026#34;; // Save the ini file, returns whether the save was successful or not. bool isok = inif.save(path); } 读取ini文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;inifile.h\u0026#34; int main() { constexpr char path[] = \u0026#34;path/to/ini/file\u0026#34;; ini::inifile inif; // Load the ini file, return whether the loading was successful or not. bool isok = inif.load(path); bool b = inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;]; double d = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::string s = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; // Explicit type conversion via as function bool bb = inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;].as\u0026lt;bool\u0026gt;(); double dd = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;].as\u0026lt;double\u0026gt;(); std::string ss = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;].as\u0026lt;std::string\u0026gt;(); bool bbb; double ddd; std::string sss; inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;].as_to(bbb); // Explicit type conversion inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;].as_to(ddd); // Explicit type conversion inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;].as_to(sss); // Explicit type conversion } stream流中读/写ini信息 支持stream流, 允许从std::istream流中读取ini数据, 也能向std::ostream中写入ini数据.\n1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { // create istream object \u0026#34;is\u0026#34; ... ini::inifile inif; inif.read(is); } 1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { // create ostream object \u0026#34;os\u0026#34; ... ini::inifile inif; inif.write(os); } std::string中读写ini信息 支持从std::string中读取ini数据, 也能将inifile 转为std::string.\n1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { // create string object \u0026#34;s\u0026#34; ... ini::inifile inif; inif.from_string(s); } 1 2 3 4 5 6 7 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;] = \u0026#34;value\u0026#34;; std::string s = inif.to_string(); } 设置值 说明: 若section-key不存在, operator[]操作符和set函数会直接插入section-key, 若section-key存在则更新field值.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; /// Setting a single value inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = \u0026#34;value\u0026#34;; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;].set(\u0026#34;hello\u0026#34;); inif.set(\u0026#34;section\u0026#34;, \u0026#34;key3\u0026#34;, true); inif[\u0026#34;section\u0026#34;].set(\u0026#34;key4\u0026#34;, 3.14159); /// Setting multiple values for the same section, supporting different types inif[\u0026#34;section2\u0026#34;].set({{\u0026#34;bool\u0026#34;, false}, {\u0026#34;int\u0026#34;, 123}, {\u0026#34;double\u0026#34;, 999.888}, {\u0026#34;string\u0026#34;, \u0026#34;ABC\u0026#34;}, {\u0026#34;char\u0026#34;, \u0026#39;m\u0026#39;}}); } 获取值 说明: 获取值的时候需要注意以下两点:\n给定的section-key是否存在, 当section-key不存在时调用不同的函数会有不同的处理策略; 使用operator[]返回引用, 若给定section或key不存在则会插入空的field值, 并设置field为空字符串. (行为类似std::map的[]) 使用get()函数返回值, 若给定的section或key不存在不会插入field, 而是返回一个默认的空field值(可以指定默认值). 使用at()函数返回引用, 若给定的section或key不存在则抛出异常 : std::out_of_range 是否可以执行类型自动转换, 以上三个函数返回的是 ini::field 包装对象, 若将该对象转为其他类型需注意: 类型转换是否允许, 若类型转换不允许则抛出异常: std::invalid_argument, (例如将\u0026quot;abc\u0026quot;转为int) 数值类型转换范围是否溢出, 若超出目标类型的范围则抛出异常: std::out_of_range, (例如将INT_MAX转为uint8_t) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; try { /// automatic type conversion std::string s0 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; bool isok = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; int ii0 = inif.get(\u0026#34;section\u0026#34;, \u0026#34;key3\u0026#34;); int ii2 = inif.get(\u0026#34;section\u0026#34;, \u0026#34;key3\u0026#34;, -1); // Specify default values std::string ss2 = inif[\u0026#34;section\u0026#34;].get(\u0026#34;key4\u0026#34;); std::string ss3 = inif[\u0026#34;section\u0026#34;].get(\u0026#34;key5\u0026#34;, \u0026#34;default\u0026#34;); // Specify default values double dd0 = inif.at(\u0026#34;section\u0026#34;).at(\u0026#34;key\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;section-key:\u0026#34; \u0026lt;\u0026lt; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;].as\u0026lt;double\u0026gt;() \u0026lt;\u0026lt; std::endl; } catch (const std::exception \u0026amp;e) { std::cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } } 注释功能 本库支持设置[section]和key=value的行级注释(不支持行尾注释), 注释符号可选;和#两种; 也能从数据源中保留注释内容. 查看案例\n以下方法是功能完全等价的，选择哪一种主要取决于你的风格偏好：\n简写形式 完整形式 说明 f.set_comment(...) f.comment().set(...) 设置注释, 覆盖原有的注释（支持单行或多行） f.add_comment(...) f.comment().add(...) 追加注释（支持单行或多行） f.clear_comment() f.comment().clear() 清除所有注释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026#34;inifile.h\u0026#34; int main() { ini::inifile inif; // Set value inif[\u0026#34;section\u0026#34;][\u0026#34;key0\u0026#34;] = true; inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = 3.141592; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = \u0026#34;value\u0026#34;; // Set comments if necessary inif[\u0026#34;section\u0026#34;].set_comment(\u0026#34;This is a section comment.\u0026#34;); // set section comment, Overwrite Mode inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;].set_comment(\u0026#34;This is a key-value pairs comment\u0026#34;, \u0026#39;#\u0026#39;); // set key=value pairs comment // Clear section comment inif[\u0026#34;section\u0026#34;].clear_comment(); // Add section comment inif[\u0026#34;section\u0026#34;].add_comment(\u0026#34;section comment01\u0026#34;); // add section comment, Append Mode inif[\u0026#34;section\u0026#34;].add_comment(\u0026#34;section comment02\\nsection comment03\u0026#34;); // Multi-line comments are allowed, lines separated by `\\n` // Get the comment object reference ini::comment \u0026amp;cmt = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;].comment(); // get reference to comment // Read comment content const std::vector\u0026lt;std::string\u0026gt; \u0026amp;view = cmt.view(); // view (non-owning) bool isok = inif.save(\u0026#34;config.ini\u0026#34;); } config.ini的内容应该为:\n1 2 3 4 5 6 7 8 ; section comment01 ; section comment02 ; section comment03 [section] key0=true # This is a key-value pairs comment key1=3.141592 key2=value 大小写不敏感功能 本库支持section和key的大小写不敏感功能, 使用ini::case_insensitive_inifile即可, 查看案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;inifile.h\u0026#34; int main() { const char *str = R\u0026#34;( [Section] KEY=Value Flag=123 hello=world )\u0026#34;; ini::case_insensitive_inifile inif; // Create a case-insensitive INI file object inif.from_string(str); // Read INI data from string // Test case-insensitive section and key access std::cout \u0026lt;\u0026lt; \u0026#34;inif.contains(\\\u0026#34;Section\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.contains(\u0026#34;Section\u0026#34;) \u0026lt;\u0026lt; std::endl; // true std::cout \u0026lt;\u0026lt; \u0026#34;inif.contains(\\\u0026#34;SECTION\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.contains(\u0026#34;SECTION\u0026#34;) \u0026lt;\u0026lt; std::endl; // true std::cout \u0026lt;\u0026lt; \u0026#34;inif.contains(\\\u0026#34;SeCtIoN\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.contains(\u0026#34;SeCtIoN\u0026#34;) \u0026lt;\u0026lt; std::endl; // true std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;section\\\u0026#34;).contains(\\\u0026#34;key\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;section\u0026#34;).contains(\u0026#34;key\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;section\\\u0026#34;).contains(\\\u0026#34;Key\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;section\u0026#34;).contains(\u0026#34;Key\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;SECTION\\\u0026#34;).contains(\\\u0026#34;KEY\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;SECTION\u0026#34;).contains(\u0026#34;KEY\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;SECTION\\\u0026#34;).contains(\\\u0026#34;flag\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;SECTION\u0026#34;).contains(\u0026#34;flag\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;inif.at(\\\u0026#34;SECTION\\\u0026#34;).contains(\\\u0026#34;FLAG\\\u0026#34;) = \u0026#34; \u0026lt;\u0026lt; inif.at(\u0026#34;SECTION\u0026#34;).contains(\u0026#34;FLAG\u0026#34;) \u0026lt;\u0026lt; std::endl; return 0; } 关于自动类型转换 自动类型转换作用在ini::field对象上, 允许ini::field \u0026lt;=\u0026gt; other type互相转换; 但是需要注意: 若转换失败会抛出异常.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026#34;inifile.h\u0026#34; int main() { /// other type -\u0026gt; ini::field ini::field f(true); ini::field f1(10); ini::field f2 = 3.14; ini::field f3 = \u0026#39;c\u0026#39;; ini::field f4 = \u0026#34;abc\u0026#34;; /// ini::field -\u0026gt; other type bool b = f; int i = f1; double d = f2; char c = f3; std::string s = f4; ini::inifile inif; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;] = true; // bool -\u0026gt; ini::field /// Get direct type(ini::field) auto val = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; // val type is ini::field ini::field val2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; /// explicit type conversion bool bb = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;].as\u0026lt;bool\u0026gt;(); /// automatic type conversion bool bb2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; /// Type conversion failure throws an exception double n = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; // error: Converting true to double is not allowed. } 支持自动转换的类型包括:\nbool char, signed char, unsigned char short, unsigned short int, unsigned int long, unsigned long long long, unsigned long long float double long double std::string const char * std::string_view (C++17) 自定义类型转换 Q: 用户自定义类型可以像上面提到的基本数据类型一样自动转换吗?\nA: 也是可以的, 只需要按以下规则自定义类型转换就能让inifile自动处理用户自定义类型.\n你可以为用户自定义类型提供自动类型转换的特化模板类, 它能让inifile库根据你定义的规则进行自动转换, 使其可以将自定义类存储在ini字段中, 这样可以大幅减少代码的重复. 以下是自定义规则和模板:\n使用INIFILE_TYPE_CONVERTER宏特化自定义的类型(必须提供默认构造函数);\n定义static void encode函数, 作用是定义如何将自定义类型转为ini存储字符串(存储字符串不能包含换行符);\n定义static void decode函数, 作用是定义如何将ini存储字符串转为自定义类型;\n1 2 3 4 5 6 7 8 9 10 11 12 13 /// Specialized type conversion template template \u0026lt;\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;CustomClass\u0026gt; // User-defined type `CustomClass` { static void encode(const CustomClass \u0026amp;obj, std::string \u0026amp;value) // pass by reference { // Convert the CustomClass object `obj` to ini storage string `value` } static void decode(const std::string \u0026amp;value, CustomClass \u0026amp;obj) // must be static { // Convert the ini storage string `value` to a CustomClass object `obj` } } 为了方便编写 encode 和 decode 函数, 本库提供了 ini::join, ini::split() 和 ini::trim() 工具函数\n案例1: 下面是将一个用户自定义类Person对象转为ini字段案例. 查看案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /// @brief User-defined classes struct Person { Person() = default; // Must have a default constructor Person(int id, int age, const std::string \u0026amp;name) : id(id), age(age), name(name) {} int id = 0; int age = 0; std::string name; }; /// @brief Custom type conversion (Use INIFILE_TYPE_CONVERTER to specialize Person) template \u0026lt;\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;Person\u0026gt; { // \u0026#34;Encode\u0026#34; the Person object into a value string static void encode(const Person \u0026amp;obj, std::string \u0026amp;value) { const char delimiter = \u0026#39;,\u0026#39;; // Format: id,age,name; Note: Please do not include line breaks in the value string value = std::to_string(obj.id) + delimiter + std::to_string(obj.age) + delimiter + obj.name; } // \u0026#34;Decode\u0026#34; the value string into a Person object static void decode(const std::string \u0026amp;value, Person \u0026amp;obj) { const char delimiter = \u0026#39;,\u0026#39;; std::vector\u0026lt;std::string\u0026gt; info = ini::split(value, delimiter); // Exception handling can be added obj.id = std::stoi(info[0]); obj.age = std::stoi(info[1]); obj.name = info[2]; } }; int main() { ini::inifile inif; Person p = Person{123456, 18, \u0026#34;abin\u0026#34;}; inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;] = p; // set person object Person pp = inif[\u0026#34;section\u0026#34;][\u0026#34;key\u0026#34;]; // get person object } 案例2: 可以嵌套调用INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt;, 实现STL容器自动转换, 能实现以下直接对容器赋值或取值的效果, 具体实现请点击查看详情\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Define vectors of different types std::vector\u0026lt;int\u0026gt; vec1 = {1, 2, 3, 4, 5}; std::vector\u0026lt;double\u0026gt; vec2 = {1.1111, 2.2222, 3.3333, 4.4444, 5.5555}; std::vector\u0026lt;std::string\u0026gt; vec3 = {\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;, \u0026#34;eee\u0026#34;}; // Set different types of vectors in the INI file object inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = vec1; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = vec2; inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;] = vec3; // Get different vectors from INI file object std::vector\u0026lt;int\u0026gt; v1 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::vector\u0026lt;double\u0026gt; v2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; std::vector\u0026lt;std::string\u0026gt; v3 = inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;]; 其他工具函数 提供其他多种工具函数, 判断是否为空empty(), 查询总个数size(), 查询key的个数count(), 是否包含元素contains(), 查找元素find(), 移除元素remove() 和 erase(), 清除所有元素clear(), 迭代器访问:begin(), end(), cbegin(), cend(), 支持范围for循环. 具体详情请查看常用 API 说明.\n下面提供一个迭代器访问ini信息:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026#34;inifile.h\u0026#34; int main() { constexpr char path[] = \u0026#34;path/to/ini/file\u0026#34;; ini::inifile inif; bool isok = inif.load(path); for (const auto \u0026amp;sec_pair : inif) { const std::string \u0026amp;section_name = sec_pair.first; const ini::section \u0026amp;section = sec_pair.second; std::cout \u0026lt;\u0026lt; \u0026#34; section \u0026#39;\u0026#34; \u0026lt;\u0026lt; section_name \u0026lt;\u0026lt; \u0026#34;\u0026#39; has \u0026#34; \u0026lt;\u0026lt; section.size() \u0026lt;\u0026lt; \u0026#34; key-values.\u0026#34; \u0026lt;\u0026lt; std::endl; for (const auto \u0026amp;kv : section) { const std::string \u0026amp;key = kv.first; const auto \u0026amp;value = kv.second; std::cout \u0026lt;\u0026lt; \u0026#34; kv: \u0026#39;\u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34;\u0026#39; = \u0026#39;\u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34; \u0026lt;\u0026lt; std::endl; } } } 案例列表 案例说明 案例链接 inifile的基本使用案例 inifile_basic.cpp inifile大小写不敏感案例 inifile_case_insensitive.cpp inifile保存ini文件案例 inifile_save.cpp inifile加载ini文件案例 inifile_load.cpp inifile读取流中的ini配置 inifile_read.cpp inifile写入ini配置到流中 inifile_write inifile注释功能案例 inifile_comment.cpp inifile读写用户自定义类型 inifile_custom.cpp inifile读写用户自定义类型2 inifile_custom2.cpp ini工具函数的使用 inifile_utility.cpp 📄 常用API说明 class 类型说明 class名称 描述 ini::inifile 对应整个ini数据, 包含了所有的section ini::section 对应整个section内容, 里面包含了本section所有的key-value值 ini::case_insensitive_inifile 对section和key大小写不敏感, 其他功能和ini::inifile一致 ini::case_insensitive_section 对key大小写不敏感, 其他功能和ini::section一致 ini::field 对应ini文件中的 value 字段, 支持多种数据类型, 支持自动类型转换 ini::comment ini文件中注释类, 管理section和key-value的注释 ini::comment类API说明 点击展开 | 函数名 | 函数签名 | 功能描述 | | --------- | ------------------------------------------------------------ | ------------------ | | comment | `comment(const std::string \u0026str, char symbol = ';')` | 构造函数 | | comment | `comment(const std::vector \u0026vec, char symbol = ';')` | 构造函数 | | comment | `comment(std::initializer_list list, char symbol = ';')` | 构造函数 | | swap | `void swap(comment \u0026other) noexcept` | 交换函数 | | empty | `bool empty() const noexcept` | 是否为空 | | clear | `void clear() noexcept` | 清空注释 | | set | `void set(const std::string \u0026str, char symbol = ';')` | 设置注释(覆盖模式) | | add | `void add(const std::string \u0026str, char symbol = ';')` | 添加注释(追加模式) | | view | `const std::vector \u0026view() const` | 返回注释容器常引用 | | to_vector | `std::vector to_vector() const` | 返回注释容器的拷贝 | | 函数名 | 函数签名 | 功能描述 | | --------- | -------------------------------------------------------- | ------------------ | | comment | `comment(const std::string \u0026str, char symbol = ';')` | 构造函数 | | comment | `comment(const std::vector \u0026vec, char symbol = ';')` | 构造函数 | | comment | `comment(std::initializer_list list, char symbol = ';')` | 构造函数 | | swap | `void swap(comment \u0026other) noexcept` | 交换函数 | | empty | `bool empty() const noexcept` | 是否为空 | | clear | `void clear() noexcept` | 清空注释 | | set | `void set(const std::string \u0026str, char symbol = ';')` | 设置注释(覆盖模式) | | add | `void add(const std::string \u0026str, char symbol = ';')` | 添加注释(追加模式) | | view | `const std::vector \u0026view() const` | 返回注释容器常引用 | | to_vector | `std::vector to_vector() const` | 返回注释容器的拷贝 | ini::field类API说明 点击展开 以下函数类型转换失败或者值溢出将抛异常 函数名 函数签名 功能描述 field field(const T \u0026amp;other) 构造field对象, 将T类型转为field值 set field \u0026amp;set(const T \u0026amp;value) 设置field值, 将T类型转为field值 operator= field \u0026amp;operator=(const T \u0026amp;rhs) 设置field值, 将T类型转为field值 operator T operator T() const 将field类型转为T类型 as T as() const 将field类型转为T类型 as_to T \u0026amp;as_to(T \u0026amp;out) const 将field类型转为给定的T类型对象 swap void swap(field \u0026amp;other) noexcept 交换函数 set_comment void set_comment(const std::string \u0026amp;str, char symbol = ';') 设置key-value的注释, 覆盖模式 add_comment void add_comment(const std::string \u0026amp;str, char symbol = ';') 添加key-value的注释, 追加模式 clear_comment void clear_comment() 清除key-value的注释 comment ini::comment \u0026amp;comment() 获取key-value的注释内容(引用) ini::section类API说明 点击展开 函数名 函数签名 功能描述 operator[] field \u0026amp;operator[](std::string key) 返回ini::field引用, 不存在则插入空ini::field set field \u0026amp;set(std::string key, T \u0026amp;\u0026amp;value) 插入或更新指定key的field contains bool contains(std::string key) const 判断key是否存在 at field \u0026amp;at(std::string key) 返回指定key键的元素的字段值的引用。如果元素不存则抛 std::out_of_range异常 swap void swap(basic_section \u0026amp;other) noexcept 交换函数 get field get(std::string key, field default_value = field{}) const 获取key对应的值(副本), 若key不存在则返回default_value默认值 find iterator find(key_type key) 查找指定key值的迭代器, 不存在返回end迭代器 erase iterator erase(iterator pos) 删除指定迭代器的key-value键值对 remove bool remove(std::string key) 删除指定的key-value键值对, 若不存在则什么都不做 empty bool empty() const noexcept 判断key-value键值对是否为空, 为空返回true clear void clear() noexcept 清除所有key - value键值对 keys std::vector\u0026lt;key_type\u0026gt; keys() const 获取所有的keys values std::vector\u0026lt;ini::filed\u0026gt; values() const 获取所有的values, 类型为ini::filed items std::vector\u0026lt;value_type\u0026gt; items() const 获取所有的key-value键值对 size size_type size() const noexcept 返回有多少key - value键值对 count size_type count(const key_type \u0026amp;key) const 返回有多少指定key的key - value键值对 begin iterator begin() noexcept 返回起始迭代器 end iterator end() noexcept 返回末尾迭代器 set_comment void set_comment(const std::string \u0026amp;str, char symbol = ';') 设置section的注释, 覆盖模式, 注释字符串允许换行\\n add_comment void add_comment(const std::string \u0026amp;str, char symbol = ';') 添加section的注释, 追加模式, 注释字符串允许换行\\n clear_comment void clear_comment() 清除section的注释 comment ini::comment \u0026amp;comment() 获取section的注释内容(引用) ini::inifile类API说明 点击展开 函数名 函数签名 功能描述 operator[] section \u0026amp;operator[](std::string sec) 返回ini::section引用, 不存在则插入空ini::section set field \u0026amp;set(std::string sec, std::string key, T \u0026amp;\u0026amp;value) 设置section key-value contains bool contains(std::string section) const 判断指定的section是否存在 contains bool contains(std::string section, std::string key) const 判断指定section下指定的key是否存在 at section \u0026amp;at(std::string section) 返回指定section的引用。如果不存在这样的元素，则会抛出 std::out_of_range 类型的异常 swap void swap(inifile \u0026amp;other) noexcept 交换函数 get field get(std::string sec, std::string key, field default_value = field{}) const 返回指定section的指定key键的字段值, 若section或key不存在则返回默认值default_value find iterator find(key_type key) 查找指定section的迭代器, 不存在返回end迭代器 erase iterator erase(iterator pos) 删除指定迭代器的section(包括其所有元素) remove bool remove(std::string sec) 删除指定的section(包括其所有元素) empty bool empty() const noexcept 判断是否没有section, 没有section空返回true clear void clear() noexcept 清空所有的section size size_type size() const noexcept 返回有多少section sections std::vector\u0026lt;key_type\u0026gt; sections() const 获取ini文件的所有section count size_type count(key_type key) const 返回有多少指定section-name的section begin iterator begin() noexcept 返回起始迭代器 end iterator end() noexcept 返回末尾迭代器 read void read(std::istream \u0026amp;is) 从istream中读取ini信息 write void write(std::ostream \u0026amp;os) const 向ostream中写入ini信息 from_string void from_string(const std::string \u0026amp;str) 从string中读取ini信息 to_string std::string to_string() const 将inifile对象转为对应字符串 load bool load(const std::string \u0026amp;filename) 从ini文件中加载ini信息, 返回是否成功 save bool save(const std::string \u0026amp;filename) 将ini信息保存到ini文件, 返回是否成功 ","date":"2025-05-04T22:05:03+08:00","permalink":"https://abin-z.github.io/p/%E8%BD%BB%E9%87%8F%E7%BA%A7ini%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%BA%93inifile/","title":"轻量级INI配置解析库(IniFile)"},{"content":"一个跨平台, 简单易用的Header-only线程池库, 基于Task提交, 支持提交任意参数提交, 支持获取返回值.\nGitHub仓库地址\n📌 线程池简介 线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程编程中。\n它的核心思想是：预先创建一定数量的线程放在“池子”里，任务来了就把任务交给空闲的线程来处理，而不是每次都新建线程。\n🚀特性亮点 任务提交灵活：支持任意可调用对象与参数组合，返回 std::future\u0026lt;T\u0026gt; 获取执行结果 线程安全：使用 std::mutex / std::condition_variable / std::atomic 构建同步机制 跨平台：纯 C++11 实现，兼容 Windows 与 POSIX 等系统 Header-only：仅需包含 thread_pool.h，零依赖，即可使用 RAII 自动管理资源：析构时自动关闭线程池，防止资源泄露 任务等待机制：支持主动调用 wait_all() 等待所有任务完成 灵活关闭策略：默认是自动关闭线程池的, 如果有需要可以手动关闭线程池: WaitForAllTasks: 等待所有任务完成后关闭 DiscardPendingTasks: 丢弃未开始的任务立即关闭 📦 快速开始 安装使用 拷贝thread_pool.h到你的项目目录，然后在代码中引入：\n1 #include \u0026#34;thread_pool.h\u0026#34; 无需额外依赖，完全头文件实现。\n基础示例代码 基础使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;thread_pool.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { abin::threadpool pool(4); auto future1 = pool.submit([] { return 42; }); std::cout \u0026lt;\u0026lt; \u0026#34;结果: \u0026#34; \u0026lt;\u0026lt; future1.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; auto future2 = pool.submit([](int a, int b) { return a + b; }, 5, 7); std::cout \u0026lt;\u0026lt; \u0026#34;加法结果: \u0026#34; \u0026lt;\u0026lt; future2.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 提交任意类型任意参数的可调用对象\n点击查看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026#34;thread_pool.h\u0026#34; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; void normal_function(int x) { std::cout \u0026lt;\u0026lt; \u0026#34;normal_function: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } struct MyClass { void member_function(int y) { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass::member_function: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; } int add(int a, int b) { return a + b; } }; struct Functor { void operator()(const std::string\u0026amp; msg) const { std::cout \u0026lt;\u0026lt; \u0026#34;Functor called with: \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; int main() { abin::threadpool pool(4); // 提交一个普通函数 pool.submit(normal_function, 42); // 提交一个无捕获 lambda pool.submit([] { std::cout \u0026lt;\u0026lt; \u0026#34;lambda no capture\\n\u0026#34;; }); // 提交一个有捕获 lambda int value = 99; pool.submit([value] { std::cout \u0026lt;\u0026lt; \u0026#34;lambda with capture: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }); // 提交成员函数, 使用lambda MyClass obj; pool.submit([\u0026amp;obj] { obj.member_function(123); }); // 提交成员函数, 使用 std::mem_fn std::future\u0026lt;int\u0026gt; ret = pool.submit(std::mem_fn(\u0026amp;MyClass::add), \u0026amp;obj, 3, 4); std::cout \u0026lt;\u0026lt; \u0026#34;add result1: \u0026#34; \u0026lt;\u0026lt; ret.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 提交成员函数, 使用 std::bind std::future\u0026lt;int\u0026gt; fut_add = pool.submit(std::bind(\u0026amp;MyClass::add, \u0026amp;obj, 2, 3)); std::cout \u0026lt;\u0026lt; \u0026#34;add result2: \u0026#34; \u0026lt;\u0026lt; fut_add.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 提交一个函数对象(仿函数) Functor f; pool.submit(f, \u0026#34;hello functor\u0026#34;); // 使用 std::bind 提交 auto bound = std::bind(\u0026amp;MyClass::add, \u0026amp;obj, 5, 6); std::future\u0026lt;int\u0026gt; fut_bound = pool.submit(bound); std::cout \u0026lt;\u0026lt; \u0026#34;bound result: \u0026#34; \u0026lt;\u0026lt; fut_bound.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 提交一个 std::packaged_task(注意: 低版本msvc可能报错) std::packaged_task\u0026lt;std::string()\u0026gt; task([] { return std::string(\u0026#34;from packaged_task\u0026#34;); }); std::future\u0026lt;std::string\u0026gt; fut_str = task.get_future(); pool.submit(std::move(task)); // 必须 move std::cout \u0026lt;\u0026lt; \u0026#34;packaged_task result: \u0026#34; \u0026lt;\u0026lt; fut_str.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; pool.wait_all(); // 等待任务完成 std::cout \u0026lt;\u0026lt; \u0026#34;===All tasks completed.===\\n\u0026#34;; } ThreadPool源码 点击查看线程池源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 /************************************************************************************************************** *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * @file: thread_pool.h * @version: v0.9.2 * @description: A cross-platform, lightweight, easy-to-use C++11 thread pool that supports submitting tasks with * arbitrary parameters and obtaining return values * - Futures * - Task-based: Supports tasks with arbitrary parameters, and obtains return values ​​through `std::future`. * - Cross-Platform: Works on platforms supporting C++11. * - Thread Safety: Uses `std::mutex`, `std::condition_variable`, and atomic variables for synchronization. * - Flexible Shutdown: Two modes for shutdown: `WaitForAllTasks` and `DiscardPendingTasks`. * - Lightweight \u0026amp; Easy-to-Use: Simple API with minimal setup. * * @author: abin * @date: 2025-04-20 * @license: MIT * @repository: https://github.com/abin-z/ThreadPool *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ **************************************************************************************************************/ #ifndef ABIN_THREADPOOL_H #define ABIN_THREADPOOL_H #include \u0026lt;atomic\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; namespace abin { /// @brief C++11的线程池, 提交任务支持任意多参数, 支持获取返回值 class threadpool { using task_t = std::function\u0026lt;void()\u0026gt;; // 定义任务类型为可调用对象 public: /// @brief 线程池当前状态信息结构体 struct status_info { std::size_t total_threads; // 总线程数 std::size_t busy_threads; // 正在执行任务的线程数 std::size_t idle_threads; // 空闲线程数 std::size_t pending_tasks; // 等待中的任务数 bool running; // 线程池是否在运行 }; /// @brief 关闭线程池的模式 enum class shutdown_mode : unsigned char { /// @brief 等待所有已提交的任务完成后再关闭线程池 /// 在此模式下, 线程池会等待所有任务(包括已开始和未开始的任务)执行完成后再关闭. WaitForAllTasks, /// @brief 立即关闭线程池, 丢弃尚未开始的任务. /// 在此模式下, 线程池会立即停止接收新任务, 丢弃所有尚未开始执行的任务, /// 但已经开始执行的任务会继续执行, 直到它们完成. DiscardPendingTasks }; public: /// @brief 构造函数, 初始化线程池并启动指定数量的工作线程 /// @param thread_count 要创建的线程数量, 默认为硬件支持的并发线程数(若无法获取则为 4) explicit threadpool(std::size_t thread_count = default_thread_count()) { launch_threads(validate_thread_count(thread_count)); // 创建线程 } /// @brief 析构函数, 停止所有线程并等待它们完成 ~threadpool() { shutdown(shutdown_mode::WaitForAllTasks); } /// @brief 提交任务到线程池并返回一个 future 对象, 用户可以通过它获取任务的返回值 /// /// @tparam F 任务类型的可调用对象 /// @tparam Args 可调用对象的参数类型 /// @param f 需要提交的任务 /// @param args 任务的参数 /// @return std::future\u0026lt;decltype(f(args...))\u0026gt; 返回一个 future 对象, 允许用户获取任务的返回值 template \u0026lt;typename F, typename... Args\u0026gt; auto submit(F \u0026amp;\u0026amp;f, Args \u0026amp;\u0026amp;...args) -\u0026gt; std::future\u0026lt;decltype(f(args...))\u0026gt; { if (!running_) throw std::runtime_error(\u0026#34;error: ThreadPool is not running. Cannot submit new tasks.\u0026#34;); using return_type = decltype(f(args...)); // 将 f 包装成 task, task 是一个 shared_ptr 指向 packaged_task auto task = std::make_shared\u0026lt;std::packaged_task\u0026lt;return_type()\u0026gt;\u0026gt;( std::bind(std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Args\u0026gt;(args)...) // 将函数和参数封装成一个 return_type() 的可调用对象 ); std::future\u0026lt;return_type\u0026gt; ret = task-\u0026gt;get_future(); // 获取与 task 相关联的 future { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); task_queue_.emplace([task] { (*task)(); }); // 将任务添加到任务队列中 } cv_.notify_one(); // 通知一个等待中的工作线程有新的任务可以执行 return ret; // 返回 future 对象 } /// @brief 阻塞直到所有任务完成(任务队列为空且没有任务在执行), 若没有任务，立即返回 void wait_all() { if (busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0) return; std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx_done_); cv_done_.wait(lock, [this] { return busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0; }); } /// @brief 关闭线程池 /// @param mode `WaitForAllTasks` 等待所有任务执行完成后再关闭; `DiscardPendingTasks` 立即关闭线程池, /// 抛弃尚未开始的任务. void shutdown(shutdown_mode mode = shutdown_mode::WaitForAllTasks) { { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); if (!running_) return; // 已经关闭则直接返回 running_ = false; if (mode == shutdown_mode::DiscardPendingTasks) // 放弃任务模式 { std::queue\u0026lt;task_t\u0026gt; empty; std::swap(task_queue_, empty); // 清空任务队列 } } cv_.notify_all(); for (std::thread \u0026amp;worker : workers_) { if (worker.joinable()) worker.join(); } workers_.clear(); } /// @brief 重启线程池, 先关闭当前线程池(等待所有任务完成), 然后以指定的线程数量重新启动线程池. /// @param thread_count 要创建的工作线程数量 void reboot(std::size_t thread_count) { shutdown(shutdown_mode::WaitForAllTasks); { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); if (running_) return; // 已重启, 无需再次初始化(幂等) running_ = true; launch_threads(validate_thread_count(thread_count)); } } /// @brief 当前线程池的总线程数量 std::size_t total_threads() const noexcept { return workers_.size(); } /// @brief 获取当前等待的任务数量 std::size_t pending_tasks() const noexcept { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); return task_queue_.size(); } /// @brief 获取繁忙的线程数量 std::size_t busy_threads() const noexcept { return busy_count_.load(); } /// @brief 获取空闲线程数量 std::size_t idle_threads() const noexcept { return workers_.size() - busy_count_.load(); } /// @brief 当前线程池是否正在运行(未停止) bool is_running() const noexcept { return running_.load(); } /// @brief 获取线程池的当前状态信息 status_info status() const noexcept { std::size_t total = 0; std::size_t pending = 0; { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_); total = workers_.size(); pending = task_queue_.size(); } std::size_t busy = busy_count_.load(); std::size_t idle = total - busy; return {total, busy, idle, pending, running_.load()}; } // 禁用拷贝构造函数和拷贝赋值操作符 threadpool(const threadpool \u0026amp;) = delete; threadpool \u0026amp;operator=(const threadpool \u0026amp;) = delete; // 禁用移动构造函数和移动赋值操作符 threadpool(threadpool \u0026amp;\u0026amp;) = delete; threadpool \u0026amp;operator=(threadpool \u0026amp;\u0026amp;) = delete; private: /// @brief 默认线程数, 获取硬件支持的并发线程数, 若无法获取则默认为4 static std::size_t default_thread_count() { auto n = std::thread::hardware_concurrency(); return n == 0 ? 4 : n; } /// @brief 验证线程数是否合法, 1 \u0026lt;= count \u0026lt;= 4096 static std::size_t validate_thread_count(std::size_t count) { if (count \u0026lt; 1 || count \u0026gt; 4096) throw std::invalid_argument(\u0026#34;invalid thread_count: must be in range [1, 1024]\u0026#34;); return count; } /// @brief 启动线程池, 创建指定数量的工作线程 /// @param thread_count 线程池中线程的数量 void launch_threads(std::size_t thread_count) { if (!workers_.empty()) return; // 已经初始化过 for (std::size_t i = 0; i \u0026lt; thread_count; ++i) { // 创建并启动工作线程 workers_.emplace_back([this] { while (true) { task_t task; { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx_); // 等待直到任务队列中有任务, 或者线程池已停止 cv_.wait(lock, [this] { return !running_ || !task_queue_.empty(); }); if (!running_ \u0026amp;\u0026amp; task_queue_.empty()) return; // 如果线程池已经停止并且队列为空, 退出线程 task = std::move(task_queue_.front()); // 从队列中取出任务 task_queue_.pop(); } ++busy_count_; task(); // 执行任务 --busy_count_; // 判断任务是否已全部完成 if (busy_count_ == 0 \u0026amp;\u0026amp; task_queue_.empty()) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx_done_); if (busy_count_ == 0 \u0026amp;\u0026amp; pending_tasks() == 0) // 二次确认, 避免竞态 { cv_done_.notify_all(); } } } }); } } private: std::vector\u0026lt;std::thread\u0026gt; workers_; // 工作线程集合，用于并发执行任务 std::queue\u0026lt;task_t\u0026gt; task_queue_; // 等待执行的任务队列 std::condition_variable cv_; // 条件变量，用于通知工作线程有新任务到来 mutable std::mutex mtx_; // 主互斥锁，保护任务队列和与其相关的状态 std::atomic\u0026lt;std::size_t\u0026gt; busy_count_{0}; // 正在执行任务的线程数量 std::atomic\u0026lt;bool\u0026gt; running_{true}; // 线程池是否处于运行状态 mutable std::mutex mtx_done_; // 用于保护完成通知的互斥锁(wait_all 用) std::condition_variable cv_done_; // 条件变量，用于等待所有任务执行完毕(配合 wait_all 使用) }; } // namespace abin #endif // ABIN_THREADPOOL_H ","date":"2025-04-26T17:29:58+08:00","permalink":"https://abin-z.github.io/p/threadpool/","title":"C++跨平台轻量级线程池(ThreadPool)"},{"content":"SimpleTimer 是一个跨平台的轻量级定时器类，支持在后台线程中定期执行任务，适用于需要定时执行任务的场景。它支持暂停、恢复、修改时间间隔等功能，且不依赖任何第三方库，仅使用 C++11 标准库实现。\n特性 跨平台支持：在多个平台上（如 Windows、Linux、macOS）均可运行，基于 C++11 标准库实现。 线程安全：内部使用 std::thread 和 std::condition_variable，保证线程安全。 灵活的时间间隔：支持使用 std::chrono::duration 设置任意时间单位（分钟、秒、毫秒等）。 支持多种执行模式：包括单次执行（one-shot）和重复执行（周期性）。 控制功能完善：支持暂停、恢复、重启定时器，支持动态修改时间间隔。 时间精度良好：定时器精度取决于系统时钟，通常为毫秒级别。 自动资源管理：SimpleTimer 对象析构时会自动停止定时器，即使忘记调用 stop 也能确保资源正确释放。 使用方式 将 simple_timer.h 文件复制到你的项目目录中，在源码中引入即可使用:\n1 #include \u0026#34;simple_timer.h\u0026#34; 在 POSIX 系统（如 Linux、macOS）中，std::thread 基于 pthread 实现，因此需要在编译时加上 -lpthread 链接选项。\n示例代码 以下是一个完整的示例代码，展示了如何使用 SimpleTimer 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026#34;simple_timer.h\u0026#34; #include \u0026lt;iostream\u0026gt; int main() { SimpleTimer timer(std::chrono::seconds(1)); // 定时器间隔为1秒，重复执行任务 timer.start([]() { std::cout \u0026lt;\u0026lt; \u0026#34;定时器任务执行！\u0026#34; \u0026lt;\u0026lt; std::endl; }); std::this_thread::sleep_for(std::chrono::seconds(5)); // 等待5秒 timer.pause(); // 暂停定时器 std::cout \u0026lt;\u0026lt; \u0026#34;定时器已暂停...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(3)); // 等待3秒 timer.resume(); // 恢复定时器 std::cout \u0026lt;\u0026lt; \u0026#34;定时器已恢复...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(5)); // 等待5秒 timer.stop(); // 停止定时器 std::cout \u0026lt;\u0026lt; \u0026#34;定时器已停止\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 代码实现: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 /** * @author: abin * @date: 2025-04-12 * @license: MIT * @repository: https://github.com/abin-z/SimpleTimer */ #ifndef SIMPLE_TIMER_H #define SIMPLE_TIMER_H #include \u0026lt;atomic\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; /** * @brief 使用 std::condition_variable 的 wait_until 方法 (也可以使用wait_for方法, 但是会累计误差) * 函数原型: * cv.wait_until(lock, time_point, predicate); * * wait_until 的行为: * - wait_until 方法的作用是让当前线程在指定的时间点之前等待, 直到条件变量被通知或者超时 * - 进入等待前会先检查 predicate() 的值. * - 如果 predicate() 在进入等待前立即为 true, 则直接返回 true, 不会进入等待状态 * - 如果 predicate() 为 false, 则进入等待状态, 直到 time_point 到达 * - 如果在 time_point 到达前 `notify_*` 被调用, 并且此时 predicate() 为 true, 则唤醒并返回 true * - 如果在 time_point 到达前 `notify_*` 被调用, 但此时 predicate() 为 false, 则继续等待(可能是虚假唤醒) * - 如果直到 time_point 到达时 predicate() 仍为 false, 返回 false(表示超时) * * 简要来说: * - `wait_until` 返回 true 表示条件变量被唤醒并且条件成立 * - `wait_until` 返回 false 表示已超时, 且条件仍未满足(即超时触发任务) */ /// @brief A simple timer class class SimpleTimer { using clock = std::chrono::steady_clock; // 单调时钟, 不受系统时间变化影响 public: /// @brief Timer state enum class State : unsigned char { Stopped = 0, // 停止 Running = 1, // 运行中 Paused = 2, // 暂停 }; /// @brief Constructs a SimpleTimer with a given duration /// @tparam Rep Duration representation type (e.g., int, long) /// @tparam Period Duration unit type (e.g., seconds, milliseconds) /// @param interval The time interval /// @param one_shot If true, the timer will only trigger once template \u0026lt;typename Rep, typename Period\u0026gt; SimpleTimer(std::chrono::duration\u0026lt;Rep, Period\u0026gt; interval, bool one_shot = false) : interval_(interval), one_shot_(one_shot), state_(State::Stopped) { } /// @brief Constructs a SimpleTimer with a millisecond interval /// @param milliseconds The time interval in milliseconds /// @param one_shot If true, the timer will only trigger once explicit SimpleTimer(long long milliseconds, bool one_shot = false) : SimpleTimer(std::chrono::milliseconds(milliseconds), one_shot) // 代理到主构造函数 { } /// @brief Constructs a SimpleTimer with a default interval of 10 seconds /// @param one_shot If true, the timer will only trigger once SimpleTimer(bool one_shot = false) : SimpleTimer(std::chrono::seconds(10), one_shot) // 默认间隔为10秒 { } /// @brief Destructor. Automatically stops the timer to clean up resources. ~SimpleTimer() { stop(); } // Delete copy constructor and copy assignment operator SimpleTimer(const SimpleTimer\u0026amp;) = delete; SimpleTimer\u0026amp; operator=(const SimpleTimer\u0026amp;) = delete; // Delete move constructor and move assignment operator SimpleTimer(SimpleTimer\u0026amp;\u0026amp;) = delete; SimpleTimer\u0026amp; operator=(SimpleTimer\u0026amp;\u0026amp;) = delete; /// @brief Starts the timer /// @tparam Func Callable object type /// @param f A callable object to be executed when the timer expires /// @note The timer task will be executed in a new thread template \u0026lt;typename Func\u0026gt; void start(Func\u0026amp;\u0026amp; f) { stop(); // 确保没有其他线程在运行(替换旧任务) state_ = State::Running; // 设置状态为运行中 auto task = std::move(std::forward\u0026lt;Func\u0026gt;(f)); // 完美转发后再 move, 提高效率 // 使用 std::thread 创建一个新的线程来执行定时器任务 thread_ = std::thread([this, task]() mutable { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mutex_); auto next_time = clock::now() + interval_; while (true) { if (state_ == State::Stopped) { break; } while (state_ == State::Paused) { cv_.wait(lock, [this]() { return state_ != State::Paused; }); next_time = clock::now() + interval_; // 重新计算下一次触发时间 } if (cv_.wait_until(lock, next_time, [this]() { return state_ != State::Running || interval_changed_; })) { if (interval_changed_) // interval_修改后立即使用新间隔 { next_time = clock::now() + interval_; interval_changed_ = false; } continue; // 若状态不是 Running, 继续循环判断; 若是 interval_ 被修改, 则更新 next_time 并立即跳过等待 } lock.unlock(); // Timer 内部处理异常, 执行task遇到异常后直接停止timer try { task(); // 执行任务 } catch (const std::exception\u0026amp; e) { state_ = State::Stopped; // 出现异常时停止定时器 (不能调用stop()会死锁) std::fprintf(stderr, \u0026#34;[SimpleTimer] Exception: %s\\n\u0026#34;, e.what()); } catch (...) { state_ = State::Stopped; // 出现异常时停止定时器 std::fprintf(stderr, \u0026#34;[SimpleTimer] Unknown exception occurred.\\n\u0026#34;); } lock.lock(); if (one_shot_) { state_ = State::Stopped; break; } next_time += interval_; // 精确推进时间点, 避免偏差 } }); } /// @brief Restarts the timer /// @tparam Func Callable object type /// @param f A callable object to be executed when the timer expires template \u0026lt;typename Func\u0026gt; void restart(Func\u0026amp;\u0026amp; f) { stop(); start(std::forward\u0026lt;Func\u0026gt;(f)); } /// @brief Stops the timer; waits for the current task to complete before fully stopping /// @note This method may block until the running task completes. void stop() { state_ = State::Stopped; cv_.notify_all(); // 唤醒等待的线程 if (thread_.joinable()) { thread_.join(); // 等待线程结束 } } /// @brief Pauses the timer void pause() { if (state_ == State::Running) { state_ = State::Paused; } } /// @brief Resumes the timer if it was paused void resume() { if (state_ == State::Paused) { state_ = State::Running; cv_.notify_all(); // 唤醒正在等待的线程 } } /// @brief Gets the current timer interval /// @return The interval in milliseconds std::chrono::milliseconds interval() const { return std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(interval_); } /// @brief Sets a new timer interval, takes effect immediately /// @param new_interval A duration representing the new interval template \u0026lt;typename Rep, typename Period\u0026gt; void set_interval(std::chrono::duration\u0026lt;Rep, Period\u0026gt; new_interval) { { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex_); interval_ = new_interval; interval_changed_ = true; // 标记为已改变 } cv_.notify_all(); // 确保线程能获取到新的时间间隔 } /// @brief Sets a new timer interval, takes effect immediately /// @param milliseconds New interval in milliseconds void set_interval(long long milliseconds) { set_interval(std::chrono::milliseconds(milliseconds)); } /// @brief Gets the current state of the timer /// @return The state of the timer State state() const { return state_; } /// @brief Checks if the timer is currently running /// @return true if running, false otherwise bool is_running() const { return state_ == State::Running; } /// @brief Checks if the timer is currently paused /// @return true if paused, false otherwise bool is_paused() const { return state_ == State::Paused; } /// @brief Checks if the timer is currently stopped /// @return true if stopped, false otherwise bool is_stopped() const { return state_ == State::Stopped; } private: // 定时器间隔, 默认10秒 clock::duration interval_ = std::chrono::seconds(10); bool interval_changed_ = false; // 时间间隔是否被修改过 bool one_shot_ = false; // 是否只触发一次 std::atomic\u0026lt;State\u0026gt; state_; // 定时器状态 std::thread thread_; // 定时器线程 std::mutex mutex_; // 互斥锁, 确保线程安全 std::condition_variable cv_; // 条件变量, 用于暂停和恢复 }; #endif // SIMPLE_TIMER_H ","date":"2025-04-13T01:20:56+08:00","permalink":"https://abin-z.github.io/p/simpletimer/","title":"基于C++11的简单定时器(SimpleTimer)"},{"content":"中文字符串在msvc编译器下出现异常报错 我在写中文单元测试用例,有以下cpp代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TEST_CASE(\u0026#34;case insensitive test08\u0026#34;, \u0026#34;[inifile][case_insensitive]\u0026#34;) { ini::case_insensitive_inifile inif; // 添加一些中文的测试 inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;] = \u0026#34;中文值\u0026#34;; // 测试中文的大小写不敏感性（实际上中文没有大小写，但测试是否受影响） CHECK(inif.contains(\u0026#34;中文节\u0026#34;) == true); CHECK(inif.contains(\u0026#34;中文节\u0026#34;, \u0026#34;中文键\u0026#34;) == true); CHECK(inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;].as\u0026lt;std::string\u0026gt;() == \u0026#34;中文值\u0026#34;); // 修改中文值 inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;] = \u0026#34;新的中文值\u0026#34;; CHECK(inif[\u0026#34;中文节\u0026#34;][\u0026#34;中文键\u0026#34;].as\u0026lt;std::string\u0026gt;() == \u0026#34;新的中文值\u0026#34;); // 测试不存在的中文键 CHECK(inif.contains(\u0026#34;中文节\u0026#34;, \u0026#34;不存在的键\u0026#34;) == false); // 测试中文默认值 CHECK(inif.get(\u0026#34;中文节\u0026#34;, \u0026#34;不存在的键\u0026#34;, \u0026#34;默认值\u0026#34;).as\u0026lt;std::string\u0026gt;() == \u0026#34;默认值\u0026#34;); } 遇到的问题: 这段代码本身其实没啥问题, 在linux下使用gcc和clang都可以通过编译, 但是在msvc编译器下就有以下的编译错误:\n问题原因: 问题的根本原因是 Windows 下的 MSVC 默认使用本地系统代码页（例如 GBK/936）读取源代码文件，而不是 UTF-8，而你写的源代码中含有中文字符（UTF-8 编码）。MSVC 在不知情的情况下用本地代码页解释 UTF-8 内容，就会：\n错误地将 UTF-8 字节当作 GBK 解析，导致中文乱码 某些 UTF-8 字节组合不合法，会被当成非法字符或换行符处理 这些非法字符一旦出现在字符串、宏、甚至标识符中，就会引发各种报错 为什么 Linux 和 GCC/Clang 没问题？\nGCC 和 Clang 默认就是按 UTF-8 读取源代码文件，尤其是在 UTF-8 环境下（比如大多数 Linux 系统）。所以它们不会把 UTF-8 中的合法字符误解为非法字符或乱码，自然不会出错。\n解决方案 核心点: 只需要让msvc能按正确的encoding读取源文件即可.\n方式1: 明确告诉msvc，使用 UTF-8 读取编译源文件, 使用编译参数/utf-8, 比如在cmake中可以添加一下内容:\n1 2 3 4 # 如果是 MSVC 编译器，设置源文件为 UTF-8 编码 if (MSVC) add_compile_options(\u0026#34;/utf-8\u0026#34;) endif() 这行代码会为 MSVC 编译器添加 /utf-8 选项，指示 MSVC 使用 UTF-8 编码来读取和处理源文件中的字符。\n方式2: 将源码文件转为UTF-8 with BOM, vscode和notepad++都可以转换, 转换后就能成功识别并按照utf-8解析源文件.(Windows真是够无语的, 不带BOM的UTF-8不识别)\n最推荐的解决方案：\n确保所有源代码文件保存为 UTF-8 编码（无 BOM）。 在 CMakeLists.txt 中添加 add_compile_options(\u0026quot;/utf-8\u0026quot;)，告诉 MSVC 使用 UTF-8 编码。 如果你使用 Visual Studio，设置默认保存为 UTF-8。 tips：这个问题困扰我很多年了，一直没搞明白，所以简单记录下(或许也是我太菜了🙈)\n","date":"2025-04-10T19:39:24+08:00","permalink":"https://abin-z.github.io/p/msvc%E4%B8%8B%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/","title":"msvc下中文字符报错记录"},{"content":"这是我的第二个博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; // 自定义哈希函数 struct CaseInsensitiveHash { std::size_t operator()(const std::string \u0026amp;s) const { std::string lower_s = s; std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), [](unsigned char c) { return std::tolower(c); }); return std::hash\u0026lt;std::string\u0026gt;{}(lower_s); } }; // 自定义比较函数 struct CaseInsensitiveEqual { bool operator()(const std::string \u0026amp;lhs, const std::string \u0026amp;rhs) const { return lhs.size() == rhs.size() \u0026amp;\u0026amp; std::equal(lhs.begin(), lhs.end(), rhs.begin(), [](unsigned char a, unsigned char b) { return std::tolower(a) == std::tolower(b); }); } }; // field 类定义 class field { public: using comment_container = std::vector\u0026lt;std::string\u0026gt;; }; // 先声明 basic_inifile template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_inifile; // ini section（支持大小写不敏感键） template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_section { // 允许 basic_inifile 访问 private 成员 template \u0026lt;typename H, typename E\u0026gt; friend class basic_inifile; using DataContainer = std::unordered_map\u0026lt;std::string, field, Hash, Equal\u0026gt;; public: using comment_container = field::comment_container; using key_type = typename DataContainer::key_type; using mapped_type = typename DataContainer::mapped_type; using value_type = typename DataContainer::value_type; using size_type = typename DataContainer::size_type; using difference_type = typename DataContainer::difference_type; using iterator = typename DataContainer::iterator; using const_iterator = typename DataContainer::const_iterator; // 默认构造 basic_section() = default; // 默认析构函数 ~basic_section() = default; // 默认移动构造函数 basic_section(basic_section \u0026amp;\u0026amp;) noexcept = default; // 默认移动赋值函数 basic_section \u0026amp;operator=(basic_section \u0026amp;\u0026amp;) noexcept = default; private: DataContainer data_; // 存储键值对 }; // ini 文件类，存储多个 section template \u0026lt;typename Hash, typename Equal\u0026gt; class basic_inifile { public: using section = basic_section\u0026lt;Hash, Equal\u0026gt;; // 在 basic_inifile 内部定义 section 别名 using SectionContainer = std::unordered_map\u0026lt;std::string, section, Hash, Equal\u0026gt;; using key_type = typename SectionContainer::key_type; using mapped_type = typename SectionContainer::mapped_type; using value_type = typename SectionContainer::value_type; using size_type = typename SectionContainer::size_type; using difference_type = typename SectionContainer::difference_type; using iterator = typename SectionContainer::iterator; using const_iterator = typename SectionContainer::const_iterator; // 默认构造 basic_inifile() = default; // 默认析构 ~basic_inifile() = default; // 默认移动构造 basic_inifile(basic_inifile \u0026amp;\u0026amp;) noexcept = default; // 默认移动赋值 basic_inifile \u0026amp;operator=(basic_inifile \u0026amp;\u0026amp;) noexcept = default; // 添加一个 section section \u0026amp;add_section(const std::string \u0026amp;name) { return sections_[name]; // 如果 name 存在，返回已有的 section，否则创建新 section } // 获取一个 section（可变版本） section *get_section(const std::string \u0026amp;name) { auto it = sections_.find(name); return it != sections_.end() ? \u0026amp;it-\u0026gt;second : nullptr; } // 获取一个 section（只读版本） const section *get_section(const std::string \u0026amp;name) const { auto it = sections_.find(name); return it != sections_.end() ? \u0026amp;it-\u0026gt;second : nullptr; } private: SectionContainer sections_; // 存储多个 section }; // 提供默认大小写不敏感的类型别名（类似 std::string） using section = basic_section\u0026lt;CaseInsensitiveHash, CaseInsensitiveEqual\u0026gt;; using inifile = basic_inifile\u0026lt;CaseInsensitiveHash, CaseInsensitiveEqual\u0026gt;; #include \u0026lt;iostream\u0026gt; int main() { inifile ini; ini.add_section(\u0026#34;General\u0026#34;); ini.add_section(\u0026#34;Database\u0026#34;); // 测试大小写不敏感 if (ini.get_section(\u0026#34;general\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;Section \u0026#39;General\u0026#39; exists (case insensitive)\u0026#34; \u0026lt;\u0026lt; std::endl; } if (ini.get_section(\u0026#34;DATABASE\u0026#34;)) { std::cout \u0026lt;\u0026lt; \u0026#34;Section \u0026#39;Database\u0026#39; exists (case insensitive)\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } ","date":"2025-04-02T21:38:50+08:00","permalink":"https://abin-z.github.io/p/secondblog/","title":"SecondBlog"},{"content":"你好, 世界 这是我的第一个博客\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;inifile/inifile.h\u0026gt; /// @brief Specialization of INIFILE_TYPE_CONVERTER for std::vector\u0026lt;T\u0026gt;. /// @tparam T The type of elements in the vector. template \u0026lt;typename T\u0026gt; struct INIFILE_TYPE_CONVERTER\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; { /// @brief Encodes a vector into a delimited string. void encode(const std::vector\u0026lt;T\u0026gt; \u0026amp;vec, std::string \u0026amp;value) { constexpr char delimiter = \u0026#39;,\u0026#39;; // Delimiter used to separate elements in the string std::string encoded_item; for (const auto \u0026amp;v : vec) { INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt; conv; conv.encode(v, encoded_item); // Encode each element of the vector value += encoded_item + delimiter; // Append the encoded element and delimiter } if (value.back() == delimiter) value.pop_back(); // Remove the trailing delimiter } /// @brief Decodes a delimited string into a vector. void decode(const std::string \u0026amp;value, std::vector\u0026lt;T\u0026gt; \u0026amp;vec) { constexpr char delimiter = \u0026#39;,\u0026#39;; // Delimiter used to separate elements in the string std::vector\u0026lt;std::string\u0026gt; info = ini::split(value, delimiter); // Split the string T encoded_item; for (const auto \u0026amp;v : info) { INIFILE_TYPE_CONVERTER\u0026lt;T\u0026gt; conv; conv.decode(v, encoded_item); // Decode each part of the string vec.emplace_back(std::move(encoded_item)); // Add the decoded element to the vector } } }; /// @brief Print the contents of a vector to the console. template \u0026lt;typename T\u0026gt; void print_vector(const std::vector\u0026lt;T\u0026gt; \u0026amp;vec) { std::cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (size_t i = 0; i \u0026lt; vec.size(); ++i) { std::cout \u0026lt;\u0026lt; vec[i]; if (i != vec.size() - 1) { std::cout \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; } } std::cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { ini::inifile inif; // Create an INI file object // Define vectors of different types std::vector\u0026lt;int\u0026gt; vec1 = {1, 2, 3, 4, 5}; std::vector\u0026lt;double\u0026gt; vec2 = {1.1111, 2.2222, 3.3333, 4.4444, 5.5555}; std::vector\u0026lt;std::string\u0026gt; vec3 = {\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;, \u0026#34;eee\u0026#34;}; // Set different types of vectors in the INI file object inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;] = vec1; inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;] = vec2; inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;] = vec3; // Get different vectors from INI file object std::vector\u0026lt;int\u0026gt; v1 = inif[\u0026#34;section\u0026#34;][\u0026#34;key1\u0026#34;]; std::vector\u0026lt;double\u0026gt; v2 = inif[\u0026#34;section\u0026#34;][\u0026#34;key2\u0026#34;]; std::vector\u0026lt;std::string\u0026gt; v3 = inif[\u0026#34;section\u0026#34;][\u0026#34;key3\u0026#34;]; // Print the vectors to the console print_vector(v1); print_vector(v2); print_vector(v3); // Print the entire INI file content as a string std::cout \u0026lt;\u0026lt; \u0026#34;ini info:\\n\u0026#34; \u0026lt;\u0026lt; inif.to_string() \u0026lt;\u0026lt; std::endl; return 0; // Exit the program } ","date":"2025-04-01T23:37:26+08:00","permalink":"https://abin-z.github.io/p/firstblog/","title":"Firstblog"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-03-11T00:00:00Z","image":"https://abin-z.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://abin-z.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Git分布式版本控制系统 git原理图解\ngit是一个分布式版本控制系统, 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。\n在本书所展示的例子中，我们对保存着软件源代码的文件作版本控制，但实际上，可以对任何类型的文件进行版本控制。\n快速上手: https://www.yiibai.com/git/git_basic_concepts.html\nGit使用铁令 切换分支前先提交本地的修改 代码及时提交, 只要提交过了就不会丢 切勿删除 .git 目录 一. 版本控制分类 本地版本控制 许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。\n为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。\n其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集(补丁是指文件修订前后的变化)；通过应用所有的补丁，可以重新计算出各个版本的文件内容。\n集中化的版本控制系统 代表作: SVN\n接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统(Centralized Version Control Systems，简称 CVCS)应运而生。 这类系统，诸如 CVS、Subversion(SVN) 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。\n这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。\n事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问您将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。\n分布式版本控制系统 代表作是git\n于是分布式版本控制系统(Distributed Version Control System，简称 DVCS)面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。如下图所示:\n更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。藉此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。\n分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。\n二. git的下载安装与基本配置: git安装配置: https://www.yiibai.com/git/git_environment.html\n1. git使用前的配置 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：\n/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 --system 选项的 git config 时，它会从此文件读写配置变量。\n~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递--global 选项让 Git 读写此文件。\n当前使用仓库的 Git 目录中的 config 文件(就是 .git/config)：针对该仓库。\n每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。\n在 Windows 系统中，Git 会查找 $HOME 目录下(一般情况下是 C:\\Users\\$USER)的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。\n2. 用户信息 当安装完 Git 应该做的第一件事就是设置用户名称与邮件地址。这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到每一次提交中，不可更改：(这个可以是不存在的邮箱，但是就是必须要有)\n1 2 3 4 5 6 $ git config --global user.name \u0026#34;abin\u0026#34; $ git config --global user.email abin_z@163.com # 不使用 --global 参数就是设置当前项目的git配置 $ git config user.name \u0026#34;abin\u0026#34; $ git config user.email abin_z@163.com 再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用这些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行不使用 --global 选项的命令来配置。\n修改后可以在文件中查看配置: C:\\Users\\Abin\\.gitconfig (windows下)\n3. 检查配置信息 如果想要检查你的配置，可以使用 git config --list 命令来列出所有 Git 当时能找到的配置。\n或者是使用git config -l 查看当前配置\n1 2 3 4 5 6 7 8 yiibai@ubuntu:~$ git config --list user.name=maxsu user.email=maxsu@yiibai.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto ... 上面的输出结果中，可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置(例如：/etc/gitconfig 与 ~/.gitconfig)。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。\n可以通过输入 git config \u0026lt;key\u0026gt;： 来检查 Git 的某一项配置。\n1 2 3 4 5 yiibai@ubuntu:~$ git config user.name maxsu yiibai@ubuntu:~$ git config user.email maxsu@yiibai.com yiibai@ubuntu:~$ 4. 获取帮助 若在使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：\n1 2 3 $ git help \u0026lt;verb\u0026gt; $ git \u0026lt;verb\u0026gt; --help $ man git-\u0026lt;verb\u0026gt; 例如，要想获得 config 命令的手册，执行\n1 $ git help config 这些命令很棒，因为随时随地可以使用而无需联网。如果你觉得手册或者本书的内容还不够用，你可以尝试在 Freenode IRC 服务器( irc.freenode.net )的 #git 或 #github 频道寻求帮助。这些频道经常有上百人在线，他们都精通 Git 并且乐于助人。\n5. 为常用指令设置别名 有些常用的指令参数非常多，每次都要输入好多参数，我们可以使用别名。\n打开用户目录，创建 .bashrc 文件 部分windows系统不允许用户创建点号开头的文件，可以打开gitbash,执行 touch ~/.bashrc 在文件中添加一下信息: 1 2 3 4 5 #用于输出git提交日志 alias git-log=\u0026#39;git log --pretty=oneline --all --graph --abbrev-commit\u0026#39; #用于输出当前目录所有文件的基本信息 alias ll=\u0026#39;ls -al\u0026#39; 6. 解决gitbash中文乱码问题 打开gitbash执行以下的命令:\n1 git config --global core.quotepath false # 让 Git 在显示文件名时不使用引号，并且避免对非 ASCII 字符进行转义。 ${git_home}/etc/bash.bashrc 文件最后添加如下内容:\n1 2 export LANG=\u0026#34;zh_CN.UTF-8\u0026#34; export LC_ALL=\u0026#34;zh_CN.UTF-8\u0026#34; 7. 解决gitk中文乱码问题 打开gitbash执行一下的命令\n1 git config --global gui.encoding utf-8 三. Git 工作流程图 说明：\nworkspace：工作区 staging area：暂存区/缓存区 local repository：版本库或本地仓库 remote repository：远程仓库 1 2 3 4 5 6 7 8 9 10 11 clone #克隆： 从远程仓库中克隆代码到本地仓库 checkout\t#检出: 从本地仓库中检出一个仓库分支然后进行修订 add\t#添加: 在提交代码前先将代码添加到暂存区 commit\t#提交: 提交到本地仓库. 本地仓库中保存了修改的历史版本 fetch\t#抓取: 从远程仓库抓取到本地仓库,不进行任何的合并操作,使用频率不高 pull\t#拉取: 从远程仓库中拉取代码到本地仓库,并自动进行合并(merge),然后放到工作区 push\t#推送: 修改完成后,需要和团队成员共享代码时,将代码推送到远程仓库 log\t#日志: 查看历史提交记录 config\t#配置: 可以配置和查看相应的git配置信息 status\t#状态: 查看当前状态 switch\t#切换: 切换分支 一个简单的操作步骤：\n1 2 3 $ git init #初始化仓库。 $ git add . #添加文件到暂存区。 $ git commit #将暂存区内容添加到本地仓库中。 1. 创建仓库命令 下表列出了 git 创建仓库的命令：\n命令 说明 git init 初始化仓库, 文件夹中会出现一个 .git 的文件夹 git clone 拷贝一份远程仓库，也就是下载一个项目。 2. 提交与修改 Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。\n下表列出了有关创建与提交你的项目的快照的命令：\n命令 说明 git add 添加文件到仓库 git status 查看仓库当前的状态，显示有变更的文件。 git diff 比较文件的不同，即暂存区和工作区的差异。 git show 显示各种类型的对象, 常用于查看提交差异 git commit 提交暂存区到本地仓库。 git reset 回退版本。 git rm 删除工作区文件。 git mv 移动或重命名工作区文件。 git tag 对版本库做标记, 它是指向某个commit的指针 git log #日志 git log 命令是 Git 中用于查看提交历史的命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 git log\t#可以按键盘空格/字母b键将信息向下/向上翻页，也可以按键盘向上/向下箭头向上/向下按行滚动 git log –p\t#输出每一个commit之间的差异信息 git log --stat\t#输出每一个commit之间的差异统计信息 git log--oneline\t#输出历史commit的简短信息 git log：显示当前分支（HEAD）的全部提交记录，按照时间倒序排列。 git log \u0026lt;commit\u0026gt;：从指定的提交记录开始显示，按照时间倒序排列。 git log --follow \u0026lt;file\u0026gt;：显示指定文件的提交历史，并显示该文件的移动或重命名记录。 git log --pretty=\u0026lt;format\u0026gt;：使用指定的格式输出提交信息。常用的格式有 %H（提交哈希值）、%h（简短的提交哈希值）、%an（作者名）、%ae（作者邮箱）、%cn（提交者名）、%ce（提交者邮箱）、%s（提交说明）等。 git log --grep=\u0026lt;pattern\u0026gt;：仅显示包含指定模式的提交记录，模式可以是正则表达式。 git log --author=\u0026lt;name\u0026gt;：仅显示指定作者的提交记录。 git log --oneline：将每个提交记录压缩为一行，只显示提交哈希值和提交说明。 git log --graph：在提交记录前面绘制 ASCII 图形表示提交记录之间的关系。 git log --since=\u0026lt;date\u0026gt;：仅显示指定日期之后的提交记录，日期的格式可以是 “YYYY-MM-DD” 或 “\u0026lt;n\u0026gt; days ago” 等。 git diff #差异 当合并分支时, 如果出现了冲突, 也可以使用git diff查看是那些地方出现了冲突 查看当前分支修改了那些内容git diff 1 2 3 4 5 6 7 8 9 10 11 12 13 git diff\t#显示工作区与暂存区的差异 git diff --cached\t#显示暂存区与历史版本库的差异 git diff HEAD~2\t#显示工作区与最新提交第二父提交的差异 git diff HEAD~2 --a.txt\t#显示工作区与最新提交第二父提交中a.txt文件差异 git diff –cachedHEAD~1\t#显示暂存区与历史版本库最新提交第一父提交的差异 git diff HEAD HEAD~2\t#显示HEAD指向的历史提交和其第二父提交之间的差异 git diff HEAD HEAD~2-- a.txt\t#显示HEAD指向的历史提交和其第二父提交中a.txt之间的差异 git show #显示 显示一个或多个对象（blob、树、标签和提交）。\n对于提交，它显示日志消息和文本差异。它还以 git diff-tree \u0026ndash;cc 生成的特殊格式呈现合并提交。 对于标签，它显示标签消息和引用的对象。 对于树，它显示名称（相当于带有 \u0026ndash;name-only 的 git ls-tree）。 对于纯 blob，它显示纯内容。 1 2 3 4 5 6 7 8 9 git show [commit_id] #查看某次历史提交信息的完整信息 git show HEAD\t#查看HEAD标签当前指向的提交的完整信息 git show master #查看master分支最新一次提交的完整信息 git show master^或git show master~ #查看master分支最新一次提交的父提交的完整信息 git show master^2\t#查看master分支最新一次提交的第二个父提交（也就是父提交的父提交）的完整信息 git 修改上一次提交 如果你想修改上一次提交的记录（包括提交信息、文件内容或作者信息），你可以使用 git commit --amend 命令。\n修改上一次提交的提交信息 如果你只想修改上一次提交的提交信息，而不改变提交的内容，可以使用以下命令：\n1 git commit --amend 执行该命令后，Git 会打开默认的文本编辑器（例如 vi 或 nano），让你编辑提交信息。修改提交信息后，保存并退出编辑器，Git 会更新提交信息。\n修改上一次提交的作者信息（邮箱/用户名） 如果你想修改上一次提交的作者信息（例如，修改用户名或邮箱），可以使用 --author 选项。比如：\n1 git commit --amend --author=\u0026#34;New-Name \u0026lt;new-email@example.com\u0026gt;\u0026#34; 这会将上一次提交的作者信息修改为 New-Name \u0026lt;new-email@example.com\u0026gt;，并保持其他提交内容不变。\n修改上一次提交的文件内容 如果你想修改上一次提交的文件内容，可以按照以下步骤操作：\n修改文件：对文件进行更改，修改你需要更新的内容。\n暂存修改：使用 git add 将修改的文件暂存起来：\n1 git add \u0026lt;file\u0026gt; 使用 git commit --amend 更新提交：\n1 git commit --amend 这样，Git 会将修改的内容添加到上一次提交中，并保持原来的提交信息。你可以在编辑器中选择是否修改提交信息。\n强制推送到远程仓库（如果已经推送）谨慎操作 ​\t如果你已经将该提交推送到远程仓库，并且需要更新远程的提交历史（例如，修改了提交信息、作者或文件），你需要强制推送：\n1 git push --force 注意： 强制推送会覆盖远程仓库中的提交历史。如果有其他人正在基于这些提交工作，强制推送可能会导致冲突，因此在团队协作中要小心使用。\n3. 查看提交日志 命令 说明 git log 查看历史提交记录 git blame \u0026lt;file\u0026gt; 以列表形式查看指定文件的历史修改记录 4. 远程操作 命令 说明 git remote 远程仓库操作 git fetch 从远程获取代码库 git pull 下载远程代码并合并 git push 上传远程代码并合并 5. reset版本回退 git reset 命令用于回退版本，可以指定退回某一次提交的版本。\n要想用好reset命令，必须深入理解它的三个参数: --soft，--mixed（默认），--hard\ngit reset \u0026ndash;soft 如下图，soft参数是指将本地仓回滚到Y版本，但是暂存区和工作区保持不变。此时本地仓回滚到Y版本号commit完成的那一刻。\ngit reset \u0026ndash;mixed 1 git reset --mixed 或者 git reset 这是默认参数。如下图 \u0026ndash;mixed 表示本地仓和暂存区，都回滚到Y版本号。工作区代码不受影响。\ngit reset \u0026ndash;hard 本地仓库、暂存区、工作区，三区都回滚。\n作用: 不同提交版本之间的切换\n1 2 3 4 5 6 7 8 9 git reset [--soft | --mixed | --hard] [HEAD] # --soft 回退到某个版本 。是指将本地仓回滚到指定版本，但是暂存区和工作区保持不变 git reset --soft \u0026lt;commitID\u0026gt; # --mixed 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。 git reset --mixed \u0026lt;commitID\u0026gt; # --hard 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交： git reset --hard \u0026lt;commitID\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 # 回退所有内容到上一个版本 git reset HEAD^ # 回退test.txt这个文件的版本到上一个版本 git reset HEAD^ test.txt # 向前回退到第3个版本 git reset HEAD~3 # 回退到某个版本51363e6 git reset 51363e6 commitID 可以使用 git log 或者是git-log 查看\n如何查看已经所有已提交的记录?\n1 git reflog\t#这个指令可以看到已经删除的提交记录, 包括 git reset --hard 6. tag标签 git仓库的tag是给仓库历史中的某一个提交打上标签，以示重要, 它指向某个commit id标记的快照记录指针. tag主要用于发布版本的管理，一个版本发布之后，我们可以为git打上 v.1.0.1 v.1.0.2 …这样的标签。 tag 对应某次commit, 是一个点，是不可移动的。 创建 tag 是基于本地分支的 commit，而且与分支的推送是两回事，就是说分支已经推送到远程了，但是你的 tag 并没有，如果想把 tag 推送到远程分支上，需要另外执行 tag 的推送命令。 tag 常用命令:\n创建tag标签 Git 支持两种标签：轻量标签（lightweight)与附注标签（annotated)。\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n附注标签 在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 tag 命令时指定 -a 选项：\n1 git tag -a \u0026lt;tagname\u0026gt; -m \u0026lt;comment\u0026gt;\t# 创建本地附注tag, -a 指定标签名, -m 指定说明信息 -m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。\n1 git show \u0026lt;tagname\u0026gt;\t# show命令可以看到标签信息和与之对应的提交信息 通过使用 git show \u0026lt;tagname\u0026gt; 会输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git tag -l v0.11 v1.12 Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git show v1.12 tag v1.12 Tagger: abin \u0026lt;abin_z@163.com\u0026gt; Date: Thu Aug 10 22:43:19 2023 +0800 标注tag说明, 版本号v1.12, 测试tag指令 commit 1e1f9aecb47dd0671a64bd84138172b96869e45a (HEAD -\u0026gt; master, tag: v1.12) Author: abin \u0026lt;abin_z@163.com\u0026gt; Date: Thu Aug 10 22:42:36 2023 +0800 修改testFile.txt文件 轻量标签 另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n1 git tag \u0026lt;tagname\u0026gt;\t# 创建轻量级标签，不用-a，-m等参数 这时，如果在标签上运行 git show \u0026lt;tagname\u0026gt; ，你不会看到额外的标签信息。 命令只会显示出提交信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git tag v1.13_lw Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git tag v0.11 v1.12 v1.13_lw Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git show v1.13_lw commit ced5c08e34686bf2ddc6b9c7711b79bacf8fce8d (HEAD -\u0026gt; master, tag: v1.13_lw) Author: abin \u0026lt;abin_z@163.com\u0026gt; Date: Thu Aug 10 22:57:14 2023 +0800 修改testFile.txt文件 给指定的commit打Tag 你也可以对过去的提交打标签。打Tag不必要在head之上，也可在之前的版本上打，这需要你知道某个提交对象的校验和（通过git log获取）。\n1 git tag -a \u0026lt;tagname\u0026gt; \u0026lt;commitID\u0026gt;\t# 给指定的commitID打tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git tag -a v0.1 766f0ae Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git tag v0.1 v0.11 v1.12 v1.13_lw Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git show v0.1 tag v0.1 Tagger: abin \u0026lt;abin_z@163.com\u0026gt; Date: Thu Aug 10 23:15:47 2023 +0800 测试在指定commitID上添加tag标签 commit 766f0ae17925916f572745c13136234cee7e3298 (tag: v0.1) Author: zhangbin \u0026lt;abin_z@163.com\u0026gt; Date: Wed Dec 22 16:29:26 2021 +0800 abc.txt 列出标签 在 Git 中列出已有的标签非常简单，只需要输入 git tag （可带上可选的 -l 选项 --list）：\n1 2 3 git tag # 查看本地所有tag列表 git tag --list # 查看本地所有tag列表 git tag -l # 同理查看本地所有tag列表 这个命令以字母顺序列出标签，但是它们显示的顺序并不重要。\n你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：\n1 2 3 4 5 6 7 8 9 10 11 $ git tag -l \u0026#34;v1.8.5*\u0026#34;\t# 只查看v1.8.5开头的tag标签, *号为通配符 v1.8.5 v1.8.5-rc0 v1.8.5-rc1 v1.8.5-rc2 v1.8.5-rc3 v1.8.5.1 v1.8.5.2 v1.8.5.3 v1.8.5.4 v1.8.5.5 共享标签 默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin \u0026lt;tagname\u0026gt;。\n1 git push origin \u0026lt;tagname\u0026gt;\t# 推送一个本地标签到远程仓库origin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git tag -l \u0026#34;v1*\u0026#34; v1.12 v1.13_lw Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git push origin v1.12 Enumerating objects: 6, done. Counting objects: 100% (6/6), done. Delta compression using up to 6 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (4/4), 470 bytes | 156.00 KiB/s, done. Total 4 (delta 1), reused 0 (delta 0), pack-reused 0 remote: Powered by GITEE.COM [GNK-6.4] To gitee.com:abin_z/git-demo.git * [new tag] v1.12 -\u0026gt; v1.12 #效果如下图: 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。\n1 git push \u0026lt;remote\u0026gt; --tags\t# 推送全部未推送过的本地标签(包括轻量标签),到远程仓库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git push origin --tags Enumerating objects: 7, done. Counting objects: 100% (7/7), done. Delta compression using up to 6 threads Compressing objects: 100% (4/4), done. Writing objects: 100% (5/5), 607 bytes | 202.00 KiB/s, done. Total 5 (delta 1), reused 0 (delta 0), pack-reused 0 remote: Powered by GITEE.COM [GNK-6.4] To gitee.com:abin_z/git-demo.git * [new tag] v0.1 -\u0026gt; v0.1 * [new tag] v0.11 -\u0026gt; v0.11 * [new tag] v1.13_lw -\u0026gt; v1.13_lw # 效果如下图: 删除标签 要删除掉你本地仓库上的标签，可以使用命令 git tag -d \u0026lt;tagname\u0026gt;。\n1 git tag -d \u0026lt;tagname\u0026gt;\t# 删除本地仓库上的标签, 此命令不会删除远程仓库中已存在的标签 例如，可以使用以下命令删除一个轻量标签：\n1 2 3 4 5 6 7 8 9 Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git tag -d v1.13_lw Deleted tag \u0026#39;v1.13_lw\u0026#39; (was ced5c08) Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git tag v0.1 v0.11 v1.12 注意: 上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push \u0026lt;remote\u0026gt; :refs/tags/\u0026lt;tagname\u0026gt; 来更新你的远程仓库：\n1 git push --delete origin \u0026lt;tag_name\u0026gt;\t# 这条指令可以删除远程的tag 1 git push \u0026lt;remote\u0026gt; :refs/tags/\u0026lt;tag_name\u0026gt; # 本地仓库和远程仓库同步 1 2 3 4 5 6 Abin@DESKTOP-TFU43J6 MINGW64 /f/gitDemo (master) $ git push origin :refs/tags/v1.13_lw remote: Powered by GITEE.COM [GNK-6.4] To gitee.com:abin_z/git-demo.git - [deleted] v1.13_lw 6. git基础操作指令 Git工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着我们执行Git的命令而 发生变化。\ngit基础指令练习 首先准备一个空文件夹 初始化本地仓库 1 git init 创建一个file01.txt文件(这个文件怎么创建都可以,可以在Windows下创建) 1 touch file01.txt 查看当前工作区的文件状态 1 git status 将工作区中的文件添加到暂存区 1 git add .\t#注意其中的 . 表示当前文件夹的所有文件 也可以单独指定某个文件 提交暂存区文件到本地仓库 1 git commit -m \u0026#39;add file01\u0026#39;\t#-m 表示提交的说明信息/一般为功能描述 查看提交的文件的目的地(所在分支) 1 git log\t#查看文历史提交日志 现在修改工作区中的文件 1 vim file01.txt 查看此时文件的状态: 此时的状态为未暂存 1 git status 添加文件到暂存区 提交本次修改 1 git commit -m \u0026#39;update file01\u0026#39; 查看此时的提交日志 1 git log 演示版本回退功能 再次提交一次修改, 并且添加一个文件 file02.txt 文件\n提交本次版本\n版本回退 可以跳转到任何提交的版本 1 git reset --hard [commitID]\t#commitID 表示要回退的版本 查看历史提交版本记录 , 还是可以回到之前的版本的, 可以通过以下命令来查看历史提交版本 1 git reflog 演示tag指令, tag是git版本库的一个标记，指向某个commit的指针。 1 git tag # 查看本地所有 tag 四. 添加忽略列表(.gitignore文件) 一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为.gitignore 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例:\n1 2 touch .gitignore vim .gitignore 1. 常用忽略规则 /abc/：忽略根目录下的abc文件夹以及abc文件夹下的所有子文件夹和文件 bcd/：忽略根目录下或者根目录下任意子目录下的bcd文件夹以及bcd文件夹下的所有子文件夹和文件 /mmm.txt：忽略根目录下的mmm.txt文件 nnn.txt：忽略根目录下或者根目录下任意子目录下的nnn.txt文件\n根目录：即工作区目录。工作区、暂存区、版本库概念\n2. 忽略已被跟踪的文件 **忽略规则只针对还没有被git跟踪的文件及文件夹有效。**若需要忽略规则对已被跟踪的文件及文件夹有效，则需要取消对文件或文件夹的跟踪\n1 2 3 git rm -r --cached \u0026lt;dir\u0026gt;：取消对文件夹及文件夹下的所有子文件夹、文件的跟踪，文件夹及文件夹下的所有子文件夹、文件的状态将从跟踪状态变为未跟踪状态 git rm --cached \u0026lt;file\u0026gt;：取消对文件的跟踪，文件的跟踪状态将变为未跟踪状态 git restore --staged \u0026lt;file\u0026gt; 将指定文件移除跟踪 取消对文件或文件夹的跟踪之后，.gitignore文件中的忽略规则将会对取消了跟踪状态的文件或文件夹生效\n运行如下类似的命令:\n1 2 3 4 git rm -r --cached . # 取消文件跟踪 git add .\t# 添加跟踪(新增的.gitignore文件会生效)\tgit commit -m \u0026#34;add gitignore\u0026#34;\t# 提交代码 git push origin master\t# 推送代码至远程仓库 五. Git 分支管理 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。\n有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。\nGit分支命令git branch、git switch、git checkout的区别: https://blog.csdn.net/wpw2000/article/details/115895848\n1. 列出分支命令： 1 2 3 4 git branch\t#查看本地分支，当前分支前面会标一个*号。 git branch -r #查看远程分支。 git branch -a\t#查看本地分支和远程分支，远程分支会用红色表示出来（如果你开了颜色支持的话）。 git branch -vv #查看本地分支对应的远程分支。\t出现ahead表示本地分支领先远端分支 1 git branch -vv\t#说明 2. 创建分支命令： 1 2 3 4 5 6 7 8 9 10 11 12 13 git branch [branchname]\t#创建分支, 但是没有切换过去, 还停留在当前分支 ---------------------------------------------------------------------------------- git checkout -b \u0026lt;name\u0026gt; #创建一个叫name的分支，然后切换到该分支。 #相当于两条命令：git branch \u0026lt;name\u0026gt;，git checkout \u0026lt;name\u0026gt; git switch -c \u0026lt;name\u0026gt; #创建一个叫name的分支,并切换过去 #相当于两条命令：git branch \u0026lt;name\u0026gt;，git switch \u0026lt;name\u0026gt; ---------------------------------------------------------------------------------- git branch -m oldName newName\t#重命名分支 现在在master主分支上新建文件master.txt并提交\n3. 切换分支命令: 就简单的切换分支，推荐使用switch命令，不推荐使用checkout\ngit checkout命令用于切换分支或恢复工作树文件。git checkout是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。\n1 2 3 4 5 6 7 git checkout [branchname]\t#切换分支 git switch\t[branchname]\t#切换分支, 推荐使用 switch 切换分支 #-------------------------- checkout 和 switch 在分支操作方面的用处完全一样, 那么在分支操作上尽量使用: git branch 和 git switch #-------------------------- 因为 git checkout 除了可以操作分支, 它还可以操作文件, 这个命令可以重写工作区, 是一个很危险的命令 ================================================================ git checkout -b [branchname]\t#直接创建分支并且切换到当前分支,若分支存在则直接切换到该分支\t当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。\n现在在develop分支上新建文件develop.txt并提交\n现在切换回master分支上, 不会出现develop分支上提交的develop.txt文件\n4. 合并分支命令: 1 git merge [branchname]\t# 将branchname的分支合并到当前分支 合作开发时,基本都是在develop分支上进行开发的, 需要保证master分支的稳定性\n协同开发就会出现分支, 下图是在develop分支上开发的情况\n下图是在master分支上开发的情况\n合并分支操作(没有冲突的时候):\n1 git merge [branchname] 填写合并分支的说明信息(一般为实现了什么功能)\n5. 删除分支命令： 删除分支的时候是不能删除当前所在的分支的 1 2 3 git branch -d [branchname]\t#需要做检查,未合并分支的时候会提示 git branch -D [branchname]\t#不需要做检查,直接删除 6. 合并分支冲突 当两个分支都修改同一个文件的同一部分(比如同一行)就会产生冲突,这时候git需要开发人员决定要保留哪一部分\n创建一个文件(common.txt)模拟冲突 原始数据如下\nmaster分支中提交的数据\ndev分支中提交的数据\n目前分支情况:\n执行合并分支操作:\n可以通过查看文件详情了解那些文件冲突\n1 git status #查看那些文件存在冲突 此时的冲突文件common.txt内容为:\n根据实际情况来修改冲突的文件\n修改完冲突文件后, 后面进行add , commit 指定解决冲突信息\n7. Git合并的快进模式 在master执行合并操作,就会执行快进模式(效果是一样的)\n8. git revert (还原) git revert 撤销某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交\ngit revert命令可以被认为是“撤消”命令。但是它不是传统的撤消操作。不是从项目历史中删除提交，而是计算出如何反转要撤销的提交所引入的更改，并附加一个新的提交及生成的反向内容。这种方式可以防止 Git 丢失历史记录，这对于我们的修订历史记录的完整性和可靠的协作非常重要。\n当想要应用项目历史中提交的逆向时，应该使用 revert。如果我们正在跟踪错误并发现它是由单个提交引入的。此时我们无需手动进入、修复并提交新快照，而是可以使用git revert自动为我们完成所有这些工作。\nrevert分为 revert 普通commit 和 revert merge commit\n对于普通的commit，使用 git revert \u0026lt;commit id\u0026gt; 即可，git 会生成一个新的 commit，将指定的 commit 内容从当前分支上撤除\n对于merge commit，需要添加 -m 选项以代表这次 revert 的是一个 merge commit, 但如果直接使用 git revert \u0026lt;commit id\u0026gt;，git 也不知道到底要撤除哪一条分支上的内容，这时需要指定一个 parent number 标识出\u0026quot;主线\u0026quot;，主线的内容将会保留，而另一条分支的内容将被 revert。 如上面的例子中，从 git show 命令的结果中可以看到，merge commit 的 parent 分别为 d98dc 和 ca82c，其中 d98dc 代表 master 分支（从图中可以看出），ca82c 代表 will-be-revert 分支。需要注意的是 -m 选项接收的参数是一个数字，数字取值为 1 和 2，也就是 Merge 行里面列出来的第一个还是第二个，其含义用来保留某个分支。\ngit revert的注意事项: 关于git revert的一点坑\n1 git revert \u0026lt;commit id\u0026gt; #还原某些现有提交 1 2 # 执行撤销 5f09a20 的提交 git revert 5f09a20 再次查看git-log\n9. git cherry-pick 通过 cherry-pick 命令，Git 可以将其他任何分支中的选定提交合并到当前的 Git HEAD 分支中。\n1 git cherry-pick \u0026lt;commit sha\u0026gt;\t# 将其他分支的commitID的提交合并到当前分支 在执行 git merge 或 git rebase 时，一个分支的所有提交都会被合并。而 cherry-pick 命令则允许你选择单个提交进行整合。\n区别图示如下:\n1 使用 merge 的情况: 在执行 merge 或 rebase 时，一个分支的所有提交都会被整合。 1 使用 cherry-pick 的情况: 允许你选择个别提交进行整合。在本例中，只有 C2 被整合到主分支，而不是 C4。 案例:\n当前在master分支上\n1 2 3 # 执行 git cherry-pick 0ee5634, 从develop分支上合并0ee5634这一次提交 git cherry-pick 0ee5634 # 合并后的结果如下图 什么时候用 Cherry-pick?\n简而言之就是：尽量少用。之所以要尽量少用 cherry-pick，是因为它很容易产生 \u0026ldquo;重复\u0026quot;提交：当你使用 cherry-pick 将一个提交整合到 HEAD 分支时，Git 必须创建一个内容完全相同的新提交。不过，这是一个全新的提交对象，有自己的 SHA 标识符。同时也会失去跟踪提交历史的能力。\n如果你不按顺序提交了很多提交，这些提交就会被记录在你的分支中，这可能会导致你的 Git 分支出现不理想的结果。\n只要能用传统的合并或重置来整合，就应该这么做。Cherry-pick 应保留给不可能这样做的情况，例如必须创建 Hotfix 或只想从一个废弃的分支中保存一个或几个提交。\n10. git stash (暂存) git stash：将本地没提交的内容进行缓存并从当前分支移除。缓存的数据结构为堆栈，先进后出。\n注意：git commit的内容不会被缓存， 但git add的内容会被缓存。stash 只会操作被git追踪的文件，也就是说，如果有新增的文件，需要进行git add [文件名]让git追踪该文件，再进行stash就可以了。\n命令名 作用 git stash 隐藏当前的工作现场, 此时, git status的结果是 clean git stash list 查看所有隐藏, 每一行的冒号前面的字符串就是标识此隐藏的id git stash pop 恢复最新的stash进度到工作区, 并删除栈中的stash git stash pop stash@{stash_id} 恢复指定的stash进度到工作区, 并删除栈中的stash git stash apply 恢复最新的进度到工作区, 不会删除栈中的stash git stash drop stash@{stash_id} 从暂存列表中删除一个特定的暂存。 git stash clear 清空暂存区的所有stash, 谨慎使用(不当使用会导致更改丢失) git stash 命令实用指南\n我们经常会遇到这样的情况： 正在dev分支开发新功能，做到一半时有人过来反馈一个bug，让马上解决，但是新功能做到了一半你又不想提交，这时就可以使用git stash命令先把当前进度保存起来，然后切换到另一个分支去修改bug，修改完提交后，再切回dev分支，使用git stash pop来恢复之前的进度继续开发新功能。\n分支有改变时不提交又不能切换分支，如下：\n使用 git stash 保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行git status命令，就会发现当前是一个干净的工作区，没有任何改动。使用git stash save 'message...'可以添加一些注释\n它会保存当前工作进度，会把暂存区和工作区的改动保存到一个未完结变更的堆栈中；执行完这个命令后，在运行 git status 命令，就会发现当前是一个干净的工作区，没有任何改动。\ngit stash 是本地的，不会上传到服务器上； 可以通过使用git stash save 'message...'可以添加一些注释。 下面是使用 git stash 时要遵循的顺序：\n将修改保存到分支 A。 运行 git stash。 签出分支 B。 修正 B 分支的错误。 提交并（可选）推送到远程。 回到分支 A 运行 git stash pop 来取回你的暂存的改动。 11. git rebase (谨慎使用) 理解rebase命令 git rebase 命令的文档描述是 Reapply commits on top of another base tip，从字面上理解是「在另一个基端之上重新应用提交」，这个定义听起来有点抽象，换个角度可以理解为「将分支的基础从一个提交改成另一个提交，使其看起来就像是从另一个提交中创建了分支一样」，如下图：\n假设我们从 Master 的提交 A 创建了 Feature 分支进行新的功能开发，这时 A 就是 Feature 的基端。接着 Matser 新增了两个提交 B 和 C， Feature 新增了两个提交 D 和 E。现在我们出于某种原因，比如新功能的开发依赖 B、C 提交，需要将 Master 的两个新提交整合到 Feature 分支，为了保持提交历史的整洁，我们可以切换到 Feature 分支执行 rebase 操作：\n1 git rebase master\t# 在Feature分支上执行 git rebase master 操作 rebase 的执行过程是首先找到这两个分支（即当前分支 Feature、 rebase 操作的目标基底分支 Master） 的最近共同祖先提交 A，然后对比当前分支相对于该祖先提交的历次提交（D 和 E），提取相应的修改并存为临时文件，然后将当前分支指向目标基底 Master 所指向的提交 C, 最后以此作为新的基端将之前另存为临时文件的修改依序应用。\n我们也可以按上文理解成将 Feature 分支的基础从提交 A 改成了提交 C，看起来就像是从提交 C 创建了该分支，并提交了 D 和 E。但实际上这只是「看起来」，在内部 Git 复制了提交 D 和 E 的内容，创建新的提交 D\u0026rsquo; 和 E\u0026rsquo; 并将其应用到特定基础上（A→B→C）。尽管新的 Feature 分支和之前看起来是一样的，但它是由全新的提交组成的。\nrebase 操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交(commitID不同)。\n1 2 # 在develop分支上执行rebase操作 git rebase master rebase主要用途 rebase 通常用于重写提交历史。下面的使用场景在大多数 Git 工作流中是十分常见的：\n我们从 master 分支拉取了一条 feature 分支在本地进行功能开发 远程的 master 分支在之后又合并了一些新的提交 我们想在 feature 分支集成 master 的最新更改 rebase 和 merge 的区别 以上场景同样可以使用 merge 来达成目的，但使用 rebase 可以使我们保持一个线性且更加整洁的提交历史。假设我们有如下分支：\n1 2 3 D---E feature / A---B---C master 现在我们将分别使用 merge 和 rebase，把 master 分支的 B、C 提交集成到 feature 分支，并在 feature 分支新增一个提交 F，然后再将 feature 分支合入 master ，最后对比两种方法所形成的提交历史的区别。\n使用 merge\n切换到 feature 分支： git checkout feature。 合并 master 分支的更新： git merge master。 新增一个提交 F： git add . \u0026amp;\u0026amp; git commit -m \u0026quot;commit F\u0026quot; 。 切回 master 分支并执行快进合并： git chekcout master \u0026amp;\u0026amp; git merge feature。 执行过程如下图所示：\n我们将得到如下提交历史：\n1 2 3 4 5 6 7 8 9 * 6fa5484 (HEAD -\u0026gt; master, feature) commit F * 875906b Merge branch \u0026#39;master\u0026#39; into feature |\\ | | 5b05585 commit E | | f5b0fc0 commit D * * d017dff commit C * * 9df916f commit B |/ * cb932a6 commit A 使用 rebase 步骤与使用 merge 基本相同，唯一的区别是第 2 步的命令替换成： git rebase master。\n执行过程如下图所示：\n我们将得到如下提交历史：\n1 2 3 4 5 6 * 74199ce (HEAD -\u0026gt; master, feature) commit F * e7c7111 commit E * d9623b0 commit D * 73deeed commit C * c50221f commit B * ef13725 commit A 可以看到，使用 rebase 方法形成的提交历史是完全线性的，同时相比 merge 方法少了一次 merge 提交，看上去更加整洁。\nrebase上潜在弊端和反对意见 从以上场景来看 rebase 功能非常强大，但我们也需要意识到它不是万能的，甚至对新手来说有些危险，稍有不慎就会发现 git log 里的提交不见了，或者卡在 rebase 的某个步骤不知道如何恢复。\n我们上面已经提到了 rebase 有保持整洁的线性提交历史的优点，但也需要意识到它有以下潜在的弊端：\n如果涉及到已经推送过的提交，需要强制推送才能将本地 rebase 后的提交推送到远程。因此绝对不要在一个公共分支（也就是说还有其他人基于这个分支进行开发）执行 rebase，否则其他人之后执行 git pull 会合并出一条令人困惑的本地提交历史，进一步推送回远程分支后又会将远程的提交历史打乱，较严重的情况下可能会对你的人身安全带来风险。 对新手不友好，新手很有可能在交互模式中误操作「丢失」某些提交（但其实是能够找回的）。 假如你频繁的使用 rebase 来集成主分支的更新，一个潜在的后果是你会遇到越来越多需要合并的冲突。尽管你可以在 rebase 过程中处理这些冲突，但这并非长久之计，更推荐的做法是频繁的合入主分支然后创建新的功能分支，而不是使用一个长时间存在的功能分支。 另外有一些观点是我们应该尽量避免重写提交历史：\n有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n以及频繁的使用 rebase 可能会使从历史提交中定位 bug 变得更加困难，详见 Why you should stop using Git rebase。\ngit rebase 用法详解与工作原理\ngit rebase 变基\n六. 开发中分支使用原则与流程 几乎所有的版本控制系统都以某种形式支持分支。\n使用分支意味着你可以把你的工作从开发主线上分离开来进行.\n重大的Bug修改、开发新的功能，以免影响开发主线。\n在开发中，一般有如下分支使用原则与流程：\n1. master分支(生产环境) 线上分支，主分支，中小规模项目作为线上运行的应用对应的分支; 需要确保master分支的稳定性, 一般不会再master分支上直接进行开发. 一般不会删除master主分支 2. develop分支(开发环境) 是从master创建的分支，一般作为开发部门的主要开发分支. 开发新功能一般都在develop分支上开发 如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。 一般也不会删除develop分支 3. feature(特征分支) 从develop创建的分支, 为了完成不同的开发需求 一般是同期并行开发，但不同期上线时创建的分支 分支上的研发任务完成后合并到develop分支。 测试通过后,合并到develop分支后, 可以删除该分支 4. hotfix(BUG修复分支) 从master派生的分支，一般作为线上bug修复使用 修复完成后需要合并到master、test、develop分支。 BUG修复完成并合并完成后可以删除该分支 5. test分支(测试分支)等其他分支 test主要是用于测试 可以删除 6. 分支示意图 git使用远端仓库强制覆盖本地仓库\n1 2 3 git fetch --all #将远端仓库的所有抓取下来 git reset --hard origin/[分支名称]\t#版本回退 git pull #重新拉取并合并 git本地强制覆盖远程 说明分支情况\n1 git push origin [分支名称] --force\t#强制推送到分支，谨慎使用 七. Git远程仓库 常见的代码托管服务 GitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名GitHub Gitee（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快, 但是存在代码审核, 有存在代码审核不通过的危险. GitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务，一般用于在企业、学校等内部网络搭建git私服。\nGitea (地址: https://about.gitea.com/)是一个轻量级的DevOps平台软件，它支持Git托管、代码审查、团队协作、软件包注册和CI/CD等功能。与GitHub和GitLab相比，Gitea的一个显著特点是它提供了自托管的能力，这意味着用户可以完全控制自己的仓库和基础设施，而不需要依赖外部服务提供商。此外，Gitea的设计目标是易于安装和使用，它的性能出色，能够快速响应各种请求，保证用户体验\n企业中开发一般使用的是GitLab, 可以使用自己的机房来搭建,自己的代码自己来托管\ngithub一般是很多的开源项目的服务托管平台(国内一般使用的是Gitee)\nGit远程仓库的SSH配置 GitHub 配置 SSH Key 的步骤及原理解释 ssh key 的配置是针对每台主机的！比如我在某台主机上操作 git 和我的远程仓库，想要 push 时不输入账号密码，走 ssh 协议，就需要配置 ssh key，放上去的 key 是当前主机的 ssh 公钥。那么如果我换了一台其他主机，想要实现无密登录，也就需要重新配置。\n1.创建远程仓库 2.配置SSH公钥 生成SSH公钥\n1 ssh-keygen -t rsa\t#使用rsa方式生成非对称秘钥 注意: 如果公钥已经存在,则自动覆盖\n在用户目录下的 .ssh 目录下会生成相应的公钥id_rsa.pub\n将生成的公钥id_rsa.pub内容复制到代码托管平台上\n点击确定后输入密码后就配置好了公钥, 可以在gitbash中测试是否配置成功\n1 ssh -T git@gitee.com\t#需要输入 yes 操作远程仓库 1.添加远程仓库 1 git remote add [远端仓库名] [ssh远程仓库地址]\t#一般远端仓库名都为 origin 1 git remote add [远端仓库名] [https远程仓库地址] #一般远端仓库名都为 origin 1 git remote add origin git@gitee.com:abin_z/git-demo.git\t#origin仅仅是远端仓库名, 还没有远端分支名 取消本地目录下关联的远程库\n1 git remote remove [远程仓库名] # 案例: git remote remove origin, 会取消本地仓库与远程仓库的关联 2.查看远程仓库 1 2 git remote #查看当前所有的远程仓库的名称 git remote -v\t#查看远程仓库的名称和远程仓库的网址 3.推送到远程仓库 在推送(push)操作之前，如想要检查文件代码变化，可使用git show [commitID] 命令指定提交ID来查看具体的变化。\n1 git push [-f] [--set-upstream] [远端分支名 [本地分支名]:[远端分支名]]\t-f 表示强制推送\n如果远程分支名和本地分支名一致,则可以只写本地分支名\n1 git push origin master \u0026ndash;set-upstream 表示在推送到远端的同时并建立起本地分支和远端分支的追踪关系\n1 git push --set-upstream origin master 如果当前分支已经和远端分支关联,则可以省略分支名和远端名\n1 git push\t#将master分支推送到远端的master分支 1 git push --set-upstream origin master 4.关联远程分支 1 2 3 4 5 6 7 ## 建立当前分支与指定远程分支的追踪关系，但不会拉取代码。参数\u0026#34;-u\u0026#34;和\u0026#34;--set-upstream-to\u0026#34;同样的意思。 $ git branch -u \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; $ git branch --set-upstream-to \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; git branch -vv #用于查看本地分支与远端分支的绑定情况 git push --set-upstream origin master:master\t#推送的同时建立追踪关系 创建本地分支来跟踪并拉取远程分支 git switch -c、git checkout -b、git branch \u0026ndash;track\n1 2 3 4 ## 该命令创建本地分支跟踪分支\u0026lt;本地分支名\u0026gt;，并从远程分支\u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt;拉取代码。 git switch -c \u0026lt;本地分支名\u0026gt; \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; git checkout -b \u0026lt;本地分支名\u0026gt; \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; git branch --track \u0026lt;本地分支名\u0026gt; \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; 5.从远程仓库克隆 1 git clone [远端地址] 克隆成功! 克隆后的目录和远端是一样的(一般克隆操作只需要使用一次就可以)\n6.从远程仓库抓取和拉取 fetch抓取, 将仓库里的更新都抓取到本地,但是不进行合并 如果不指定远端名称和分支, 则抓取所有分支修改 1 git fetch [remote name] [branch name] pull拉取, 将远程仓库的修改拉取到本地并自动进行合并,类似于: pull = fetch + merge 如果不指定远端名称和分支, 则抓取所有分支修改并自动合并 1 git pull #抓取并自动合并 7.解决合并冲突 发送冲突的情况:\n​\t在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支,如下图所示。\n在B用户拉取代码时，因为A、B用户同一段时间修改了同一个文件的相同位置代码，故会发生合并冲突。 远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同，但是解决冲突时需要在本地解决\n此时需要先pull然后在push\n8.配置git代理(访问github) 1. 配置 HTTP/HTTPS 代理 配置步骤\n打开终端（Command Prompt、PowerShell 或 Git Bash）。\n配置 HTTP 和 HTTPS 代理：\n1 2 git config --global http.proxy http://127.0.0.1:10809 git config --global https.proxy http://127.0.0.1:10809 127.0.0.1:10809 为代理服务器的地址和端口。 验证配置：\n1 2 git config --global --get http.proxy git config --global --get https.proxy 应返回 http://127.0.0.1:10809。 测试代理是否生效：\n1 git clone https://github.com/git/git.git 如果可以正常克隆，说明代理配置成功。 取消代理配置\n如果需要取消代理配置，执行以下命令：\n1 2 git config --global --unset http.proxy git config --global --unset https.proxy 或者清除所有代理配置：\n1 2 git config --global --remove-section http git config --global --remove-section https 2. 仅对 GitHub 使用代理 配置步骤\n配置 GitHub 专用代理：\n1 git config --global http.https://github.com.proxy http://127.0.0.1:10809 此配置仅对 https://github.com 的请求启用代理。 验证配置：\n1 git config --global --get http.https://github.com.proxy 应返回 http://127.0.0.1:10809。 测试：\n克隆 GitHub 仓库：\n1 git clone https://github.com/git/git.git 克隆其他仓库（如 GitLab）测试是否不使用代理：\n1 git clone https://gitlab.com/gitlab-org/git.git 取消 GitHub 专用代理：\n1 git config --global --unset http.https://github.com.proxy 3. 配置 SSH 协议通过代理 SSH 默认行为\nGit 使用 SSH 协议（如 git@github.com:username/repository.git）时，不会走 HTTP/HTTPS 代理。 需配置 SSH 客户端单独使用代理。 配置步骤\n检查代理类型\n确认你的代理服务支持的协议（HTTP 或 SOCKS5）。 如果是 SOCKS5 代理，配置可能会有所不同。 编辑 SSH 配置文件\n打开或创建 SSH 配置文件：\n1 vim ~/.ssh/config 添加以下内容：\n1 2 3 4 Host github.com Hostname github.com User git ProxyCommand nc -X connect -x 127.0.0.1:10808 %h %p ProxyCommand 表示通过代理连接目标主机。 -X connect 指定使用 HTTP CONNECT 模式。 -x 127.0.0.1:10809 是代理服务器的地址和端口。 %h 和 %p 分别代表目标主机和端口。 如果使用的是 SOCKS5 代理，改为：\n1 ProxyCommand nc -X 5 -x 127.0.0.1:10808 %h %p -X 5 指定使用 SOCKS5 协议。 这是本人使用的config配置(win系统, 安装了nmap, 使用其中的ncat):\n1 2 3 4 5 6 # SSH 配置 - github.com Host github.com HostName ssh.github.com Port 443 User git ProxyCommand ncat --proxy-type socks5 --proxy 127.0.0.1:10808 %h %p 安装 netcat 工具（如需要）\n某些系统可能需要安装 netcat 工具（如 nc）。\n在 Debian/Ubuntu 系统上安装：\n1 sudo apt-get install netcat 在 CentOS/RHEL 系统上安装：\n1 sudo yum install nc 测试 SSH 配置\n测试 SSH 是否通过代理连接：\n1 ssh -T git@github.com 返回 Hi username! You've successfully authenticated 说明配置成功。 代理调试\n如果连接失败： 确认代理服务是否运行正常。 检查 SSH 配置文件路径和语法是否正确。 查看代理日志，排查问题。 取消 SSH 代理配置\n删除或注释掉 ~/.ssh/config 中的相关配置。\n示例：\n1 2 3 4 # Host github.com # Hostname github.com # User git # ProxyCommand nc -X connect -x 127.0.0.1:10808 %h %p 高级配置（可选）\n为多个主机设置代理\n如果需要为多个主机配置代理，可以使用通配符：\n1 2 Host *.example.com ProxyCommand nc -X connect -x 127.0.0.1:10808 %h %p 仅特定网络环境启用代理\n可以使用脚本动态修改 ~/.ssh/config，根据网络环境启用或禁用代理。 4. 注意事项 SOCKS5 代理\n如果使用 SOCKS5 代理：\nGit 配置：\n1 2 git config --global http.proxy socks5h://127.0.0.1:10808 git config --global https.proxy socks5h://127.0.0.1:10808 SSH 配置：\n1 ProxyCommand nc -X 5 -x 127.0.0.1:10808 %h %p 按需配置\n为特定域名设置代理（如 GitHub），其他域名不走代理。 避免为所有流量配置代理，减少不必要的延迟。 调试代理\n使用 curl 测试代理：\n1 curl -x http://127.0.0.1:10808 https://www.google.com 检查代理服务日志，确保流量通过代理。\n八. Git其他操作 1. 恢复暂存区的指定文件到工作区：git checkout 1 2 3 4 5 6 7 8 9 10 11 ## 恢复暂存区的指定文件到工作区 $ git checkout -- [file] $ git checkout [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] ## 注意：git add然后git commit后，认为暂存区和本地仓库一致。克隆文件下来时，认为暂存区和远程仓库一致 1 2 3 git checkout -- [filename]\t#将filename文件从暂存区恢复到工作区.会导致工作区修改丢失, 使用时慎重 git checkout [filename]\t#将filename文件从暂存区恢复到工作区.会导致工作区修改丢失, 使用时慎重 git checkout .\t#将暂存区的所有文件恢复到工作区,会导致工作区修改丢失, 使用时慎重 2. 在远程仓库新建分支 git是无法直接在远程仓库直接新建分支的,\n但是可以通过新建本地分支+推送本地分支到远程达到新建远程分支目的\ngit branch + git push\n在本地创建develop分支\n1 $ git branch develop 将创建的develop分支推送到远端仓库: 远程没有develop分支,但是将本地的develop分支推送到远端仓库, 就会在远程仓库中新建一个develop分支\n1 $ git push origin develop #将本地的提交到远程仓库，如果远程没有相依的分支则创建 3.删除远程仓库的分支 git push origin \u0026ndash;delete [name]\n仅仅删除远程仓库的叫[name]的分支, 同名的本地分支不会被删除, 要删除本地同名的本地分支还需要单独删除\n1 $ git push origin --delete test 事先已经创建好了远程分支: test, feature\n4.用本地分支追踪远程仓库分支(建立追踪关系) 建立当前分支与指定远程分支的追踪关系，但不会拉取代码。\ngit branch \u0026ndash;set-upstream-to \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt;\n1 2 3 4 5 6 ## 建立当前分支与指定远程分支的追踪关系，但不会拉取代码。参数\u0026#34;-u\u0026#34;和\u0026#34;--set-upstream-to\u0026#34;同样的意思。 $ git branch -u \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; $ git branch --set-upstream-to \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; ================================================== $ git push --set-upstream \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt; #在push的同时也建立当前分支与的远端分支的追踪关系（会新建远程分支） 5.删除 git branch -r 列表中的追踪分支 git branch -dr / 没有删除远程分支，只是删除 git branch -r 列表中的追踪分支。\n1 git branch -dr origin/feature\t#并不是删除远程分支, 仅仅是删除git branch -r中的追踪分支 6.把远程分支的最新情况拉取到本地 git fetch -p\n1 $ git fetch -p 7.创建本地分支来跟踪并拉取远程分支 1 2 3 4 ## 该命令创建本地分支跟踪分支\u0026lt;本地分支名\u0026gt;，并从远程分支\u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt;拉取代码。 git switch -c \u0026lt;本地分支名\u0026gt; \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; git checkout -b \u0026lt;本地分支名\u0026gt; \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; git branch --track \u0026lt;本地分支名\u0026gt; \u0026lt;远程主机名\u0026gt;/\u0026lt;远程分支名\u0026gt; 8.一个git项目多个远程仓库 在我们的git项目中，操作远程仓库信息的命令为\n1 2 $ git remote # 查看当前所有的远程仓库的名称 $ git remote -v # 查看远程仓库的名称和远程仓库的网址 一般情况下，当我们从远程仓库中克隆下一个项目来之后。默认的远程仓库名是 origin\n1 2 3 4 5 6 7 8 $ git clone https://github.com/onmpw/JYGO.git $ cd JYGO $ git remote origin $ git remote -v origin https://github.com/onmpw/JYGO.git (fetch) origin https://github.com/onmpw/JYGO.git (push) 当pull 或者 push 的时候默认使用的都是origin远程仓库\n1 2 3 $ git pull origin master # 或者 git pull $ git push origin master # 或者 git push 怎么给这个项目再添加一个远程仓库呢？使用git remote add 命令。\n方法一、 git remote add 1 $ git remote add local git@localhost:workspace/repo/JYGO2.git 上面的local 和 origin一样，也是远程仓库的名称\n1 2 3 4 5 $ git remote -v origin https://github.com/onmpw/JYGO.git (fetch) origin https://github.com/onmpw/JYGO.git local git@localhost:workspace/repo/JYGO2.git (fetch) local git@localhost:workspace/repo/JYGO2.git (push) 添加成功之后，以后再使用git push的时候，就可以根据需要推送到需要的远程仓库中。如果需要推送到两个仓库中，则执行两边 git push\n1 2 3 4 5 6 7 8 9 10 $ git push origin master # 默认的origin远程仓库 $ git push local master # 新添加的 local 远程仓库 To git@localhost:workspace/repo/JYGO2.git ! [rejected] master -\u0026gt; master (fetch first) error: failed to push some refs to \u0026#39;git@localhost:workspace/repo/JYGO2.git\u0026#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., \u0026#39;git pull ...\u0026#39;) before pushing again. hint: See the \u0026#39;Note about fast-forwards\u0026#39; in \u0026#39;git push --help\u0026#39; for details. push没有成功！怎么会出现这种情况呢。原来在使用git remote add 添加完远程仓库之后，其实是不能直接推送到远程仓库的。也就是说开始的时候，上面第二条命令是执行不成功的。因为这时候你本地的版本和local远程仓库的版本是不一致的，需要从local上获取最新的代码。也就是说在执行 push 之前需要先从local上拉取最新的内容。\n1 2 3 4 5 6 $ git pull local master Unpacking objects: 100% (3/3), done. From git@localhost:workspace/repo/JYGO2.git * branch master -\u0026gt; FETCH_HEAD * [new branch] master -\u0026gt; github/master fatal: refusing to merge unrelated histories 是的，仅仅使用上面的命令也是不会成功的。需要使用下面的命令\n1 $ git pull --allow-unrelated-histories local master 顺利执行成功。然后再使用 push 就可以推送到远程仓库了。\n1 $ git push local master 成功了。 很好。不过问题也随之而来了。如果有多个远程仓库都需要提交，那我们要每个远程仓库都执行一次 git push。有没有一种方法一次push就提交到多个远程仓库呢？答案当然是：这个真有！\n方法二、 git remote set-url \u0026ndash;add 命令 1 $ git remote set-url --add origin git@localhost:workspace/repo/JYGO2.git 上面命令就是给远程仓库origin 再新增一个远程仓库的地址。网上有很多文章写到这就认为，添加完成之后就可以直接使用 git push 命令一次性提交到多个远程仓库了。其实不然，最初始的那个远程仓库push成功是没问题的。但是到了新增的这个地址的时候就会出现推送失败的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ git push --all # 或者 git push origin master 或者直接使用 git push， 都可以。 Enumerating objects: 8, done. Counting objects: 100% (8/8), done. Delta compression using up to 4 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (6/6), 931 bytes | 931.00 KiB/s, done. Total 6 (delta 0), reused 0 (delta 0) To https://github.com/onmpw/JYGO.git c1857d1..ff94cf0 master -\u0026gt; master To git@localhost:workspace/repo/JYGO2.git ! [rejected] master -\u0026gt; master (fetch first) error: failed to push some refs to \u0026#39;git@localhost:workspace/repo/JYGO2.git\u0026#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., \u0026#39;git pull ...\u0026#39;) before pushing again. hint: See the \u0026#39;Note about fast-forwards\u0026#39; in \u0026#39;git push --help\u0026#39; for details. 很明显，还是因为本地和远程版本不同步的问题。也就是说在push 之前需要先 pull 内容。\n1 2 $ git pull Already up to date. 很奇怪，已经是最新的内容了。但是新添加的远程仓库并没有获取过。 其实问题的原因是在同一仓库名称下如果有多个远程仓库地址的话，pull 的时候只会去第一个仓库地址中拉取内容。所以说，我们新添加的远程仓库的内容是不会被获取到的。也就是不能push的。 那这个问题要怎么解决呢？很简单，换成第一种方法，使用 git remote add 来添加远程仓库，从而进行管理。但是，push的时候是比较麻烦。 有没有其他的方法呢？答案还是：这个真有。\n1. 修改配置文件 .git/config 首先，我们知道不管是 git remote add 还是 git remote set-url --add 其实都是来操作项目中的.git/config配置文件(有兴趣可以去看一下该配置文件的内容)。对于 git remote set-url --add 来说，config配置文件的主要部分内容如下\n1 2 3 4 [remote \u0026#34;origin\u0026#34;] url = https://github.com/onmpw/JYGO.git fetch = +refs/heads/*:refs/remotes/github/* url = git@localhost:workspace/repo/JYGO2.git 看到内容了吗，很简单明了。既然pull只是获取第一个远程仓库的内容，那还不好说吗，直接交换二者的位置，改动如下\n1 2 3 4 [remote \u0026#34;origin\u0026#34;] url = git@localhost:workspace/repo/JYGO2.git fetch = +refs/heads/*:refs/remotes/github/* url = https://github.com/onmpw/JYGO.git 然后再使用git pull\n这里需要注意的是，使用git pull的时候，和第一种方法是一样的，也要加上 --allow-unrelated-histories 参数\n1 2 $ git pull $ git push --all 很开心，终于成功了。\n2. 空仓库方法 这种方法很简单。既然内容版本不同步，那就不要有内容。我们新添加的远程仓库要是一个空仓库，不要有任何的文件内容。 网上有人说是因为README.md 文件的问题。其实只是说对了一半。因为在github或者gitlab等平台上，新建仓库的时候可能有些会默认初始化一个README.md文件。像github在新建仓库的时候是会让你选择是否初始化README.md文件的，我们只要不初始化这个文件就行了。当然除了这个默认文件。在我们将这个远程仓库加到我们项目中之前，该仓库中就不要有任何的文件了。只有这样，当我们将远程仓库加到项目中之后才不需要pull就可以直接推送本地内容到该远程仓库了。\n更多更详细教程参考易百教程： https://www.yiibai.com/git\n迹忆客Git教程: https://www.jiyik.com/w/git\n","date":"2023-05-09T23:09:05+08:00","permalink":"https://abin-z.github.io/p/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%A9%E4%BD%A0%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8git/","title":"一篇文章让你熟练使用Git"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://abin-z.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://abin-z.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://abin-z.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://abin-z.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://abin-z.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://abin-z.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://abin-z.github.io/p/emoji-support/","title":"Emoji Support"}]